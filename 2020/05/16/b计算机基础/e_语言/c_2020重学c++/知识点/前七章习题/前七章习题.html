<p>[toc]</p>
<h1 id="第一章："><a href="#第一章：" class="headerlink" title="第一章："></a>第一章：</h1><h2 id="一、基础题"><a href="#一、基础题" class="headerlink" title="一、基础题"></a>一、基础题</h2><ol>
<li><p>请说出C++语言的优点，缺点，和主要用途？（<strong>涉及知识点：1-4节 C++特点， 1-5 C++作用</strong>） </p>
<p>优点：</p>
<ul>
<li>强大的抽象封装能力：这让C++语言具备了强大的开发工程能力，在封装的同时C++最大程度的保留了高性能；</li>
<li>高性能：运行快，快并且占用资源少一直是C++语言的追求；</li>
<li>低功耗：特别适合在各种微型的嵌入式设备中运行高效的程序；</li>
</ul>
<p>缺点：</p>
<ul>
<li>语法相对复杂，细节比较多，学习曲线比较陡；</li>
<li>需要一些好的规范和范式，否则代码很难维护；</li>
</ul>
</li>
</ol>
<h2 id="二、提高题"><a href="#二、提高题" class="headerlink" title="二、提高题"></a>二、提高题</h2><ol>
<li>请参考课程演示代码”CPPDemo1”中的C++面向对象方式，思考C面向过程方式中如何实现trace功能在开关打开状态下写入到文件中，并想想这两种方式各自的优缺点？（<strong>涉及知识点：1-3节 C++vsC，面向对象vs面向过程</strong>） </li>
</ol>
<pre><code class="c"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span>
<span class="keyword">static</span> <span class="keyword">bool</span> trigger;
<span class="function"><span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span></span>
<span class="function"></span>{
    trigger = <span class="literal">true</span>;
}
<span class="function"><span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span></span>
<span class="function"></span>{
    trigger = <span class="literal">false</span>;
}
<span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> n)</span></span>
<span class="function"></span>{
    FILE *fp = fopen(<span class="string">"test.txt"</span>,<span class="string">"a+"</span>);
    <span class="keyword">if</span>(trigger)
    {
        fwrite(s,<span class="number">1</span>,n,fp);
    }
    fclose(fp);
}
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>
<span class="function"></span>{
    turnOn();
    <span class="built_in">write</span>(<span class="string">"First"</span>,<span class="number">5</span>);
    turnOff();
    <span class="built_in">write</span>(<span class="string">"Second"</span>,<span class="number">6</span>);
}</code></pre>
<p>c语言需要用全局变量和全局函数来实现，在稍微大一些的项目中，将会产生难以维护，难以扩展，难以阅读的问题，而C++封装对象的方式就可以解决这些问题。</p>
<p>c语言在内存方面占用更小。在微型项目中编写更加方便。</p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="一、基础题-1"><a href="#一、基础题-1" class="headerlink" title="一、基础题"></a>一、基础题</h2><ol>
<li>下面标识符是合法的有哪些（BEF ） （<strong>涉及知识点： 2-5 标识符与关键字</strong>）<br><strong>A</strong>.float<br><strong>B</strong>.ipad<br><strong>C</strong>.1button<br><strong>D</strong>. A#BC<br><strong>E</strong>.my_button<br><strong>F</strong>. button_1_ok </li>
<li>请给一个退出按钮命一个好变量名（ C）（<strong>涉及知识点： 2-5 标识符</strong>）<br><strong>A</strong>. 1button<br><strong>B</strong>. button1<br><strong>C</strong>.buttonQuit<br><strong>D</strong>.button_tuichu </li>
<li>下面整数常量合法的是（ D）（<strong>涉及知识点： 2-6 常量</strong>）<br><strong>A</strong>.078<br><strong>B</strong>.03UU<br><strong>C</strong>.0x9AHX<br><strong>D</strong>.0xFFAA00 </li>
</ol>
<h2 id="二、提高题-1"><a href="#二、提高题-1" class="headerlink" title="二、提高题"></a>二、提高题</h2><ol>
<li><p>下面程序输出结果是    (8)（<strong>涉及知识点： 2-6 常量的宏定义</strong>）</p>
<pre><code class="c++"><span class="meta">#<span class="meta-keyword">define</span> MA(x) x*(x-1)</span>
<span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>
<span class="function"></span>{
  <span class="keyword">int</span> a=<span class="number">1</span>, b=<span class="number">2</span>;
  <span class="built_in">cout</span> &lt;&lt; MA(<span class="number">1</span>+a+b) &lt;&lt; <span class="built_in">endl</span>;
}  <span class="comment">// 8</span>
   <span class="comment">//ma(1+a+b) = 1+a+b*(1+a +b-1)</span>
   <span class="comment">//            = 1+1+2*(1+1+2-1)</span>
   <span class="comment">//            = 8</span></code></pre>
</li>
</ol>
<h1 id="第三章："><a href="#第三章：" class="headerlink" title="第三章："></a>第三章：</h1><h2 id="一、填空"><a href="#一、填空" class="headerlink" title="一、填空"></a>一、填空</h2><ol>
<li><pre><code class="c++"><span class="built_in">cout</span> &lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//1</span>
<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(short) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//2</span>
<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//4</span>
<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//4</span>
<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//8</span></code></pre>
</li>
<li><pre><code class="c++">a = (x=<span class="number">10</span>,y=<span class="number">20</span>,z=x+y);
<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//30   逗号返回最后一个值</span></code></pre>
</li>
<li><pre><code class="c++"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span>
short Sunday = <span class="number">0</span>;
short Monday = <span class="number">1</span>;
short Tuesday = <span class="number">2</span>;
short Wednesday = <span class="number">3</span>;
short Thursday = <span class="number">4</span>;
short Friday = <span class="number">5</span>;
short Saturday = <span class="number">6</span>;
} Week;
Week w;
<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(w.Sunday); <span class="comment">//2</span>
<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(w) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//14</span></code></pre>
</li>
</ol>
<h2 id="二、编程题"><a href="#二、编程题" class="headerlink" title="二、编程题"></a>二、编程题</h2><ol>
<li><p>使用#define 编写一段代码，来实现“标准”宏MIN</p>
<pre><code class="c++"><span class="meta">#<span class="meta-keyword">define</span> MIN(a,b) (((a)&gt;=(b))?(b):(a))         <span class="comment">//a,b可能为式子，故需单独加括号</span></span></code></pre>
</li>
<li><p>分别写出bool 、int、 float、与“零值”比较，表达式返回值等于1的代码片段；</p>
<pre><code class="c++">#设变量为flag
<span class="comment">////////////////////////////////////////////////////////////////////////</span>
<span class="keyword">bool</span>:
    <span class="keyword">if</span>(flag)
<span class="keyword">int</span>:
    <span class="keyword">if</span>(flag == <span class="number">0</span>)
 <span class="keyword">double</span>:
    <span class="keyword">const</span> <span class="keyword">double</span> EPSINON = <span class="number">0.00001</span>;  
 <span class="keyword">if</span> ((flag &gt;= - EPSINON) &amp;&amp; (flag &lt;= EPSINON))
<span class="keyword">char</span> *:
    <span class="keyword">if</span> (flag == <span class="literal">NULL</span>)</code></pre>
</li>
</ol>
<h1 id="第四五六章："><a href="#第四五六章：" class="headerlink" title="第四五六章："></a>第四五六章：</h1><h2 id="一、程序运行题"><a href="#一、程序运行题" class="headerlink" title="一、程序运行题"></a>一、程序运行题</h2><ol>
<li>请说出下列问号处的结果：<pre><code>char str[] = “Hello” ;
char *p = str ;
int n = 10;
//请计算
sizeof (str ) = ?
sizeof ( p )  = ?
sizeof ( n )  = ?
void Func ( char str[100])
{
//请计算
    sizeof( str ) = ?
}</code></pre></li>
</ol>
<p><strong>答：<br>    sizeof (str ) = 6<br>    sizeof ( p ) = 4<br>    sizeof ( n ) = 4<br>    void Func ( char str[100])<br>    {<br>      sizeof( str ) = 4<br>    }</strong></p>
<ol start="2">
<li><pre><code>void GetMemory(char *p)
{
    p = new char[100];
}
void Test(void)
{
    char *str = NULL;
    GetMemory(str);
    strcpy(str, &quot;hello world&quot;);
    printf(str);
}</code></pre> 问运行Test 函数会有什么样的结果？</li>
</ol>
<p><strong>答：程序崩溃。因为GetMemory 并不能传递动态内存，<br>Test 函数中的 str 一直都是 NULL。strcpy(str, “hello world”);将使程序崩溃。</strong></p>
<ol start="3">
<li><pre><code>char *GetMemory(void)
{
    char p[] = &quot;hello world&quot;;
    return p;
}
void Test(void)
{
    char *str = NULL;
    str = GetMemory();
    printf(str);
}</code></pre>请问运行Test 函数会有什么样的结果？</li>
</ol>
<p><strong>答：可能是乱码;因为GetMemory 返回的是指向“栈内存”的指针，该指针的地址不是 NULL，但其原现的内容已经被清除，新内容不可知。</strong></p>
<ol start="4">
<li><pre><code>void GetMemory2(char **p, int num)
{
    *p = new char[num];
}
void Test(void)
{
    char *str = NULL;
    GetMemory2(&amp;str, 100);
    strcpy(str, &quot;hello&quot;);
    printf(str);
}</code></pre>请问运行Test 函数会有什么样的结果？<br> *<em>答：能够输出hello，但内存泄漏 *</em></li>
</ol>
<ol start="5">
<li><pre><code># include &lt;string.h&gt;
 void Test(void)
 {
     char *str = new  char[100];
     strcpy(str, &quot;hello&quot;);
     delete[ ] str;
     if (str != NULL)
     {
         strcpy(str,&quot;world&quot;);
         printf(str);
     }
 }</code></pre>请问运行Test 函数会有什么样的结果？<br> <strong>答：篡改动态内存区的内容，后果难以预料，非常危险。因为 delete[ ]str;之后，str成为野指针(需要str = NULL;)if(str != NULL)语句不起作用。</strong></li>
</ol>
<h2 id="二、编程题-1"><a href="#二、编程题-1" class="headerlink" title="二、编程题"></a>二、编程题</h2><ol>
<li>char *strcpy(char *strDest, const char *strSrc)不调用C++/C 的字符串库函数，请编写函数 strcpy；<pre><code>char *strcpy(char *strDest, const char *strSrc);
{
assert((strDest!=NULL) &amp;&amp; (strSrc !=NULL));
char *address = strDest; 
while( (*strDest++ = * strSrc++) != ‘\0’ )
   ;
return address ; 
}</code></pre><h1 id="第七章："><a href="#第七章：" class="headerlink" title="第七章："></a>第七章：</h1></li>
</ol>
<h2 id="一、编程题"><a href="#一、编程题" class="headerlink" title="一、编程题"></a>一、编程题</h2><p>编写自定义类String 的构造函数、析构函数和赋值函数。<br>已知类String 的原型为：<br>class String<br>{<br>public:<br>    String(const char *str = NULL);                             // 普通构造函数<br>    String(const String &amp;other);                                  // 拷贝构造函数<br>    String(String&amp;&amp; other);                                          // 移动构造函数<br>    ~String(void);                                                            // 析构函数<br>    String&amp; operator= (const String&amp; other);             // 赋值函数<br>    String&amp; operator=(String&amp;&amp; rhs)noexcept;          // 移动赋值运算符<br>private:<br>    char *m_data; // 用于保存字符串<br>};<br>请编写String 的上述几个函数。</p>
<pre><code>// String 的析构函数
String::~String(void)
{
    if (m_data != NULL)
    {
        delete[] m_data;
    }
}

// String 的普通构造函数
String::String(const char *str)
{
    if (str == NULL)
    {
        m_data = new char[1];
        if (m_data != NULL)
        {
            *m_data = &apos;\0&apos;;
        }
        else
        {
            exit(-1); // new有可能失败，失败后返回错误退出, 最好能有日志
        }
    }
    else
    {
        int length = strlen(str);
        m_data = new char[length + 1];
        if (m_data != NULL)
        {
            *m_data = &apos;\0&apos;;
        }
        else
        {
            exit(-1); // new有可能失败，失败后返回错误退出, 最好能有日志
        }
        strcpy(m_data, str);
    }
}
// 拷贝构造函数
String::String(const String &amp;other)
{
    int length = strlen(other.m_data);
    m_data = new char[length + 1];
    if (m_data != NULL)
    {
        *m_data = &apos;\0&apos;;
    }
    else
    {
        exit(-1); // new有可能失败，失败后返回错误退出, 最好能有日志
    }
    strcpy(m_data, other.m_data);
}

String::String(String&amp;&amp; other)
{
    if (other.m_data != NULL)
    {
        m_data=other.m_data;
        other.m_data = NULL;
    }
}


// 赋值函数
String&amp; String::operator= (const String &amp;other)
{
    // 检查自赋值
    if (this == &amp;other)
        return *this;
    // 释放原有的内存资源 
    delete[] m_data;
    // 分配新的内存资源，并复制内容
    int length = strlen(other.m_data);
    m_data = new char[length + 1];
    if (m_data != NULL)
    {
        *m_data = &apos;\0&apos;;
    }
    else
    {
        exit(-1); // new有可能失败，失败后返回错误退出, 最好能有日志
    }
    strcpy(m_data, other.m_data);
    //  返回本对象的引用
    return *this;
}

String&amp; String::operator=(String&amp;&amp; rhs)noexcept
{
    if (this != &amp;rhs)
    {
        delete[] m_data;
        m_data = rhs.m_data;
        rhs.m_data = NULL;
    }
    return *this;
}</code></pre>