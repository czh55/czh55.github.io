<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenzhiheng.cn","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="陈志恒的技术博客">
<meta property="og:url" content="http://chenzhiheng.cn/page/2/index.html">
<meta property="og:site_name" content="陈志恒的技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhiheng Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://chenzhiheng.cn/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>陈志恒的技术博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6bc779d0e3be483fc01e871fbb7cef3d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">陈志恒的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/27/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E7%AE%97%E6%B3%95/leetcode/%E9%A2%98%E7%9B%AE/[%E6%91%98%E6%8A%84]map%E7%9A%84%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/27/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E7%AE%97%E6%B3%95/leetcode/%E9%A2%98%E7%9B%AE/%5B%E6%91%98%E6%8A%84%5Dmap%E7%9A%84%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">摘抄map的排序</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-27 06:45:00" itemprop="dateCreated datePublished" datetime="2020-04-27T06:45:00+08:00">2020-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 16:19:51" itemprop="dateModified" datetime="2020-05-04T16:19:51+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E7%AE%97%E6%B3%95-leetcode-%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_算法/leetcode/题目</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/27/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E7%AE%97%E6%B3%95/leetcode/%E9%A2%98%E7%9B%AE/%5B%E6%91%98%E6%8A%84%5Dmap%E7%9A%84%E6%8E%92%E5%BA%8F/" class="post-meta-item leancloud_visitors" data-flag-title="摘抄map的排序" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月27日 下午6:45</p>
<p><a href="https://www.cnblogs.com/eilearn/p/9473804.html" target="_blank" rel="noopener">C++（十三）— map的排序 - 深度机器学习 - 博客园</a></p>
<h4 id="对有序map中的key排序"><a href="#对有序map中的key排序" class="headerlink" title="对有序map中的key排序"></a>对有序map中的key排序</h4><ul>
<li>map这里指定less作为其默认比较函数(对象),就是默认按键值升序排列</li>
<li>可以自定义，按照键值升序排列，注意加载</li>
<li>按照自定义内容进行排序，比如字符串的长度<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; // std::greater</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CmpByKeyLength</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; k1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; k2)</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k1.length() &lt; k2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、map这里指定less作为其默认比较函数(对象),就是默认按键值升序排列</span></span><br><span class="line">    <span class="comment">// map&lt;string, int&gt; name_score_map;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、可以自定义，按照键值升序排列，注意加载 </span></span><br><span class="line">    <span class="comment">// #include &lt;functional&gt; // std::greater</span></span><br><span class="line">    <span class="comment">// map&lt;string, int, greater&lt;string&gt;&gt; name_score_map;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、按照自定义内容进行排序，比如字符串的长度</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>, CmpByKeyLength&gt; name_score_map;</span><br><span class="line"></span><br><span class="line">    name_score_map[<span class="string">"LiMin"</span>] = <span class="number">90</span>;</span><br><span class="line">    name_score_map[<span class="string">"ZiLinMi"</span>] = <span class="number">79</span>;</span><br><span class="line">    name_score_map[<span class="string">"BoB"</span>] = <span class="number">92</span>;</span><br><span class="line">    name_score_map.insert(make_pair(<span class="string">"Bing"</span>, <span class="number">99</span>));</span><br><span class="line">    name_score_map.insert(make_pair(<span class="string">"Albert"</span>, <span class="number">86</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span> ( iter = name_score_map.<span class="built_in">begin</span>();iter != name_score_map.<span class="built_in">end</span>();++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*iter).first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="对有序map中的value排序"><a href="#对有序map中的value排序" class="headerlink" title="对有序map中的value排序"></a>对有序map中的value排序</h4><ul>
<li>把map中的元素放到序列容器（如vector）中，再用sort进行排序。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; // std::greater</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、map这里指定less作为其默认比较函数(对象),就是默认按键值升序排列</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; name_score_map;</span><br><span class="line">    name_score_map[<span class="string">"LiMin"</span>] = <span class="number">90</span>;</span><br><span class="line">    name_score_map[<span class="string">"ZiLinMi"</span>] = <span class="number">79</span>;</span><br><span class="line">    name_score_map[<span class="string">"BoB"</span>] = <span class="number">92</span>;</span><br><span class="line">    name_score_map.insert(make_pair(<span class="string">"Bing"</span>, <span class="number">99</span>));</span><br><span class="line">    name_score_map.insert(make_pair(<span class="string">"Albert"</span>, <span class="number">86</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出添加的内容</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span> (iter = name_score_map.<span class="built_in">begin</span>(); iter != name_score_map.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*iter).first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将map中的内容转存到vector中</span></span><br><span class="line">    vector&lt;pair&lt;string, int&gt;&gt; vec(name_score_map.begin(), name_score_map.end());</span><br><span class="line">    <span class="comment">//对线性的vector进行排序</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; vec[i].first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/26/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/%E7%8E%B0%E4%BB%A3C++/%E4%B8%B2%E8%AE%B2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB%E3%80%81%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E3%80%81OOP%E3%80%81%E6%A8%A1%E6%9D%BF%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/26/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/%E7%8E%B0%E4%BB%A3C++/%E4%B8%B2%E8%AE%B2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB%E3%80%81%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E3%80%81OOP%E3%80%81%E6%A8%A1%E6%9D%BF%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">串讲：基本关键字、类型转换、运行时类型识别、重载运算、OOP、模板泛型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-26 09:37:00" itemprop="dateCreated datePublished" datetime="2020-04-26T09:37:00+08:00">2020-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 16:19:50" itemprop="dateModified" datetime="2020-05-04T16:19:50+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AF%AD%E8%A8%80-%E7%8E%B0%E4%BB%A3C/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_语言/现代C++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/26/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/%E7%8E%B0%E4%BB%A3C++/%E4%B8%B2%E8%AE%B2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB%E3%80%81%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E3%80%81OOP%E3%80%81%E6%A8%A1%E6%9D%BF%E6%B3%9B%E5%9E%8B/" class="post-meta-item leancloud_visitors" data-flag-title="串讲：基本关键字、类型转换、运行时类型识别、重载运算、OOP、模板泛型" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月26日 上午9:37</p>
<h4 id="基本关键字："><a href="#基本关键字：" class="headerlink" title="基本关键字："></a>基本关键字：</h4><ul>
<li>C++这个框架提供给用户的功能接口。也需要并不像我们熟悉的开发框架，是通过给函数传参数进行功能的封装和调用，语言框架他是利用设计的语法 + 编译器的处理，最终达到的功能接口的作用。框架思想是理解C++的关键角度之一。<br>附：</li>
<li><a href="https://www.cnblogs.com/iloveyoucc/archive/2012/03/18/2404658.html" target="_blank" rel="noopener">#define和inline 的区别 - cbwcwy - 博客园</a></li>
</ul>
<h4 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a>类型转换：</h4><ul>
<li>首先，需要说明的是类型和类别的区别</li>
<li>另外，类型转换分为两个大类，编译器自动转换，手动关键字转换。自动类型转换对于不同的语法类型，编译器本身就定死了一些规则，当满足条件触发时，就会按既定的步骤进行类型转换。而手动类型转换，需要我们使用一些运算符，一般来说，如果在开发过程中需要使用手动类型转换才可以完成一些功能时，都是我们不合理的设计代码引起的，这时我们需要去修改我们原有的设计，而不是去使用手动类型转换</li>
</ul>
<h4 id="运行时类型识别："><a href="#运行时类型识别：" class="headerlink" title="运行时类型识别："></a>运行时类型识别：</h4><ul>
<li>只有一种使用场景：我们有基类的指针，需要在继承类中调用基类中没有标志位virtual的成员方法。<ul>
<li>编译器也给我们留了对应的功能接口：dynamic_cast运算符。但是一般来说，出现这样的需求时，我们可以通过合理的重新设计代码逻辑，从而不需要这样的接口。</li>
</ul>
</li>
<li>关于typeid运算符<ul>
<li>在编译阶段会自动插入一段类型检查代码，这些代码会在运行时进行执行，从而判断对象的类型。这种运算符在python中其实很多很多</li>
<li>从这个例子中我们就可以看出C++虽然是一门静态类型的语言，类型是在编译期进行确定，但是也可以支持动态类型语言在运行期做类型的判定和检查</li>
</ul>
</li>
</ul>
<h4 id="OOP面向对象编程"><a href="#OOP面向对象编程" class="headerlink" title="OOP面向对象编程"></a>OOP面向对象编程</h4><ul>
<li>这个框架功能的设计就比上面提到的通过关键字、运算符来提供接口实现的功能要复杂。关键字、运算符这些语法点，可以认为在编译器代码中会使用一些映射好的代码进行替换，这些关键字、运算符其实更多的是为了帮助使用者将常用的功能封装好，这样就减少了重复劳动，和使用定义函数、模板、类进行代码复用的思想是一致的，只不过这些关键字、运算符更关注与系统功能的复用，而使用者更关心与逻辑功能的复用。</li>
<li>相反，OOP就不是简简单单的代码替换这么简单，OOP可以把它理解成C++这门框架中的一个子系统<ul>
<li>既然提到了系统这个词，我们回想操作系统知识，那么这其中一定包括一定程度的层次抽象，就像linux中包含用户态和内核态一样，当用户态调用了一个系统调用以后，我们需要深入的了解这个系统调用在内核态的工作原理是什么。同样，在C++中我们需要知道OOP这个子系统到底是如何完成功能的</li>
</ul>
</li>
<li>对于编译器来说，资源的单位：变量 ，函数<ul>
<li>OOP是对变量和函数这两个资源单位的逻辑上的组合，注意这里强调的是逻辑，这是为了更加贴近人类文明中的概念，减少语言框架和使用者之间的逻辑gap，让使用者能够更好的对现实进行抽象。而，对于编译器本身来说，他不需要这些人类社会的抽象，他眼中认为他自己所在的社会就是一个资源管理的系统，资源的单位时变量和函数，而即使是编译器，他也需要通过变量名和函数名和资源的映射表，来找到这些资源。</li>
</ul>
</li>
<li>虽然对于编译器来说，资源的单位是变量和函数，但是由于C++支持了OOP编程，那么资源单元之间就可以定义新的组合关系，并在组合关系之上设计新的功能，比如说：定义继承的访问控制、定义类的作用域、虚函数实现动态绑定机制，抽象基类等等新的功能。这些功能的本质依然是操作资源的基本单位，但是新添加了一些新的设计，花样也更多。<ul>
<li>这里需要特别强调关键的一点是：对于C++框架的使用者来说，视角是关注现实事物到类之间关系的转化抽象定义，但是对于C++框架本身的编译器来说，它的视角是更多的是从真实存储(内存的各个段，cpu的各种寄存器)的角度来分析。</li>
<li>在编译器视角中，语法层的继承关系变成了资源单位之间的访问关系，这这一点特别关键。从内存角度来说：派生类对象(所占的内存)中含有与其基类对应的部分，这是继承的关键，其中提到的“含有”就是编译器通过代码实现的逻辑功能，将不同的独立的单元产生逻辑上的语义。</li>
</ul>
</li>
</ul>
<h4 id="重载运算"><a href="#重载运算" class="headerlink" title="重载运算"></a>重载运算</h4><ul>
<li>重载运算是OOP系统中其中一个支持的功能，为什么重载运算可以单独成为一章节呢？<ul>
<li>这里面的原因我认为是计算机的核心功能是完成计算，那么语言框架、编译器处理支持代码(变量、函数)的管理以外，也应该直观的可以进行运算接口。</li>
</ul>
</li>
<li>让自定义的类有运算能力：<ul>
<li>在C++已有类型的运算不需要我们程序员关心是因为默认的编译器已经在通识的基础上写好了，并且大家对加法、减法等有统一的认识，因此可以直接写到编译器中，程序员不用管了。那么，OOP中的自定义类，这时我们就需要结合自己对业务功能的理解，定义符合业务特有逻辑的运算操作。</li>
</ul>
</li>
<li>另外，对于重载运算来说更多是编程实战best prictise<ul>
<li>哪些运算符不应该被重载</li>
<li>选择作为成员或者非成员</li>
</ul>
</li>
</ul>
<h4 id="模板泛型"><a href="#模板泛型" class="headerlink" title="模板泛型"></a>模板泛型</h4><ul>
<li>要理解模板的意义，我们需要和define进行对比，我们知道define他只干一件事：在预处理期进行直接、简单的替换操作。怎么评价define呢？往好里说，define功能简单但是也很明确，人们很好理解KISS原则，往不好里说，功能也谈简单了，感觉一点高级功能都没有，连基本的类型、语法检查都没有。</li>
<li>与difine相比，模板看上去好像也是简单的文本替换，但是在编译器中加入了一些高级功能：<ul>
<li>函数模板：可以进行自动的类型推断</li>
<li>支持所谓的模板重载：SFINAE机制</li>
<li>支持可变参数：编译器中加入了参数包的处理代码</li>
<li>模板的特例化：对比与OOP中的类继承关系，特例化是另一种意义上的“关系描述方式”</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/26/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B96%EF%BC%9A%E5%BC%95%E7%94%A8[%E6%91%98%E6%8A%84]/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/26/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B96%EF%BC%9A%E5%BC%95%E7%94%A8%5B%E6%91%98%E6%8A%84%5D/" class="post-title-link" itemprop="url">专题知识点6：引用摘抄</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-26 03:50:00" itemprop="dateCreated datePublished" datetime="2020-04-26T03:50:00+08:00">2020-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 16:20:16" itemprop="dateModified" datetime="2020-05-04T16:20:16+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AF%AD%E8%A8%80-c/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_语言/c++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/26/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B96%EF%BC%9A%E5%BC%95%E7%94%A8%5B%E6%91%98%E6%8A%84%5D/" class="post-meta-item leancloud_visitors" data-flag-title="专题知识点6：引用摘抄" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月26日 下午3:50</p>
<p><a href="https://blog.csdn.net/weixin_40539125/article/details/81410008" target="_blank" rel="noopener">C/C++ 引用作为函数的返回值_C/C++_Jeff_的博客-CSDN博客</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码来源：RUNOOB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">float</span> temp;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">fn1</span><span class="params">(<span class="keyword">float</span> r)</span></span>&#123;</span><br><span class="line">    temp=r*r*<span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">float</span> &amp;<span class="title">fn2</span><span class="params">(<span class="keyword">float</span> r)</span></span>&#123; <span class="comment">//&amp;说明返回的是temp的引用，换句话说就是返回temp本身</span></span><br><span class="line">    temp=r*r*<span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a=fn1(<span class="number">5.0</span>); <span class="comment">//case 1：返回值</span></span><br><span class="line">    <span class="comment">//float &amp;b=fn1(5.0); //case 2:用函数的返回值作为引用的初始化值 [Error] invalid initialization of non-const reference of type 'float&amp;' from an rvalue of type 'float'</span></span><br><span class="line">                           <span class="comment">//（有些编译器可以成功编译该语句，但会给出一个warning） </span></span><br><span class="line">    <span class="keyword">float</span> c=fn2(<span class="number">5.0</span>);<span class="comment">//case 3：返回引用</span></span><br><span class="line">    <span class="keyword">float</span> &amp;d=fn2(<span class="number">5.0</span>);<span class="comment">//case 4：用函数返回的引用作为新引用的初始化值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//78.5</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;b&lt;&lt;endl;//78.5</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//78.5</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//78.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>case 1：用返回值方式调用函数（如下图，图片来源：伯乐在线）：<br><img src="/2020/04/26/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B96%EF%BC%9A%E5%BC%95%E7%94%A8[%E6%91%98%E6%8A%84]/900715-20170824213332277-1403805406.png" alt><ol start="2">
<li>返回全局变量temp的值时，C++会在内存中创建临时变量并将temp的值拷贝给该临时变量。当返回到主函数main后，赋值语句a=fn1(5.0)会把临时变量的值再拷贝给变量a</li>
</ol>
</li>
<li>case 2：用函数的返回值初始化引用的方式调用函数（如下图，图片来源：伯乐在线）<br><img src="/2020/04/26/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B96%EF%BC%9A%E5%BC%95%E7%94%A8[%E6%91%98%E6%8A%84]/900715-20170824213909761-1693110470.png" alt><ol start="2">
<li><strong>这种情况下，函数fn1()是以值方式返回到，返回时，首先拷贝temp的值给临时变量。返回到主函数后，用临时变量来初始化引用变量b，使得b成为该临时变量到的别名。由于临时变量的作用域短暂（在C++标准中，临时变量或对象的生命周期在一个完整的语句表达式结束后便宣告结束，也就是在语句float &amp;b=fn1(5.0);之后） ，所以b面临无效的危险，很有可能以后的值是个无法确定的值。</strong></li>
<li>如果真的希望用函数的返回值来初始化一个引用，应当先创建一个变量，将函数的返回值赋给这个变量，然后再用该变量来初始化引用：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=fn1(<span class="number">5.0</span>);</span><br><span class="line"><span class="keyword">int</span> &amp;b=x;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>case 3:用返回引用的方式调用函数（如下图，图片来源：伯乐在线）<br><img src="/2020/04/26/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B96%EF%BC%9A%E5%BC%95%E7%94%A8[%E6%91%98%E6%8A%84]/900715-20170824225424339-901573647.png" alt><ol start="2">
<li>这种情况下，函数fn2()的返回值不产生副本，而是直接将变量temp返回给主函数，即主函数的赋值语句中的左值是直接从变量temp中拷贝而来（也就是说c只是变量temp的一个拷贝而非别名） ，这样就避免了临时变量的产生。尤其当变量temp是一个用户自定义的类的对象时，这样还避免了调用类中的拷贝构造函数在内存中创建临时对象的过程，提高了程序的时间和空间的使用效率。</li>
</ol>
</li>
<li>case 4:用函数返回的引用作为新引用的初始化值的方式来调用函数（如下图，图片来源：伯乐在线）<br><img src="/2020/04/26/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B96%EF%BC%9A%E5%BC%95%E7%94%A8[%E6%91%98%E6%8A%84]/900715-20170824231047714-55281615.png" alt><ol start="2">
<li>这种情况下，函数fn2()的返回值不产生副本，而是直接将变量temp返回给主函数。在主函数中，一个引用声明d用该返回值初始化，也就是说此时d成为变量temp的别名。由于temp是全局变量，所以在d的有效期内temp始终保持有效，故这种做法是安全的。</li>
</ol>
</li>
</ol>
<ol>
<li><strong>不能返回局部变量的引用。</strong>如上面的例子，如果temp是局部变量，那么它会在函数返回后被销毁，此时对temp的引用就会成为“无所指”的引用，程序会进入未知状态。</li>
<li><strong>不能返回函数内部通过new分配的内存的引用</strong>。虽然不存在局部变量的被动销毁问题，但如果被返回的函数的引用只是作为一个临时变量出现，而没有将其赋值给一个实际的变量，那么就可能造成这个引用所指向的空间（有new分配）无法释放的情况（由于没有具体的变量名，故无法用delete手动释放该内存），从而造成内存泄漏。因此应当避免这种情况的发生</li>
<li><strong>当返回类成员的引用时，最好是const引用</strong>。这样可以避免在无意的情况下破坏该类的成员。</li>
<li>可以用函数返回的引用作为赋值表达式中的左值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> value[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> error=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;=<span class="number">0</span>&amp;&amp;n&lt;=<span class="number">9</span>)</span><br><span class="line">        <span class="keyword">return</span> value[n];<span class="comment">//返回的引用所绑定的变量一定是全局变量，不能是函数中定义的局部变量 </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func(<span class="number">0</span>)=<span class="number">10</span>;</span><br><span class="line">    func(<span class="number">4</span>)=<span class="number">12</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;value[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;value[<span class="number">4</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/20/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E7%AE%97%E6%B3%95/leetcode/%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%85%B3%E9%94%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E7%AE%97%E6%B3%95/leetcode/%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%85%B3%E9%94%AE/" class="post-title-link" itemprop="url">二分查找的关键</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-20 10:24:00" itemprop="dateCreated datePublished" datetime="2020-04-20T10:24:00+08:00">2020-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 16:19:50" itemprop="dateModified" datetime="2020-05-04T16:19:50+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E7%AE%97%E6%B3%95-leetcode-%E9%A2%98%E7%9B%AE/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_算法/leetcode/题目</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/20/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E7%AE%97%E6%B3%95/leetcode/%E9%A2%98%E7%9B%AE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%85%B3%E9%94%AE/" class="post-meta-item leancloud_visitors" data-flag-title="二分查找的关键" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>421</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月20日 下午10:24</p>
<h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ol>
<li>定义：我们要找的值在[left,right]闭区间中。在循环的过程中我们要维护这个定义，知道left = right，就可以找到我们target<ol>
<li>注意：这里的[left,right]区间要包括所有的情况，有些题目初始化right = nums.size() 而不是nums.size() - 1就是这个原因</li>
</ol>
</li>
<li>在循环的过程中需要维护两个条件：<ol>
<li>在[left,right]闭区间的包含target的定义</li>
<li>并且，每次循环保证[left,right]区间在缩小，否则会造成死循环<ol>
<li>这里就需要考虑上取整 or 下取整<ol>
<li>上取整 mid = right + (left - right) / 2</li>
<li>下取整 mid = right + (left - right - 1) / 2<ol>
<li>mid = (left + right) / 2</li>
</ol>
</li>
</ol>
</li>
<li>经验结论：<ol>
<li>left = mid or right = mid - 1  =&gt; 上取整</li>
<li>left = mid + 1 or right = mid   =&gt; 下取整</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p> <a href="https://leetcode-cn.com/problems/ju-qing-hong-fa-shi-jian/" target="_blank" rel="noopener">LCP 08. 剧情触发时间</a><br> <a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/16/web%E5%BC%80%E5%8F%91/czh_blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6%E5%A4%A7%E5%8E%9F%E5%88%99%E4%B9%8B%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/16/web%E5%BC%80%E5%8F%91/czh_blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6%E5%A4%A7%E5%8E%9F%E5%88%99%E4%B9%8B%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/" class="post-title-link" itemprop="url">设计模式6大原则之最重要的开闭原则</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-16 09:43:00" itemprop="dateCreated datePublished" datetime="2020-04-16T09:43:00+08:00">2020-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 16:19:50" itemprop="dateModified" datetime="2020-05-04T16:19:50+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%BC%80%E5%8F%91-czh-blog-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">web开发/czh_blog/设计模式</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/16/web%E5%BC%80%E5%8F%91/czh_blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6%E5%A4%A7%E5%8E%9F%E5%88%99%E4%B9%8B%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/" class="post-meta-item leancloud_visitors" data-flag-title="设计模式6大原则之最重要的开闭原则" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>599</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月16日 上午9:43</p>
<p><a href="https://tianweili.github.io/2015/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">设计模式六大原则 - 开闭原则 | 李天炜</a></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>开闭原则是对扩展开放，对修改关闭。</li>
<li>开闭原则的主旨是为了拥抱变化。</li>
<li><strong>在六大原则中，开闭原则只是一个思想，没有具体实际操作方法。其他五大原则都是为了实现这个开闭思想的一些方法和工具</strong>。</li>
<li>想要遵守开闭原则，就需要一个设计合理的系统。可以说在做系统设计的时候就要考虑到未来的扩展和改变。</li>
</ol>
<p><a href="https://baike.baidu.com/item/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/6189149?fromtitle=%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99&fromid=7706090" target="_blank" rel="noopener">依赖倒置原则_百度百科</a></p>
<ol>
<li><strong>一个应用中的重要策略决定及业务模型正是在这些高层的模块中</strong>。也正是这些模型包含着应用的特性。但是，当这些模块依赖于低层模块时，低层模块的修改将会直接影响到它们，迫使它们也去改变。这种境况是荒谬的。应该是处于高层的模块去迫使那些低层的模块发生改变。应该是处于高层的模块优先于低层的模块。<strong>无论如何高层的模块也不应依赖于低层的模块</strong>。</li>
<li>而且，我们想能够复用的是高层的模块。通过子程序库的形式，我们已经可以很好地复用低层的模块了。当高层的模块依赖于低层的模块时，这些高层模块就很难在不同的环境中复用。但是，当那些<strong>高层模块独立于低层模块</strong>时，它们就能很简单地被复用了。</li>
<li><strong>这正是位于框架设计的最核心之处的原则</strong></li>
<li>总结：<ol>
<li>场景：一个应用中的重要策略决定及业务模型正是在这些高层的模块中</li>
<li>处理方法：无论如何高层的模块也不应依赖于低层的模块，相反高层模块应该独立于低层模块</li>
<li>效果：框架使用这种设计方式可以在将来很容易的添加子模块，并且对框架的使用者来说，使用方式一样的。</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/15/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_linux%E5%91%BD%E4%BB%A4/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/iptable%20vs%20route/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_linux%E5%91%BD%E4%BB%A4/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/iptable%20vs%20route/" class="post-title-link" itemprop="url">iptable vs route</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:19:00" itemprop="dateCreated datePublished" datetime="2020-04-15T12:19:00+08:00">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 16:20:16" itemprop="dateModified" datetime="2020-05-04T16:20:16+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-linux%E5%91%BD%E4%BB%A4-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_linux命令/常用指令</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/15/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_linux%E5%91%BD%E4%BB%A4/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/iptable%20vs%20route/" class="post-meta-item leancloud_visitors" data-flag-title="iptable vs route" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月15日 下午12:19</p>
<p>注：关于linux中iptable和route这些指令的学习一定要以了解linux系统内核处理过程的设计为前提，否则学习这些命令就是花架子。</p>
<ol>
<li>linux中关于网络的命令有很多：iptable route rule iostat 等等，我觉得他们很乱，我作为一个使用者我该如何理解，学习并可以做到按照场景需要来控制自己的网络数据包的走向呢？这其中最大的问题就是iptable和route之间的区别是什么？iptable是否和route是取代的关系，还是在一套流程中是合作的关系？<ol>
<li><a href="https://superuser.com/questions/419659/iptables-vs-route" target="_blank" rel="noopener">linux - iptables vs route - Super User</a></li>
<li>route is a command that displays, adds and deletes entries from the kernel’s TCP/IP routing table (aka “Forwarding Information Base”).</li>
<li>iptables is a command that displays, adds, and deletes entries from Netfilter, the Linux kernel’s packet filtering and manipulating subsystem. It handles NAT.</li>
<li>这篇文章对route和iptable下了一个准确的定义，可以看出route操作的对象是table，而iptable对应的是linux中的一个内核模块Netfilter</li>
</ol>
</li>
<li>这里首先我们需要了解linux中Netfilter这个内核模块他的逻辑是什么？<br><img src="/2020/04/15/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_linux%E5%91%BD%E4%BB%A4/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/iptable%20vs%20route/A66DE4C7-65B2-48B3-B7BD-F8F6841E3C59.png" alt><ol start="2">
<li><a href="http://www.zsythink.net/archives/1199" target="_blank" rel="noopener">iptables详解：图文并茂理解iptables</a></li>
</ol>
</li>
<li>这里得再次提醒，一定要站在linux系统内核的角度去分析这个问题，iptable这命令只不过是一个用户接口罢了。从这个图中，我们就可以看到需要做到这几个功能：<ol>
<li>Netfilter模块可作为一个网关路由度器，<strong>转发其他主机发过来的数据包</strong>。</li>
<li><strong>可以接收网络中放给自己的数据包</strong>，然后通过内核，也即是Netfilter来传递给上层的协议栈，进而传递给对应的进程端口</li>
<li>当我们自己<strong>发送数据给别人</strong>时，也需要通过内核态的Netfilter，然后才可以发送到网络上</li>
</ol>
</li>
<li>我们做到上面的基础功能是不够的，在这个数据流动的过程中，我们希望可以对信息进行处理：<ol>
<li>对数据包处理的能力：<ol>
<li>过滤功能</li>
<li>网络地址转换功能</li>
<li>拆解报文，做出修改，并重新封装的功能</li>
<li>连接追踪的功能</li>
</ol>
</li>
<li>定位数据包发送位置的能力：<ol>
<li>判断数据包下一站是去哪里</li>
</ol>
</li>
</ol>
</li>
<li>上面的对数据包处理的能力1-4功能其实对应了iptable中的四种表 filter表，nat表，mangle表，raw表，定位数据包发送位置的能力就是由route table来完成。也就是说其实iptable是更加偏向于提供对数据包处理的能力，而route则是提供所谓的定位发送的能力，也就是路由本身的意思。这里我们就区分开了iptable和route，他们是在一个大的数据处理流程中有不同的任务，他们之间是合作的关系，共同保证数据的正确传输，也就是Netfilter内核的正确运作。</li>
<li>这里有个Netfilter简要的处理流程：转发其他主机发过来的数据包<ol>
<li>Netfilter 处理网络包的先后顺序：接收网络包，先 DNAT，然后查路由策略，查路由策略指定的路由表做路由，然后 SNAT，再发出网络包。<ol>
<li><a href="https://segmentfault.com/q/1010000002389520" target="_blank" rel="noopener">iptables - SNAT和DNAT的区别 - SegmentFault 思否</a></li>
<li>SNAT: Source Network Address Translation，是修改网络包源ip地址的。<ol>
<li>修改源ip地址的目的一般都是为了让这个包能再回到自己这里，所以在iptables中，SNAT是在出口，也即POSTROUTING链发挥作用。</li>
</ol>
</li>
<li>DNAT: Destination Network Address Translation,是修改网络包目的ip地址的。<ol>
<li>修改目的ip地址的原因一般就是为了改变包发送的目的地，让包走出去，而不是留下来，所以在iptables中，DNAT是在入口，也即PREROUTING链中发挥作用，以便让包进入FORWARD表</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>最后，一个实际的例子来应用route,iptable完成：公司内网要求192.168.0.100 以内的使用 10.0.0.1 网关上网 （电信），其他IP使用 20.0.0.1 （网通）上网。<ol>
<li>参考：<ol>
<li><a href="http://blog.sina.com.cn/s/blog_659b48590100n2q6.html" target="_blank" rel="noopener">使用 ip route ， ip rule ， iptables 配置策略路由_shuti_新浪博客</a></li>
<li><a href="https://www.cnblogs.com/sammyliu/p/4713562.html" target="_blank" rel="noopener">理解 OpenStack 高可用（HA）（3）：Neutron 分布式虚拟路由（Neutron Distributed Virtual Routing） - SammyLiu - 博客园</a></li>
</ol>
</li>
<li>第一步：route<ol>
<li>首先要在网关服务器上添加一个默认路由，当然这个指向是绝大多数的IP的出口网关：ip route add default gw 20.0.0.1</li>
<li>之后通过 ip route 添加一个路由表：ip route add table 3 via 10.0.0.1 dev ethX (ethx 是 10.0.0.1 所在的网卡, 3 是路由表的编号)</li>
</ol>
</li>
<li>第二步：rule<ol>
<li>之后添加 ip rule 规则：ip rule add fwmark 3 table 3 （fwmark 3 是标记，table 3 是路由表3 上边。 意思就是凡事标记了 3 的数据使用 table3 路由表）</li>
</ol>
</li>
<li>第三部：iptables<ol>
<li>之后使用 iptables 给相应的数据打上标记：iptables -A PREROUTING -t mangle -i eth0 -s 192.168.0.1 - 192.168.0.100 -j MARK —set-mark 3</li>
</ol>
</li>
<li>总结：<ol>
<li><strong>因为 mangle 的处理是优先于 nat 和 fiter 表的，所以在数据包到达之后先打上标记，之后再通过 ip rule 规则，对应的数据包使用相应的路由表进行路由，最后读取路由表信息，将数据包送出网关。</strong></li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/15/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_linux%E5%91%BD%E4%BB%A4/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E5%8D%95%E5%85%83%E7%9A%84%E8%A7%92%E5%BA%A6%E6%95%B4%E7%90%86linux%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_linux%E5%91%BD%E4%BB%A4/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E5%8D%95%E5%85%83%E7%9A%84%E8%A7%92%E5%BA%A6%E6%95%B4%E7%90%86linux%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">从对象单元的角度整理linux命令</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:04:00" itemprop="dateCreated datePublished" datetime="2020-04-15T12:04:00+08:00">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 16:19:51" itemprop="dateModified" datetime="2020-05-04T16:19:51+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-linux%E5%91%BD%E4%BB%A4-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_linux命令/常用指令</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/15/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_linux%E5%91%BD%E4%BB%A4/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E5%8D%95%E5%85%83%E7%9A%84%E8%A7%92%E5%BA%A6%E6%95%B4%E7%90%86linux%E5%91%BD%E4%BB%A4/" class="post-meta-item leancloud_visitors" data-flag-title="从对象单元的角度整理linux命令" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>800</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月15日 下午12:04</p>
<h5 id="序："><a href="#序：" class="headerlink" title="序："></a>序：</h5><ul>
<li>为什么会有这篇文章？<ul>
<li>因为我即使在学习、使用linux命令的过程中详细的做了笔记，但是如果半个月不用真的就忘了大半，每次返回来在复习笔记的过程中还是觉得学习路线不清晰，都是散乱的点，所以我就尝试能不能再找一个角度进行总结，所以就有了这篇文章。</li>
</ul>
</li>
<li>那为什么要以对象单元为角度呢？<ul>
<li>其实这个角度我自己起的名字，我的初衷是希望可以结合linux系统的知识反过来推理linux应该提供哪些命令帮助程序员了解linux的运行情况。那么首当其冲的就是以进程为单位，因为linux系统中所有的任务都是一个或者多个进行在处理。对于一个进程进行socket文件读写的任务，从理论上来说我们既可以从进程的角度进行描述，也可以从设备读写的角度进行描述，也可以从网络的角度进行描述，正式因为这种角度的多样性，linux需要为不同需要的程序员来提供各自合适的工具。</li>
</ul>
</li>
</ul>
<h4 id="linux为开发者提供的工具包"><a href="#linux为开发者提供的工具包" class="headerlink" title="linux为开发者提供的工具包"></a>linux为开发者提供的工具包</h4><p><a href="bear://x-callback-url/open-note?id=F73C7047-94EC-4A5B-B716-09802AEF6D42-1064-00001B007E116822">curl</a><br><a href="bear://x-callback-url/open-note?id=DC2233D1-0C53-4BF4-865B-AB001D336C5C-803-0000422566ADD03B">traceroute</a><br>客户端操作进程的方式：<br><a href="bear://x-callback-url/open-note?id=04FCA021-94F1-4407-8E7F-1C03E1BA87C3-1064-00002D298C8E5FE7">Linux 守护进程的启动方法:bg、disown、nohup、tmux、sytemd</a></p>
<ul>
<li><input disabled type="checkbox"> <a href="bear://x-callback-url/open-note?id=BCACC082-63EC-4FF4-AFAD-2676AACAECDF-1064-00002DD065332898">Systemd</a><br><a href="bear://x-callback-url/open-note?id=0A9561F7-3E94-4F01-A9D6-8434F81CCC53-827-000016B0F15519E1">bg+fg</a><br><a href="bear://x-callback-url/open-note?id=F76181EF-0184-431A-B7B3-E5456537AE60-15210-0001827723A95D37">Linux中的定时自动执行功能（at,crontab）</a></li>
</ul>
<h4 id="以硬件设备为单位，查看硬件的执行情况"><a href="#以硬件设备为单位，查看硬件的执行情况" class="headerlink" title="以硬件设备为单位，查看硬件的执行情况"></a>以硬件设备为单位，查看硬件的执行情况</h4><p><a href="bear://x-callback-url/open-note?id=F592CA50-7805-462E-9CF8-2F43F6C2E554-740-00002E84915D9881">ifconfig</a>以网卡为单位<br><a href="bear://x-callback-url/open-note?id=35679952-B3E3-40C0-94E0-45BACA481C2A-1064-00005F220CEC4B47">iftop</a>网卡为单位<br><a href="bear://x-callback-url/open-note?id=FE470B70-E6FF-48D4-BEA0-2F0EBC6221A2-827-00005F331671A6A7">根据iostate判断计算机瓶颈</a>读写设备为单位<br><a href="bear://x-callback-url/open-note?id=C72D8B44-F3C4-437A-A7C8-523342A5476E-1064-000024CD17DF3041">查看系统版本和管理员</a><br><a href="bear://x-callback-url/open-note?id=D1DFB994-BDA0-47A5-993F-052B6A7DEBA8-740-00002C7BCBBD8879">查询cpu信息</a>cpu</p>
<h4 id="以进程为单位，查看linux各个子系统的执行情况："><a href="#以进程为单位，查看linux各个子系统的执行情况：" class="headerlink" title="以进程为单位，查看linux各个子系统的执行情况："></a>以进程为单位，查看linux各个子系统的执行情况：</h4><p><a href="bear://x-callback-url/open-note?id=B9C075C8-BC3A-4A29-976D-4D783B4D9C41-1064-00005F0B1034AA04">htop</a>进程为单位<br><a href="bear://x-callback-url/open-note?id=6F189998-F016-4B08-93CC-9E3880EFDAEA-740-00002B4DF3EA80DE">top</a>进程为单位</p>
<ul>
<li><input disabled type="checkbox"> <a href="bear://x-callback-url/open-note?id=B24690B1-4F33-4790-9A60-AB02830933F6-1064-0000431B6FB57565">lsof(list open files)</a>进程为单位，查看文件读写系统</li>
<li><input disabled type="checkbox"> <a href="bear://x-callback-url/open-note?id=ACFDC824-6D99-46B0-A82B-3844902A3EA4-1064-00005F4826F57092">iotop:每个进程是如何使用 IO</a>进程为单位，查看io子系统</li>
<li><input disabled type="checkbox"> <a href="bear://x-callback-url/open-note?id=177C76D8-6AE3-440C-85D0-0E5D0ABF8E64-827-00000802A7502611">ps</a>进程为单位<br><a href="bear://x-callback-url/open-note?id=2343CD79-DB5D-4B83-9922-A03711CFFDA8-827-00006042D9E747CC">僵尸进程：原理+清理</a><br><a href="bear://x-callback-url/open-note?id=E806CE17-7A6D-4509-A9AF-E2074905933D-1064-00002A8BA1197BC7">kill</a>进程为单位</li>
</ul>
<h4 id="以其他为单位，查看子系统的执行情况"><a href="#以其他为单位，查看子系统的执行情况" class="headerlink" title="以其他为单位，查看子系统的执行情况"></a>以其他为单位，查看子系统的执行情况</h4><p><a href="bear://x-callback-url/open-note?id=C741790D-0479-4BD4-A092-E44897C7FACC-827-000180D29BA8A951">netstat</a>以连接为单位<br><a href="bear://x-callback-url/open-note?id=4EA264FC-8D50-4BCB-AF81-8C494A44E171-1144-0000555FD9C08AB9">iptable</a>以规则为单位<br><a href="bear://x-callback-url/open-note?id=99AB2F0D-CA76-4273-9485-B8642758750A-499-00000A1C27961712">看懂本机上的路由表，并操作</a>以路由规则为单位<br>硬盘：<br><a href="bear://x-callback-url/open-note?id=726B0BF1-9046-441D-986E-43072DE1A68E-740-000021DF2FCC08ED">df</a>目录结构<br><a href="bear://x-callback-url/open-note?id=1203A121-366C-4E68-9ECD-1B3FE6AE66FC-15210-0003F035CD63F862">硬盘</a>目录结构</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/13/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F/linux%E4%B8%AD%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99(%E5%8C%85%E6%8B%AC%E5%90%84%E7%A7%8D%E6%8A%BD%E8%B1%A1%E6%96%87%E4%BB%B6%EF%BC%9A%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E3%80%81%E5%9D%97%E8%AE%BE%E5%A4%87%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97%E7%AD%89%E7%AD%89)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/13/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F/linux%E4%B8%AD%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99(%E5%8C%85%E6%8B%AC%E5%90%84%E7%A7%8D%E6%8A%BD%E8%B1%A1%E6%96%87%E4%BB%B6%EF%BC%9A%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E3%80%81%E5%9D%97%E8%AE%BE%E5%A4%87%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97%E7%AD%89%E7%AD%89)/" class="post-title-link" itemprop="url">linux中，是如何完成文件的读写(包括各种抽象文件：字符设备、块设备、套接字等等)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-13 12:19:00" itemprop="dateCreated datePublished" datetime="2020-04-13T12:19:00+08:00">2020-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 16:19:50" itemprop="dateModified" datetime="2020-05-04T16:19:50+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-linux-%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_计算机系统/linux/系统</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/13/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F/linux%E4%B8%AD%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99(%E5%8C%85%E6%8B%AC%E5%90%84%E7%A7%8D%E6%8A%BD%E8%B1%A1%E6%96%87%E4%BB%B6%EF%BC%9A%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E3%80%81%E5%9D%97%E8%AE%BE%E5%A4%87%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97%E7%AD%89%E7%AD%89)/" class="post-meta-item leancloud_visitors" data-flag-title="linux中，是如何完成文件的读写(包括各种抽象文件：字符设备、块设备、套接字等等)" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月13日 下午12:19</p>
<h4 id="在讲解这个过程的同时，也可以一并理解一下几个问题："><a href="#在讲解这个过程的同时，也可以一并理解一下几个问题：" class="headerlink" title="在讲解这个过程的同时，也可以一并理解一下几个问题："></a>在讲解这个过程的同时，也可以一并理解一下几个问题：</h4><ol>
<li>为什么需要文件描述符？</li>
<li>文件描述符fd与inode有关系吗，有怎样的关系？</li>
<li>linux内核是如何封装各种抽象文件的读写接口的，能做到所谓的“一切皆文件”？</li>
<li>不同的抽象文件，他们之间的读写操作在内核中有什么区别？也就是linux内核它封装了什么？(等同于上一个问题)</li>
<li>你怎样验证你说的是正确的？有没有可以证明的方式？</li>
</ol>
<h4 id="讲解的角度、方法："><a href="#讲解的角度、方法：" class="headerlink" title="讲解的角度、方法："></a>讲解的角度、方法：</h4><p>我们这里采用自顶向下的角度来讲解linux中是如何完成文件的读写。所谓自顶向下其实就是按着程序员代码不断展开，到达系统调用，在系统调用中就需要看linux内核的实现了，这里我们绕过内核的具体代码实现，直接找到通过系统内核系统调用之后处理的结果什么，通过这样间接的方式来验证我们的思路正确性，具体来说就是看能够在linux系统中找到系统内核调用过程中使用的文件以及对应的文件描述符，这些文件或者文件描述符其实就是系统内核调用在运行过程中留下的脚印👣，我们可以按图索骥看看内核到底干了点什么。</p>
<h4 id="linux中，是如何完成文件的读写"><a href="#linux中，是如何完成文件的读写" class="headerlink" title="linux中，是如何完成文件的读写"></a>linux中，是如何完成文件的读写</h4><ol>
<li>根据操作系统的我们已有的知识储备，我们知道操作系统是很讲究设计的，也就是各个部门之间的分工合作，并且有上下级之间的封装调用，可以做到下级对上级来说，下级的工作是透明的。具体的在linux中的体现就是：区分用户态和内核态。从linux设计的角度来说，希望让竟可能的降低系统的使用者也就是程序员的使用难度，给他们封装出一些丰富的接口，够他们能够完成功能就可以了，程序员你就别管我操作系统是如何实现你调用的接口了。</li>
<li>正是由于来于这样一种考虑，linux设计了文件描述符：当一个文件被一个进程打开，就会创建一个文件描述符，这里的文件描述符可以理解成字节流的接口，接口这个词就能很清晰的体现了文件描述符在linux中的本质特性。那么，<strong>从用户态这个层面来看，其实并不是一切皆文件，而是一切皆文件描述符。</strong></li>
<li>那么对于有追求的程序员来说，他不满足现状，他希望可以弄明白linux内核是如何实现文件的读写的。这是我们就需要思考一个问题，难道整个文件系统有两层吗，一层是用户态，一层是内核态，内核态就能直接操作硬盘上的文件吗？其实，我们单独拿出内核态来看，它为了实现文件的读写，其实也有所谓的层次结构，这中间也进行了精妙的设计。这里面最关键的一个设计就是inode，<strong>inode将我们操作的文件进行抽象，成为我们操作文件读写时最小的操作单元，也就是说，在内核态中其实他操作是的inode</strong>，可千万别以为我们直接操作的是赤裸裸的文件，inode就可以很要的封装了各个文件之间大小类型之间的区别，可以说inode是实现文件读写最最核心的关键，其他的类似于管理不同的抽象文件读写，其实都是在inode基础上的业务逻辑，业务逻辑可以频繁的更换，但是基础的inode这层定义逻辑是一定不能变的。这里我们就知道inode真的是特别特别重要，理解inode对理解操作系统也是一个关键。</li>
<li>认识到inode的重要性，我们接下来说说linux是如何考虑在inode的基础上完成所谓的业务逻辑，来实现不同的抽象文件的读写操作。<ol>
<li>inode的重要性就像是数据结构与算法中数据结构对算法的作用，inode就是这里的数据结构，在做算法题的时候，我们知道如果我们设计出了这道题需要的数据结构，那么写算法在熟练语法的基础上就是分分钟的事情</li>
<li>在inode这套数据结构之上，<strong>我们可以这样认为：从内核态的角度来看，不是所谓的一切皆文件描述符，而是一切皆inode</strong>，因为内核态中文件描述符是不存在，在从用户态到内核态时文件描述符已近展开了成为了inode。<strong>文件描述符fd和inode其实都是一个非负整数，这点他们是相同的。</strong></li>
<li>如何证明inode是可以对抽象文件，eg：tcp socket进行抽象表示呢？在<a href="https://www.cnblogs.com/MrVolleyball/p/9987208.html" target="_blank" rel="noopener">linux一切皆文件之tcp socket描述符（三） - wilson排球 - 博客园</a>就可以找到证据。</li>
<li>要实现不同文件类型的读写，我们考虑到linux是一个各种子系统的集合 <a href="bear://x-callback-url/open-note?id=B8B464F7-1E8D-435A-AB86-6D0F52CD7D1B-1248-000098B1433E95C7">将操作系统分解，看看这个庞大的系统中包含哪些子系统</a>，这其中就包括网络子系统，当我们需要完成基于socket、tcp socket的文件读写的时候，就需要依赖于网络子系统，把这部分工作承包给它；还有输入输出系统，当我们需要对块设备进行读写时，我们依然需要依赖于它；还有对字符流设备的读写，这里的例子有ssh连接的连接过程，其实就是一个文件读写的过程，它的本质不变，依然可以拆解为单个的文件读写过程，只不过ssh连接进行操作的过程并不是依靠单独唯一的进程、文件，它需要涉及到进行的fork，以及各个进程都会有自己对应的操作文件组。在学习的过程中，一定要明白这部分是属于业务逻辑，比如在ssh中，可以称作为client和server进行交互的逻辑。在学习的时候，容易沉溺于业务逻辑中，而忘记了文件读写的本质操作。业务逻辑会根据业务的不同随时变化，但是文件读写这样基本的操作是永远不会变的，各种复杂的业务也都是有多个文件读写操作进行组合完成的。</li>
<li>那么现在回答：单独的文件读写的本质是什么，是如何完成的？<ol>
<li>一个进程A启动,那么并不是进打开一个文件，而是会打开各种各样的文件，这这些文件中有很多都是这个进行它所依赖的系统库文件，在这些依赖的系统库文件之外，才有我们真正进行读写的文件，这些文件在打开之后，会有对应的文件描述符</li>
<li>我们可以在<code>/proc/A/fd</code>找到这些文件描述符的链接，这个链接就会指向我们真正操作的文件位置。其实这个位置是给内核态使用的，他拿上这个位置上的文件进行操作。在从用户态到内核态的过程中，我们就依赖于这个链接完成用户态到内核态的转换。这个位置可以是linux下文件的真实路径，这部分工作由linux文件子系统完成，另外这个位置也可以直接指向inode的编号，在socket链接中我们就以看到这个inode编号。</li>
<li><strong>简单来说，读写文件的核心是用户态到内核态的一次转换过程，至于到达内核态之后，会根据你操作的文件类型，内核会选择不同的助手子系统来完成真正的inode读写操作。</strong></li>
<li>对node的读写，就是读写文件的最后一步。至于要问如何完成对node的读写，我下次在写。</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/12/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/%E7%90%86%E8%A7%A3control%E3%80%81logic%E3%80%81data%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/12/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/%E7%90%86%E8%A7%A3control%E3%80%81logic%E3%80%81data%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">理解control、logic、data、泛型、函数式编程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-12 02:42:00 / 修改时间：19:31:54" itemprop="dateCreated datePublished" datetime="2020-04-12T02:42:00+08:00">2020-04-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AF%AD%E8%A8%80-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_语言/编程范式</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/12/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/%E7%90%86%E8%A7%A3control%E3%80%81logic%E3%80%81data%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="理解control、logic、data、泛型、函数式编程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月12日 下午2:42</p>
<h4 id="还是从需求的角度进行分析-理解control、logic、data、泛型、函数式编程"><a href="#还是从需求的角度进行分析-理解control、logic、data、泛型、函数式编程" class="headerlink" title="还是从需求的角度进行分析,理解control、logic、data、泛型、函数式编程"></a>还是从需求的角度进行分析,理解control、logic、data、泛型、函数式编程</h4><ol>
<li>老一辈的有经验的程序员认识到：我们需要将代码中的control，logic，data进行分离，这样不管我们看别人的代码，还是自己写代码都会更加的有逻辑，更容易看懂并写出，而不仅仅是完成功能就可以了</li>
<li>那我们如何实现所谓的control，logic，data的分离呢？<ol>
<li>首先我们需要将data进行分离，因为data与control和logic的区别更大</li>
<li>这个操作我们把它叫做泛型，当然在泛型的过程中并不是使用一个T就可以了，我们需要将泛型和迭代一起完成，详见 <a href="bear://x-callback-url/open-note?id=27C737A4-47D9-4205-82FA-767D5B68C0CB-711-00003AC547043BB6">模板编程：分步骤STL如何实现泛型</a></li>
</ol>
</li>
<li>实现泛型之后，我们如何将control和logic进行分离呢？<ol>
<li>首先，我们需要明白什么是contorl什么是logic，control我把它理解成是调度好像更好理解一些；而logic其实就是我们业务功能。当我们需要更换业务功能时，是可以使用同一个套control进行调度的。可以把control和logic之间的关系可以称作为“范llogic”,这个名字去自与泛型。一个control的例子：map_reduce_filter 就是control，他们只负责遍历。</li>
<li>这时候，我们将control和logic进行分离之后进行的编程方法叫做函数式编程。当然，上面说的从control和logic进行分离角度来认识函数式编程，其实函数式编程的起源是来自于数学上的函数，函数有有两个特性：stateless,immutable，而函数式编程也必须满足这两个条件，最终能够做到并行执行和copy-paste。两个角度不同而已。</li>
</ol>
</li>
<li>此时，我们有了实现control，logic，data的分离的方法，也引出了泛型编程和函数编程，那么泛型编程和函数编程具体在语言中该如何进行实现呢？<ol>
<li>函数式编程的实现：<ol>
<li>函数式编程其实还是程序员逻辑角度的不同，并不需要语言、编译器对其进行支持(当然有些语言在设计语法的时候就考虑到了函数式编程，甚至只能进行函数式编程，那么就可以在我们使用函数式编程的时候提供语法层面的便利)</li>
<li>函数式编程其实就是逻辑的抽象，比过程式这样扁平的设计更加立体，有更多的上下级函数之间的调用封装。</li>
<li>明白了函数式的思想，那么我们看看代码中具体如何实现函数式呢：<ol>
<li>利用函数编程的三驾马车：filter_map_reduce，把for循环进行函数的封装，隐藏起来。</li>
<li>递归代替for循环。</li>
<li>其实，如果将所有的函数式编程的调用过程展开，最终其实还是会变回for循环，只不过由于上下级的调用封装，我们将for循环进行了隐藏，你看不见，并不代表没有，这部分内容其实可以通过map_reduce的实现来看出，map_reduce其实就是通过for循环来实现的。</li>
</ol>
</li>
<li>为什么拿掉for是实现函数式编程的关键？拿掉之后对有什么效果？<ol>
<li>一般来说，for循环中for本身是control部分，而是其中执行的操作是logic部分，因此与我们要分离control和logic的初衷所违背，成为重灾区</li>
<li>处理方法是，将for循环按这两部分进拆分：循环部分让map/reduce这些控制来实现，而logic部分作为control部分的参数进行传入。通过这样就实现了control和logic的分离</li>
</ol>
</li>
</ol>
</li>
<li>而实现泛型，不仅需要我们程序员逻辑代码上的改变，也需要语言本身、编译器对齐进行支持才可以实现。</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%865%EF%BC%9A%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%865%EF%BC%9A%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">专题知识5：内存相关</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 11:51:00" itemprop="dateCreated datePublished" datetime="2020-04-08T11:51:00+08:00">2020-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 19:31:54" itemprop="dateModified" datetime="2020-04-12T19:31:54+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AF%AD%E8%A8%80-c/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_语言/c++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%865%EF%BC%9A%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/" class="post-meta-item leancloud_visitors" data-flag-title="专题知识5：内存相关" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月8日 上午11:51</p>
<p><a href="bear://x-callback-url/open-note?id=A54ECAD0-E043-4021-AE84-B75D618E10DB-1248-0000DB50D44264DF">专题知识点3：const</a>const是存储在.text的常量区</p>
<h4 id="new-delete与malloc-free的区别是什么"><a href="#new-delete与malloc-free的区别是什么" class="headerlink" title="new/delete与malloc/free的区别是什么"></a>new/delete与malloc/free的区别是什么</h4><ol>
<li>首先，new_delete是C++的关键字，而malloc_free是C语言的库函数，</li>
<li>malloc不会调用构造函数和析构函数：<ol>
<li>需要给定申请内存的大小，返回的指针需要强转。</li>
</ol>
</li>
<li>new会调用构造函数<ol>
<li>不用指定内存大小，返回的指针不用强转。</li>
</ol>
</li>
</ol>
<h4 id="什么是memory-leak，也就是内存泄漏"><a href="#什么是memory-leak，也就是内存泄漏" class="headerlink" title="什么是memory leak，也就是内存泄漏"></a>什么是memory leak，也就是内存泄漏</h4><ol>
<li><strong>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。</strong>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，<strong>失去了对该段内存的控制</strong>，因而造成了内存的浪费。</li>
</ol>
<h4 id="内存泄漏的分类：内存泄漏的常见原因"><a href="#内存泄漏的分类：内存泄漏的常见原因" class="headerlink" title="内存泄漏的分类：内存泄漏的常见原因"></a>内存泄漏的分类：内存泄漏的常见原因</h4><ol>
<li>堆内存泄漏 （Heap leak）。<ol>
<li>对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</li>
</ol>
</li>
<li>系统资源泄露（Resource Leak）。<ol>
<li>主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li>
</ol>
</li>
<li>没有将基类的析构函数定义为虚函数。<ol>
<li>当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li>
</ol>
</li>
<li><a href="bear://x-callback-url/open-note?id=71D3B9CC-2DE8-479F-9BBD-E153A8A6B9BA-1248-0000D5840CF48A53">专题知识点1：指针专题</a>smart_ptr也可以引起内存泄漏</li>
</ol>
<h4 id="C-的内存管理是怎样的？"><a href="#C-的内存管理是怎样的？" class="headerlink" title="C++的内存管理是怎样的？"></a>C++的内存管理是怎样的？</h4><ol>
<li><strong>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</strong></li>
<li>代码段:<ol>
<li>包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</li>
</ol>
</li>
<li>数据段：<ol>
<li>存储程序中已初始化的全局变量和静态变量</li>
</ol>
</li>
<li>Bss 段：<ol>
<li>存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</li>
</ol>
</li>
<li>堆区：<ol>
<li>调用new_malloc函数时在堆区动态分配内存，同时需要调用delete_free来手动释放申请的内存。</li>
</ol>
</li>
<li>映射区:<ol>
<li>存储动态链接库以及调用mmap函数进行的文件映射</li>
</ol>
</li>
<li>栈：<ol>
<li>使用栈空间存储函数的返回地址、参数、局部变量、返回值</li>
</ol>
</li>
</ol>
<h4 id="函数在main函数执行前先运行"><a href="#函数在main函数执行前先运行" class="headerlink" title="函数在main函数执行前先运行"></a>函数在main函数执行前先运行</h4><ol start="2">
<li>在 .text之前：<strong>data段的内容</strong>:<ol>
<li>全局对象的构造函数会在main 函数之前执行。</li>
<li>一些全局变量、对象和静态变量、对象的空间分配和赋初值就是在执行main函数之前，而main函数执行完后，还要去执行一些诸如释放空间、释放资源使用权等操作</li>
</ol>
</li>
<li>在 .text之前：<strong>.bss段的内容</strong><ol>
<li>进程启动后，要执行一些初始化代码（如设置环境变量等），然后跳转到main执行。全局对象的构造也在main之前。</li>
</ol>
</li>
<li>通过关键字<strong>attribute</strong>，让一个函数在主函数之前运行，进行一些数据初始化、模块加载验证等。</li>
</ol>
<h4 id="Main函数执行之前，主要就是初始化系统相关资源："><a href="#Main函数执行之前，主要就是初始化系统相关资源：" class="headerlink" title="Main函数执行之前，主要就是初始化系统相关资源："></a>Main函数执行之前，主要就是初始化系统相关资源：</h4><p><a href="https://www.jianshu.com/p/4260d859f181" target="_blank" rel="noopener">C语言深度总结全面认识main函数之前运行代码 - 简书</a></p>
<ol>
<li><strong>设置栈指针</strong></li>
<li>在 .text之前：<strong>data段的内容</strong>:<ol>
<li>初始化static静态和global全局变量</li>
</ol>
</li>
<li>在 .text之前：<strong>.bss段的内容</strong><ol>
<li>将未初始化部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等</li>
</ol>
</li>
<li>.text段：<ol>
<li>将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/120/">120</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhiheng Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1193</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">103</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhiheng Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">18:20</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        






  <script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.getAttribute('data-flag-title');

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=QiM1vjQ7SAoirKD4qY57L82O-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id'     : 'QiM1vjQ7SAoirKD4qY57L82O-gzGzoHsz',
            'X-LC-Key'    : 'aOHhzmfDblK0HGWUqEyb6ra2',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
