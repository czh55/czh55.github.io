<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenzhiheng.cn","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Zhiheng Chen‘s blogs">
<meta property="og:url" content="http://chenzhiheng.cn/page/7/index.html">
<meta property="og:site_name" content="Zhiheng Chen‘s blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhiheng Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://chenzhiheng.cn/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Zhiheng Chen‘s blogs</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6bc779d0e3be483fc01e871fbb7cef3d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zhiheng Chen‘s blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/15/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/a_linux%E6%8C%87%E4%BB%A4/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E5%8D%95%E5%85%83%E7%9A%84%E8%A7%92%E5%BA%A6%E6%95%B4%E7%90%86linux%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiheng Chen‘s blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/15/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/a_linux%E6%8C%87%E4%BB%A4/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E5%8D%95%E5%85%83%E7%9A%84%E8%A7%92%E5%BA%A6%E6%95%B4%E7%90%86linux%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">从对象单元的角度整理linux命令</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 12:04:00" itemprop="dateCreated datePublished" datetime="2020-04-15T12:04:00+08:00">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 21:53:24" itemprop="dateModified" datetime="2020-06-08T21:53:24+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-c-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-a-linux%E6%8C%87%E4%BB%A4/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/c_计算机系统/a_linux指令</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/15/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/a_linux%E6%8C%87%E4%BB%A4/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E5%8D%95%E5%85%83%E7%9A%84%E8%A7%92%E5%BA%A6%E6%95%B4%E7%90%86linux%E5%91%BD%E4%BB%A4/" class="post-meta-item leancloud_visitors" data-flag-title="从对象单元的角度整理linux命令" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>800</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月15日 下午12:04</p>
<h5 id="序："><a href="#序：" class="headerlink" title="序："></a>序：</h5><ul>
<li>为什么会有这篇文章？<ul>
<li>因为我即使在学习、使用linux命令的过程中详细的做了笔记，但是如果半个月不用真的就忘了大半，每次返回来在复习笔记的过程中还是觉得学习路线不清晰，都是散乱的点，所以我就尝试能不能再找一个角度进行总结，所以就有了这篇文章。</li>
</ul>
</li>
<li>那为什么要以对象单元为角度呢？<ul>
<li>其实这个角度我自己起的名字，我的初衷是希望可以结合linux系统的知识反过来推理linux应该提供哪些命令帮助程序员了解linux的运行情况。那么首当其冲的就是以进程为单位，因为linux系统中所有的任务都是一个或者多个进行在处理。对于一个进程进行socket文件读写的任务，从理论上来说我们既可以从进程的角度进行描述，也可以从设备读写的角度进行描述，也可以从网络的角度进行描述，正式因为这种角度的多样性，linux需要为不同需要的程序员来提供各自合适的工具。</li>
</ul>
</li>
</ul>
<h4 id="linux为开发者提供的工具包"><a href="#linux为开发者提供的工具包" class="headerlink" title="linux为开发者提供的工具包"></a>linux为开发者提供的工具包</h4><p><a href="bear://x-callback-url/open-note?id=F73C7047-94EC-4A5B-B716-09802AEF6D42-1064-00001B007E116822">curl</a><br><a href="bear://x-callback-url/open-note?id=DC2233D1-0C53-4BF4-865B-AB001D336C5C-803-0000422566ADD03B">traceroute</a><br>客户端操作进程的方式：<br><a href="bear://x-callback-url/open-note?id=04FCA021-94F1-4407-8E7F-1C03E1BA87C3-1064-00002D298C8E5FE7">Linux 守护进程的启动方法:bg、disown、nohup、tmux、sytemd</a></p>
<ul>
<li><input disabled type="checkbox"> <a href="bear://x-callback-url/open-note?id=BCACC082-63EC-4FF4-AFAD-2676AACAECDF-1064-00002DD065332898">Systemd</a><br><a href="bear://x-callback-url/open-note?id=0A9561F7-3E94-4F01-A9D6-8434F81CCC53-827-000016B0F15519E1">bg+fg</a><br><a href="bear://x-callback-url/open-note?id=F76181EF-0184-431A-B7B3-E5456537AE60-15210-0001827723A95D37">Linux中的定时自动执行功能（at,crontab）</a></li>
</ul>
<h4 id="以硬件设备为单位，查看硬件的执行情况"><a href="#以硬件设备为单位，查看硬件的执行情况" class="headerlink" title="以硬件设备为单位，查看硬件的执行情况"></a>以硬件设备为单位，查看硬件的执行情况</h4><p><a href="bear://x-callback-url/open-note?id=F592CA50-7805-462E-9CF8-2F43F6C2E554-740-00002E84915D9881">ifconfig</a>以网卡为单位<br><a href="bear://x-callback-url/open-note?id=35679952-B3E3-40C0-94E0-45BACA481C2A-1064-00005F220CEC4B47">iftop</a>网卡为单位<br><a href="bear://x-callback-url/open-note?id=FE470B70-E6FF-48D4-BEA0-2F0EBC6221A2-827-00005F331671A6A7">根据iostate判断计算机瓶颈</a>读写设备为单位<br><a href="bear://x-callback-url/open-note?id=C72D8B44-F3C4-437A-A7C8-523342A5476E-1064-000024CD17DF3041">查看系统版本和管理员</a><br><a href="bear://x-callback-url/open-note?id=D1DFB994-BDA0-47A5-993F-052B6A7DEBA8-740-00002C7BCBBD8879">查询cpu信息</a>cpu</p>
<h4 id="以进程为单位，查看linux各个子系统的执行情况："><a href="#以进程为单位，查看linux各个子系统的执行情况：" class="headerlink" title="以进程为单位，查看linux各个子系统的执行情况："></a>以进程为单位，查看linux各个子系统的执行情况：</h4><p><a href="bear://x-callback-url/open-note?id=B9C075C8-BC3A-4A29-976D-4D783B4D9C41-1064-00005F0B1034AA04">htop</a>进程为单位<br><a href="bear://x-callback-url/open-note?id=6F189998-F016-4B08-93CC-9E3880EFDAEA-740-00002B4DF3EA80DE">top</a>进程为单位</p>
<ul>
<li><input disabled type="checkbox"> <a href="bear://x-callback-url/open-note?id=B24690B1-4F33-4790-9A60-AB02830933F6-1064-0000431B6FB57565">lsof(list open files)</a>进程为单位，查看文件读写系统</li>
<li><input disabled type="checkbox"> <a href="bear://x-callback-url/open-note?id=ACFDC824-6D99-46B0-A82B-3844902A3EA4-1064-00005F4826F57092">iotop:每个进程是如何使用 IO</a>进程为单位，查看io子系统</li>
<li><input disabled type="checkbox"> <a href="bear://x-callback-url/open-note?id=177C76D8-6AE3-440C-85D0-0E5D0ABF8E64-827-00000802A7502611">ps</a>进程为单位<br><a href="bear://x-callback-url/open-note?id=2343CD79-DB5D-4B83-9922-A03711CFFDA8-827-00006042D9E747CC">僵尸进程：原理+清理</a><br><a href="bear://x-callback-url/open-note?id=E806CE17-7A6D-4509-A9AF-E2074905933D-1064-00002A8BA1197BC7">kill</a>进程为单位</li>
</ul>
<h4 id="以其他为单位，查看子系统的执行情况"><a href="#以其他为单位，查看子系统的执行情况" class="headerlink" title="以其他为单位，查看子系统的执行情况"></a>以其他为单位，查看子系统的执行情况</h4><p><a href="bear://x-callback-url/open-note?id=C741790D-0479-4BD4-A092-E44897C7FACC-827-000180D29BA8A951">netstat</a>以连接为单位<br><a href="bear://x-callback-url/open-note?id=4EA264FC-8D50-4BCB-AF81-8C494A44E171-1144-0000555FD9C08AB9">iptable</a>以规则为单位<br><a href="bear://x-callback-url/open-note?id=99AB2F0D-CA76-4273-9485-B8642758750A-499-00000A1C27961712">看懂本机上的路由表，并操作</a>以路由规则为单位<br>硬盘：<br><a href="bear://x-callback-url/open-note?id=726B0BF1-9046-441D-986E-43072DE1A68E-740-000021DF2FCC08ED">df</a>目录结构<br><a href="bear://x-callback-url/open-note?id=1203A121-366C-4E68-9ECD-1B3FE6AE66FC-15210-0003F035CD63F862">硬盘</a>目录结构</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/13/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F/linux%E4%B8%AD%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99(%E5%8C%85%E6%8B%AC%E5%90%84%E7%A7%8D%E6%8A%BD%E8%B1%A1%E6%96%87%E4%BB%B6%EF%BC%9A%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E3%80%81%E5%9D%97%E8%AE%BE%E5%A4%87%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97%E7%AD%89%E7%AD%89)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiheng Chen‘s blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/13/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F/linux%E4%B8%AD%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99(%E5%8C%85%E6%8B%AC%E5%90%84%E7%A7%8D%E6%8A%BD%E8%B1%A1%E6%96%87%E4%BB%B6%EF%BC%9A%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E3%80%81%E5%9D%97%E8%AE%BE%E5%A4%87%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97%E7%AD%89%E7%AD%89)/" class="post-title-link" itemprop="url">linux中，是如何完成文件的读写(包括各种抽象文件：字符设备、块设备、套接字等等)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-13 12:19:00" itemprop="dateCreated datePublished" datetime="2020-04-13T12:19:00+08:00">2020-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 15:40:57" itemprop="dateModified" datetime="2020-06-08T15:40:57+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-c-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-b-linux%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/c_计算机系统/b_linux系统/系统</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/13/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F/linux%E4%B8%AD%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99(%E5%8C%85%E6%8B%AC%E5%90%84%E7%A7%8D%E6%8A%BD%E8%B1%A1%E6%96%87%E4%BB%B6%EF%BC%9A%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E3%80%81%E5%9D%97%E8%AE%BE%E5%A4%87%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97%E7%AD%89%E7%AD%89)/" class="post-meta-item leancloud_visitors" data-flag-title="linux中，是如何完成文件的读写(包括各种抽象文件：字符设备、块设备、套接字等等)" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月13日 下午12:19</p>
<h4 id="在讲解这个过程的同时，也可以一并理解一下几个问题："><a href="#在讲解这个过程的同时，也可以一并理解一下几个问题：" class="headerlink" title="在讲解这个过程的同时，也可以一并理解一下几个问题："></a>在讲解这个过程的同时，也可以一并理解一下几个问题：</h4><ol>
<li>为什么需要文件描述符？</li>
<li>文件描述符fd与inode有关系吗，有怎样的关系？</li>
<li>linux内核是如何封装各种抽象文件的读写接口的，能做到所谓的“一切皆文件”？</li>
<li>不同的抽象文件，他们之间的读写操作在内核中有什么区别？也就是linux内核它封装了什么？(等同于上一个问题)</li>
<li>你怎样验证你说的是正确的？有没有可以证明的方式？</li>
</ol>
<h4 id="讲解的角度、方法："><a href="#讲解的角度、方法：" class="headerlink" title="讲解的角度、方法："></a>讲解的角度、方法：</h4><p>我们这里采用自顶向下的角度来讲解linux中是如何完成文件的读写。所谓自顶向下其实就是按着程序员代码不断展开，到达系统调用，在系统调用中就需要看linux内核的实现了，这里我们绕过内核的具体代码实现，直接找到通过系统内核系统调用之后处理的结果什么，通过这样间接的方式来验证我们的思路正确性，具体来说就是看能够在linux系统中找到系统内核调用过程中使用的文件以及对应的文件描述符，这些文件或者文件描述符其实就是系统内核调用在运行过程中留下的脚印👣，我们可以按图索骥看看内核到底干了点什么。</p>
<h4 id="linux中，是如何完成文件的读写"><a href="#linux中，是如何完成文件的读写" class="headerlink" title="linux中，是如何完成文件的读写"></a>linux中，是如何完成文件的读写</h4><ol>
<li>根据操作系统的我们已有的知识储备，我们知道操作系统是很讲究设计的，也就是各个部门之间的分工合作，并且有上下级之间的封装调用，可以做到下级对上级来说，下级的工作是透明的。具体的在linux中的体现就是：区分用户态和内核态。从linux设计的角度来说，希望让竟可能的降低系统的使用者也就是程序员的使用难度，给他们封装出一些丰富的接口，够他们能够完成功能就可以了，程序员你就别管我操作系统是如何实现你调用的接口了。</li>
<li>正是由于来于这样一种考虑，linux设计了文件描述符：当一个文件被一个进程打开，就会创建一个文件描述符，这里的文件描述符可以理解成字节流的接口，接口这个词就能很清晰的体现了文件描述符在linux中的本质特性。那么，<strong>从用户态这个层面来看，其实并不是一切皆文件，而是一切皆文件描述符。</strong></li>
<li>那么对于有追求的程序员来说，他不满足现状，他希望可以弄明白linux内核是如何实现文件的读写的。这是我们就需要思考一个问题，难道整个文件系统有两层吗，一层是用户态，一层是内核态，内核态就能直接操作硬盘上的文件吗？其实，我们单独拿出内核态来看，它为了实现文件的读写，其实也有所谓的层次结构，这中间也进行了精妙的设计。这里面最关键的一个设计就是inode，<strong>inode将我们操作的文件进行抽象，成为我们操作文件读写时最小的操作单元，也就是说，在内核态中其实他操作是的inode</strong>，可千万别以为我们直接操作的是赤裸裸的文件，inode就可以很要的封装了各个文件之间大小类型之间的区别，可以说inode是实现文件读写最最核心的关键，其他的类似于管理不同的抽象文件读写，其实都是在inode基础上的业务逻辑，业务逻辑可以频繁的更换，但是基础的inode这层定义逻辑是一定不能变的。这里我们就知道inode真的是特别特别重要，理解inode对理解操作系统也是一个关键。</li>
<li>认识到inode的重要性，我们接下来说说linux是如何考虑在inode的基础上完成所谓的业务逻辑，来实现不同的抽象文件的读写操作。<ol>
<li>inode的重要性就像是数据结构与算法中数据结构对算法的作用，inode就是这里的数据结构，在做算法题的时候，我们知道如果我们设计出了这道题需要的数据结构，那么写算法在熟练语法的基础上就是分分钟的事情</li>
<li>在inode这套数据结构之上，<strong>我们可以这样认为：从内核态的角度来看，不是所谓的一切皆文件描述符，而是一切皆inode</strong>，因为内核态中文件描述符是不存在，在从用户态到内核态时文件描述符已近展开了成为了inode。<strong>文件描述符fd和inode其实都是一个非负整数，这点他们是相同的。</strong></li>
<li>如何证明inode是可以对抽象文件，eg：tcp socket进行抽象表示呢？在<a href="https://www.cnblogs.com/MrVolleyball/p/9987208.html" target="_blank" rel="noopener">linux一切皆文件之tcp socket描述符（三） - wilson排球 - 博客园</a>就可以找到证据。</li>
<li>要实现不同文件类型的读写，我们考虑到linux是一个各种子系统的集合 <a href="bear://x-callback-url/open-note?id=B8B464F7-1E8D-435A-AB86-6D0F52CD7D1B-1248-000098B1433E95C7">将操作系统分解，看看这个庞大的系统中包含哪些子系统</a>，这其中就包括网络子系统，当我们需要完成基于socket、tcp socket的文件读写的时候，就需要依赖于网络子系统，把这部分工作承包给它；还有输入输出系统，当我们需要对块设备进行读写时，我们依然需要依赖于它；还有对字符流设备的读写，这里的例子有ssh连接的连接过程，其实就是一个文件读写的过程，它的本质不变，依然可以拆解为单个的文件读写过程，只不过ssh连接进行操作的过程并不是依靠单独唯一的进程、文件，它需要涉及到进行的fork，以及各个进程都会有自己对应的操作文件组。在学习的过程中，一定要明白这部分是属于业务逻辑，比如在ssh中，可以称作为client和server进行交互的逻辑。在学习的时候，容易沉溺于业务逻辑中，而忘记了文件读写的本质操作。业务逻辑会根据业务的不同随时变化，但是文件读写这样基本的操作是永远不会变的，各种复杂的业务也都是有多个文件读写操作进行组合完成的。</li>
<li>那么现在回答：单独的文件读写的本质是什么，是如何完成的？<ol>
<li>一个进程A启动,那么并不是进打开一个文件，而是会打开各种各样的文件，这这些文件中有很多都是这个进行它所依赖的系统库文件，在这些依赖的系统库文件之外，才有我们真正进行读写的文件，这些文件在打开之后，会有对应的文件描述符</li>
<li>我们可以在<code>/proc/A/fd</code>找到这些文件描述符的链接，这个链接就会指向我们真正操作的文件位置。其实这个位置是给内核态使用的，他拿上这个位置上的文件进行操作。在从用户态到内核态的过程中，我们就依赖于这个链接完成用户态到内核态的转换。这个位置可以是linux下文件的真实路径，这部分工作由linux文件子系统完成，另外这个位置也可以直接指向inode的编号，在socket链接中我们就以看到这个inode编号。</li>
<li><strong>简单来说，读写文件的核心是用户态到内核态的一次转换过程，至于到达内核态之后，会根据你操作的文件类型，内核会选择不同的助手子系统来完成真正的inode读写操作。</strong></li>
<li>对node的读写，就是读写文件的最后一步。至于要问如何完成对node的读写，我下次在写。</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/12/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/a_%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/%E7%90%86%E8%A7%A3control%E3%80%81logic%E3%80%81data%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiheng Chen‘s blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/12/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/a_%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/%E7%90%86%E8%A7%A3control%E3%80%81logic%E3%80%81data%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">理解control、logic、data、泛型、函数式编程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-12 02:42:00" itemprop="dateCreated datePublished" datetime="2020-04-12T02:42:00+08:00">2020-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 15:40:50" itemprop="dateModified" datetime="2020-06-08T15:40:50+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-e-%E8%AF%AD%E8%A8%80-a-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/e_语言/a_编程范式</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/12/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/a_%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/%E7%90%86%E8%A7%A3control%E3%80%81logic%E3%80%81data%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="理解control、logic、data、泛型、函数式编程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月12日 下午2:42</p>
<h4 id="还是从需求的角度进行分析-理解control、logic、data、泛型、函数式编程"><a href="#还是从需求的角度进行分析-理解control、logic、data、泛型、函数式编程" class="headerlink" title="还是从需求的角度进行分析,理解control、logic、data、泛型、函数式编程"></a>还是从需求的角度进行分析,理解control、logic、data、泛型、函数式编程</h4><ol>
<li>老一辈的有经验的程序员认识到：我们需要将代码中的control，logic，data进行分离，这样不管我们看别人的代码，还是自己写代码都会更加的有逻辑，更容易看懂并写出，而不仅仅是完成功能就可以了</li>
<li>那我们如何实现所谓的control，logic，data的分离呢？<ol>
<li>首先我们需要将data进行分离，因为data与control和logic的区别更大</li>
<li>这个操作我们把它叫做泛型，当然在泛型的过程中并不是使用一个T就可以了，我们需要将泛型和迭代一起完成，详见 <a href="bear://x-callback-url/open-note?id=27C737A4-47D9-4205-82FA-767D5B68C0CB-711-00003AC547043BB6">模板编程：分步骤STL如何实现泛型</a></li>
</ol>
</li>
<li>实现泛型之后，我们如何将control和logic进行分离呢？<ol>
<li>首先，我们需要明白什么是contorl什么是logic，control我把它理解成是调度好像更好理解一些；而logic其实就是我们业务功能。当我们需要更换业务功能时，是可以使用同一个套control进行调度的。可以把control和logic之间的关系可以称作为“范llogic”,这个名字去自与泛型。一个control的例子：map_reduce_filter 就是control，他们只负责遍历。</li>
<li>这时候，我们将control和logic进行分离之后进行的编程方法叫做函数式编程。当然，上面说的从control和logic进行分离角度来认识函数式编程，其实函数式编程的起源是来自于数学上的函数，函数有有两个特性：stateless,immutable，而函数式编程也必须满足这两个条件，最终能够做到并行执行和copy-paste。两个角度不同而已。</li>
</ol>
</li>
<li>此时，我们有了实现control，logic，data的分离的方法，也引出了泛型编程和函数编程，那么泛型编程和函数编程具体在语言中该如何进行实现呢？<ol>
<li>函数式编程的实现：<ol>
<li>函数式编程其实还是程序员逻辑角度的不同，并不需要语言、编译器对其进行支持(当然有些语言在设计语法的时候就考虑到了函数式编程，甚至只能进行函数式编程，那么就可以在我们使用函数式编程的时候提供语法层面的便利)</li>
<li>函数式编程其实就是逻辑的抽象，比过程式这样扁平的设计更加立体，有更多的上下级函数之间的调用封装。</li>
<li>明白了函数式的思想，那么我们看看代码中具体如何实现函数式呢：<ol>
<li>利用函数编程的三驾马车：filter_map_reduce，把for循环进行函数的封装，隐藏起来。</li>
<li>递归代替for循环。</li>
<li>其实，如果将所有的函数式编程的调用过程展开，最终其实还是会变回for循环，只不过由于上下级的调用封装，我们将for循环进行了隐藏，你看不见，并不代表没有，这部分内容其实可以通过map_reduce的实现来看出，map_reduce其实就是通过for循环来实现的。</li>
</ol>
</li>
<li>为什么拿掉for是实现函数式编程的关键？拿掉之后对有什么效果？<ol>
<li>一般来说，for循环中for本身是control部分，而是其中执行的操作是logic部分，因此与我们要分离control和logic的初衷所违背，成为重灾区</li>
<li>处理方法是，将for循环按这两部分进拆分：循环部分让map/reduce这些控制来实现，而logic部分作为control部分的参数进行传入。通过这样就实现了control和logic的分离</li>
</ol>
</li>
</ol>
</li>
<li>而实现泛型，不仅需要我们程序员逻辑代码上的改变，也需要语言本身、编译器对齐进行支持才可以实现。</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/10/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_2020%E9%87%8D%E5%AD%A6c++/%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%89%8D%E4%B8%83%E7%AB%A0%E4%B9%A0%E9%A2%98/%E5%89%8D%E4%B8%83%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiheng Chen‘s blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_2020%E9%87%8D%E5%AD%A6c++/%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%89%8D%E4%B8%83%E7%AB%A0%E4%B9%A0%E9%A2%98/%E5%89%8D%E4%B8%83%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">b计算机基础/e_语言/c_2020重学c++/知识点/前七章习题/前七章习题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-10 17:29:30" itemprop="dateCreated datePublished" datetime="2020-04-10T17:29:30+08:00">2020-04-10</time>
            </span>

          
            <span id="/2020/04/10/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_2020%E9%87%8D%E5%AD%A6c++/%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%89%8D%E4%B8%83%E7%AB%A0%E4%B9%A0%E9%A2%98/%E5%89%8D%E4%B8%83%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-meta-item leancloud_visitors" data-flag-title="b计算机基础/e_语言/c_2020重学c++/知识点/前七章习题/前七章习题" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h1 id="第一章："><a href="#第一章：" class="headerlink" title="第一章："></a>第一章：</h1><h2 id="一、基础题"><a href="#一、基础题" class="headerlink" title="一、基础题"></a>一、基础题</h2><ol>
<li><p>请说出C++语言的优点，缺点，和主要用途？（<strong>涉及知识点：1-4节 C++特点， 1-5 C++作用</strong>） </p>
<p>优点：</p>
<ul>
<li>强大的抽象封装能力：这让C++语言具备了强大的开发工程能力，在封装的同时C++最大程度的保留了高性能；</li>
<li>高性能：运行快，快并且占用资源少一直是C++语言的追求；</li>
<li>低功耗：特别适合在各种微型的嵌入式设备中运行高效的程序；</li>
</ul>
<p>缺点：</p>
<ul>
<li>语法相对复杂，细节比较多，学习曲线比较陡；</li>
<li>需要一些好的规范和范式，否则代码很难维护；</li>
</ul>
</li>
</ol>
<h2 id="二、提高题"><a href="#二、提高题" class="headerlink" title="二、提高题"></a>二、提高题</h2><ol>
<li>请参考课程演示代码”CPPDemo1”中的C++面向对象方式，思考C面向过程方式中如何实现trace功能在开关打开状态下写入到文件中，并想想这两种方式各自的优缺点？（<strong>涉及知识点：1-3节 C++vsC，面向对象vs面向过程</strong>） </li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> trigger;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	trigger = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	trigger = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *fp = fopen(<span class="string">"test.txt"</span>,<span class="string">"a+"</span>);</span><br><span class="line">    <span class="keyword">if</span>(trigger)</span><br><span class="line">    &#123;</span><br><span class="line">        fwrite(s,<span class="number">1</span>,n,fp);</span><br><span class="line">    &#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	turnOn();</span><br><span class="line">	<span class="built_in">write</span>(<span class="string">"First"</span>,<span class="number">5</span>);</span><br><span class="line">	turnOff();</span><br><span class="line">	<span class="built_in">write</span>(<span class="string">"Second"</span>,<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c语言需要用全局变量和全局函数来实现，在稍微大一些的项目中，将会产生难以维护，难以扩展，难以阅读的问题，而C++封装对象的方式就可以解决这些问题。</p>
<p>c语言在内存方面占用更小。在微型项目中编写更加方便。</p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="一、基础题-1"><a href="#一、基础题-1" class="headerlink" title="一、基础题"></a>一、基础题</h2><ol>
<li>下面标识符是合法的有哪些（BEF ） （<strong>涉及知识点： 2-5 标识符与关键字</strong>）<br><strong>A</strong>.float<br><strong>B</strong>.ipad<br><strong>C</strong>.1button<br><strong>D</strong>. A#BC<br><strong>E</strong>.my_button<br><strong>F</strong>. button_1_ok </li>
<li>请给一个退出按钮命一个好变量名（ C）（<strong>涉及知识点： 2-5 标识符</strong>）<br><strong>A</strong>. 1button<br><strong>B</strong>. button1<br><strong>C</strong>.buttonQuit<br><strong>D</strong>.button_tuichu </li>
<li>下面整数常量合法的是（ D）（<strong>涉及知识点： 2-6 常量</strong>）<br><strong>A</strong>.078<br><strong>B</strong>.03UU<br><strong>C</strong>.0x9AHX<br><strong>D</strong>.0xFFAA00 </li>
</ol>
<h2 id="二、提高题-1"><a href="#二、提高题-1" class="headerlink" title="二、提高题"></a>二、提高题</h2><ol>
<li><p>下面程序输出结果是    (8)（<strong>涉及知识点： 2-6 常量的宏定义</strong>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MA(x) x*(x-1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">1</span>, b=<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; MA(<span class="number">1</span>+a+b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;  <span class="comment">// 8</span></span><br><span class="line">   <span class="comment">//ma(1+a+b) = 1+a+b*(1+a +b-1)</span></span><br><span class="line">   <span class="comment">//            = 1+1+2*(1+1+2-1)</span></span><br><span class="line">   <span class="comment">//            = 8</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="第三章："><a href="#第三章：" class="headerlink" title="第三章："></a>第三章：</h1><h2 id="一、填空"><a href="#一、填空" class="headerlink" title="一、填空"></a>一、填空</h2><ol>
<li><pre><code class="c++"><span class="built_in">cout</span> &lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//1</span>
<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(short) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//2</span>
<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//4</span>
<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//4</span>
<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//8</span>
&lt;!--￼<span class="number">2</span>--&gt;</code></pre>
</li>
<li><pre><code class="c++"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span>
short Sunday = <span class="number">0</span>;
short Monday = <span class="number">1</span>;
short Tuesday = <span class="number">2</span>;
short Wednesday = <span class="number">3</span>;
short Thursday = <span class="number">4</span>;
short Friday = <span class="number">5</span>;
short Saturday = <span class="number">6</span>;
} Week;
Week w;
<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(w.Sunday); <span class="comment">//2</span>
<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(w) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//14</span>
&lt;!--￼<span class="number">3</span>--&gt;</code></pre>
</li>
<li><p>分别写出bool 、int、 float、与“零值”比较，表达式返回值等于1的代码片段；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#设变量为flag</span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">bool</span>:</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line"><span class="keyword">int</span>:</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">double</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> EPSINON = <span class="number">0.00001</span>;  </span><br><span class="line"> <span class="keyword">if</span> ((flag &gt;= - EPSINON) &amp;&amp; (flag &lt;= EPSINON))</span><br><span class="line"><span class="keyword">char</span> *:</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="第四五六章："><a href="#第四五六章：" class="headerlink" title="第四五六章："></a>第四五六章：</h1><h2 id="一、程序运行题"><a href="#一、程序运行题" class="headerlink" title="一、程序运行题"></a>一、程序运行题</h2><ol>
<li>请说出下列问号处的结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   char str[] &#x3D; “Hello” ;</span><br><span class="line">char *p &#x3D; str ;</span><br><span class="line">int n &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F;请计算</span><br><span class="line">sizeof (str ) &#x3D; ?</span><br><span class="line">sizeof ( p )  &#x3D; ?</span><br><span class="line">sizeof ( n )  &#x3D; ?</span><br><span class="line">void Func ( char str[100])</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;请计算</span><br><span class="line">    sizeof( str ) &#x3D; ?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>答：<br>    sizeof (str ) = 6<br>    sizeof ( p ) = 4<br>    sizeof ( n ) = 4<br>    void Func ( char str[100])<br>    {<br>      sizeof( str ) = 4<br>    }</strong></p>
<ol start="2">
<li><pre><code>void GetMemory(char *p)
{
    p = new char[100];
}
void Test(void)
{
    char *str = NULL;
    GetMemory(str);
    strcpy(str, &quot;hello world&quot;);
    printf(str);
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    问运行Test 函数会有什么样的结果？</span><br><span class="line">**答：程序崩溃。因为GetMemory 并不能传递动态内存，</span><br><span class="line">Test 函数中的 str 一直都是 NULL。strcpy(str, &quot;hello world&quot;);将使程序崩溃。**</span><br><span class="line"></span><br><span class="line">3.</span><br></pre></td></tr></table></figure>
char *GetMemory(void)
{
    char p[] = &quot;hello world&quot;;
    return p;
}
void Test(void)
{
    char *str = NULL;
    str = GetMemory();
    printf(str);
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请问运行Test 函数会有什么样的结果？</span><br><span class="line">**答：可能是乱码;因为GetMemory 返回的是指向“栈内存”的指针，该指针的地址不是 NULL，但其原现的内容已经被清除，新内容不可知。**</span><br><span class="line"></span><br><span class="line">4.</span><br></pre></td></tr></table></figure>
void GetMemory2(char **p, int num)
{
    *p = new char[num];
}
void Test(void)
{
    char *str = NULL;
    GetMemory2(&amp;str, 100);
    strcpy(str, &quot;hello&quot;);
    printf(str);
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   请问运行Test 函数会有什么样的结果？</span><br><span class="line">    **答：能够输出hello，但内存泄漏 **</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.</span><br></pre></td></tr></table></figure>
# include &lt;string.h&gt;
 void Test(void)
 {
     char *str = new  char[100];
     strcpy(str, &quot;hello&quot;);
     delete[ ] str;
     if (str != NULL)
     {
         strcpy(str,&quot;world&quot;);
         printf(str);
     }
 }
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   请问运行Test 函数会有什么样的结果？</span><br><span class="line">    **答：篡改动态内存区的内容，后果难以预料，非常危险。因为 delete[ ]str;之后，str成为野指针(需要str &#x3D; NULL;)if(str !&#x3D; NULL)语句不起作用。**</span><br><span class="line"></span><br><span class="line">## 二、编程题</span><br><span class="line">1. char *strcpy(char *strDest, const char *strSrc)不调用C++&#x2F;C 的字符串库函数，请编写函数 strcpy；</span><br></pre></td></tr></table></figure>
char *strcpy(char *strDest, const char *strSrc);
{
assert((strDest!=NULL) &amp;&amp; (strSrc !=NULL));
char *address = strDest; 
while( (*strDest++ = * strSrc++) != ‘\0’ )
   ;
return address ; 
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 第七章：</span><br><span class="line"></span><br><span class="line">## 一、编程题</span><br><span class="line">编写自定义类String 的构造函数、析构函数和赋值函数。</span><br><span class="line">已知类String 的原型为：</span><br><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	String(const char *str &#x3D; NULL);                             &#x2F;&#x2F; 普通构造函数</span><br><span class="line">	String(const String &amp;other);                                  &#x2F;&#x2F; 拷贝构造函数</span><br><span class="line">	String(String&amp;&amp; other);                                          &#x2F;&#x2F; 移动构造函数</span><br><span class="line">	~String(void);                                                            &#x2F;&#x2F; 析构函数</span><br><span class="line">	String&amp; operator&#x3D; (const String&amp; other);             &#x2F;&#x2F; 赋值函数</span><br><span class="line">	String&amp; operator&#x3D;(String&amp;&amp; rhs)noexcept;		  &#x2F;&#x2F; 移动赋值运算符</span><br><span class="line">private:</span><br><span class="line">	char *m_data; &#x2F;&#x2F; 用于保存字符串</span><br><span class="line">&#125;;</span><br><span class="line">请编写String 的上述几个函数。</span><br></pre></td></tr></table></figure>
// String 的析构函数
String::~String(void)
{
 if (m_data != NULL)
 {
     delete[] m_data;
 }
}
</code></pre></li>
</ol>
<p>// String 的普通构造函数<br>String::String(const char *str)<br>{<br>    if (str == NULL)<br>    {<br>        m_data = new char[1];<br>        if (m_data != NULL)<br>        {<br>            *m_data = ‘\0’;<br>        }<br>        else<br>        {<br>            exit(-1); // new有可能失败，失败后返回错误退出, 最好能有日志<br>        }<br>    }<br>    else<br>    {<br>        int length = strlen(str);<br>        m_data = new char[length + 1];<br>        if (m_data != NULL)<br>        {<br>            *m_data = ‘\0’;<br>        }<br>        else<br>        {<br>            exit(-1); // new有可能失败，失败后返回错误退出, 最好能有日志<br>        }<br>        strcpy(m_data, str);<br>    }<br>}<br>// 拷贝构造函数<br>String::String(const String &amp;other)<br>{<br>    int length = strlen(other.m_data);<br>    m_data = new char[length + 1];<br>    if (m_data != NULL)<br>    {<br>        *m_data = ‘\0’;<br>    }<br>    else<br>    {<br>        exit(-1); // new有可能失败，失败后返回错误退出, 最好能有日志<br>    }<br>    strcpy(m_data, other.m_data);<br>}</p>
<p>String::String(String&amp;&amp; other)<br>{<br>    if (other.m_data != NULL)<br>    {<br>        m_data=other.m_data;<br>        other.m_data = NULL;<br>    }<br>}</p>
<p>// 赋值函数<br>String&amp; String::operator= (const String &amp;other)<br>{<br>    // 检查自赋值<br>    if (this == &amp;other)<br>        return *this;<br>    // 释放原有的内存资源<br>    delete[] m_data;<br>    // 分配新的内存资源，并复制内容<br>    int length = strlen(other.m_data);<br>    m_data = new char[length + 1];<br>    if (m_data != NULL)<br>    {<br>        *m_data = ‘\0’;<br>    }<br>    else<br>    {<br>        exit(-1); // new有可能失败，失败后返回错误退出, 最好能有日志<br>    }<br>    strcpy(m_data, other.m_data);<br>    //  返回本对象的引用<br>    return *this;<br>}</p>
<p>String&amp; String::operator=(String&amp;&amp; rhs)noexcept<br>{<br>    if (this != &amp;rhs)<br>    {<br>        delete[] m_data;<br>        m_data = rhs.m_data;<br>        rhs.m_data = NULL;<br>    }<br>    return *this;<br>}<br>```</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E8%A1%A5%E5%85%85/%E5%B9%BF%E4%B9%89%E7%9A%84IO%E6%A8%A1%E5%9E%8B%EF%BC%9A%E9%98%BB%E5%A1%9EIO-%3E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BF%99%E8%BD%AE%E8%AF%A2IO-%3Eselectepoll%E6%97%A0%E5%B7%AE%E5%88%AB%E8%BD%AE%E8%AF%A2%E4%BB%A3%E7%90%86-%3E%20epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiheng Chen‘s blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E8%A1%A5%E5%85%85/%E5%B9%BF%E4%B9%89%E7%9A%84IO%E6%A8%A1%E5%9E%8B%EF%BC%9A%E9%98%BB%E5%A1%9EIO-%3E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BF%99%E8%BD%AE%E8%AF%A2IO-%3Eselectepoll%E6%97%A0%E5%B7%AE%E5%88%AB%E8%BD%AE%E8%AF%A2%E4%BB%A3%E7%90%86-%3E%20epoll/" class="post-title-link" itemprop="url">b计算机基础/c_计算机系统/b_linux系统/补充/广义的IO模型：阻塞IO->非阻塞忙轮询IO->selectepoll无差别轮询代理-> epoll</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 15:25:56" itemprop="dateCreated datePublished" datetime="2020-04-08T15:25:56+08:00">2020-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-02 21:03:38" itemprop="dateModified" datetime="2020-05-02T21:03:38+08:00">2020-05-02</time>
              </span>

          
            <span id="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E8%A1%A5%E5%85%85/%E5%B9%BF%E4%B9%89%E7%9A%84IO%E6%A8%A1%E5%9E%8B%EF%BC%9A%E9%98%BB%E5%A1%9EIO-%3E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BF%99%E8%BD%AE%E8%AF%A2IO-%3Eselectepoll%E6%97%A0%E5%B7%AE%E5%88%AB%E8%BD%AE%E8%AF%A2%E4%BB%A3%E7%90%86-%3E%20epoll/" class="post-meta-item leancloud_visitors" data-flag-title="b计算机基础/c_计算机系统/b_linux系统/补充/广义的IO模型：阻塞IO->非阻塞忙轮询IO->selectepoll无差别轮询代理-> epoll" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="广义的IO模型：阻塞I-O-gt-非阻塞忙轮询I-O-gt-select-epoll无差别轮询代理-gt-epoll"><a href="#广义的IO模型：阻塞I-O-gt-非阻塞忙轮询I-O-gt-select-epoll无差别轮询代理-gt-epoll" class="headerlink" title="广义的IO模型：阻塞I/O-&gt;非阻塞忙轮询I/O-&gt;select/epoll无差别轮询代理-&gt; epoll"></a>广义的IO模型：阻塞I/O-&gt;非阻塞忙轮询I/O-&gt;select/epoll无差别轮询代理-&gt; epoll</h1><p>#b计算机基础/c_计算机系统/b_linux系统/补充<br>2020年4月8日 下午3:25</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>下面这篇文章其实写的非常好，我反复多了多次才明白其中的关键：<ol>
<li>首先，你需要理解流的概念：<ol>
<li>其实我们在server定义socket的时候<code>server = socket(AF_INET, SOCK_STREAM)</code>，这个定义会产生一个流，只不过在没有client进行连接的时候，这个流中的内容为空而已。</li>
<li>在代码中我就一直疑惑：<strong>流数组</strong>是从哪里来的？<ol>
<li>上面我们知道定义socket会产生一个流(“缓冲区空”)，当client连接server的时候，这个流中就会有信息在传递(“缓冲区非空”)</li>
<li>这里比较特殊的一个地方是：<strong>socket流中的信息也是一个流</strong>，代表着不同client与server的链接。</li>
<li>当有n个client与server进行连接的时候，加上原本socket，在当前进程中，就会有n+1个流对象</li>
</ol>
</li>
</ol>
</li>
<li>整个的IO模型，其实就是信息在流上进行一个个进行传递的过程。有些流中传递的还是流，有些流中传递的时候真正的byte数据。</li>
<li>IO模型与网络IO模型的关系：<ol>
<li>我目前见过做多的就是网络IO模型，当你把client与server之间的socket连接理解成一个流的时候，你就会发现其实就是IO模型，不要因为加上了网络就觉得难以理解</li>
<li>IO模型的基础操作单位是流，具体你是什么流(文件，socket，pipe)对于IO模型来说其实是透明的，流这个抽象就能把具体的子类对上层隐藏。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="python代码实现："><a href="#python代码实现：" class="headerlink" title="python代码实现："></a>python代码实现：</h3><p><a href="https://blog.csdn.net/u013210620/article/details/78733743" target="_blank" rel="noopener">python基础-io模型、阻塞、非阻塞、io多路复用_Python_金丙坤-CSDN博客</a><br><strong>io模型、阻塞、非阻塞、io多路复用</strong>这四种对应的client，server代码！</p>
<h3 id="概念的理解："><a href="#概念的理解：" class="headerlink" title="概念的理解："></a>概念的理解：</h3><p>补充：<a href="https://blog.csdn.net/feitianxuxue/article/details/17078179" target="_blank" rel="noopener">Epoll之ET、LT模式_网络_feitianxuxue的专栏-CSDN博客</a></p>
<ol>
<li><p>在使用epoll时，在函数 epoll_ctl中如果不设定，epoll_event 的event默认为LT（水平触发）模式。</p>
</li>
<li><p>LT模式</p>
<ol>
<li><strong>使用LT模式意味着只要fd处于可读或者可写状态，每次epoll_wait都会返回该fd</strong>，这样的话会带来很大的系统开销，且处理时候每次都需要把这些fd轮询一遍，如果fd的数量巨大，不管有没有事件发生，epoll_wait都会触发这些fd的轮询判断。</li>
</ol>
</li>
<li><p>ET模式：</p>
<ol>
<li>在ET模式下，当有事件发生时，系统只会通知你一次，即在调用epoll_wait返回fd后，不管这个事件你处理还是没处理，处理完没有处理完，当再次调用epoll_wait时，都不会再返回该fd，这样的话程序员要自己保证在事件发生时要及时有效的处理完该事件。</li>
</ol>
</li>
<li><p><em>首先我们来定义流的概念</em></p>
<ol>
<li>一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。</li>
<li>不管是文件，还是套接字，还是管道，我们都可以把他们看作流。</li>
</ol>
</li>
<li><p>之后我们来讨论<strong>I/O的操作</strong>，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，<strong>但是流中还没有数据</strong>，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），这时候该怎么办？</p>
<ul>
<li>阻塞。阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。</li>
<li>非阻塞<strong>忙</strong>轮询。接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”<ul>
<li>很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。</li>
<li>大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。</li>
</ul>
</li>
</ul>
</li>
<li><p>为了了解阻塞是如何进行的，我们来讨论<strong>缓冲区</strong>，以及内核缓冲区，最终把I_O事件解释清楚。缓冲区的引入是为了减少频繁I_O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。<br>假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。</p>
<ul>
<li><strong>假设一开始内核缓冲区是空的，B作为读出方，被阻塞着</strong>。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。</li>
<li>但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，<strong>告诉进程A，你该等等（阻塞）了</strong>，我们把这个事件定义为“缓冲区满”。</li>
<li>假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”</li>
<li>也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。<strong>这个时候内核就告诉B，你需要阻塞了！</strong>，我们把这个时间定为“缓冲区空”。</li>
<li>这四个情形涵盖了四个I_O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。 <em>_<strong>_这四个I_O事件是进行阻塞同步的根本</strong></em> 。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。</li>
</ul>
</li>
<li><p>然后我们来说说<strong>阻塞I/O的缺点</strong>。</p>
<ol>
<li>阻塞I_O模式下，一个线程只能处理一个流的I_O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。</li>
</ol>
</li>
<li><p>于是再来考虑<strong>非阻塞忙轮询的I/O方式</strong>，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> true &#123;</span><br><span class="line">	<span class="keyword">for</span> I <span class="keyword">in</span> stream[]&#123; <span class="comment">#一直轮询</span></span><br><span class="line">		<span class="keyword">if</span> I has data</span><br><span class="line">			read until unavailable</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I_O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I_O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。</li>
</ul>
</li>
<li><p>为了避免CPU空转，可以引进了<strong>一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）</strong>。这个代理比较厉害，可以同时观察许多流的I_O事件，在空闲的时候，<em>**_会把当前线程阻塞掉</em>**_，当有一个或多个流有I_O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。代码长这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> true &#123;</span><br><span class="line">	select(streams[]) <span class="comment"># 增加的这步</span></span><br><span class="line">	<span class="keyword">for</span> I <span class="keyword">in</span> streams[] &#123;</span><br><span class="line">		<span class="keyword">if</span> I has data</span><br><span class="line">			read until unavailable</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>于是，如果没有I_O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I_O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能<strong>无差别轮询</strong>所有流，找出能读出数据，或者写入数据的流，对他们进行操作。</li>
<li>但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。再次</li>
</ul>
</li>
<li><p><strong>说了这么多，终于能好好解释epoll了</strong></p>
<ul>
<li>Epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I_O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(k)，k为产生I_O事件的流的个数，也有认为O(1)的[更新 1]）</li>
<li>epoll实现机制：<ul>
<li><strong>使用epoll的时候，内核会维护一个就绪的链表，这个链表里面的东西就是”那些发生了I/O事件的流”</strong>。</li>
<li>而这些文件描述符是如何被添加到就绪链表里面的呢？是通过注册的那些回调函数实现的。</li>
<li><em>而怎么知道这些文件描述符上发生的是什么事件呢？这个就需要我们自己在代码里面去判断了。epoll这个函数返回的只是那些发生了事件的文件描述符。</em> 因为这些事件是你自己给这个文件描述符的，所以你可以通过代码判断发生了什么I/O事件。</li>
<li>于是就有”epoll只会把哪个流发生了怎样的I/O事件通知我们”。</li>
</ul>
</li>
<li>在讨论epoll的实现细节之前，先把epoll的相关操作列出[更新 2]：<ol>
<li>epoll_create 创建一个epoll对象，一般epollfd = epoll_create()</li>
<li>epoll_ctl （epoll_add_epoll_del的合体），往epoll对象中增加_删除某一个流的某一个事件</li>
<li>比如</li>
<li>epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);有缓冲区内有数据时epoll_wait返回</li>
<li>epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);缓冲区可写入时epoll_wait返回</li>
<li>epoll_wait(epollfd,…)等待直到注册的事件发生</li>
<li>（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。</li>
</ol>
</li>
<li>一个epoll模式的代码大概的样子是：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> true &#123;</span><br><span class="line">	active_stream[] = epoll_wait(epollfd) <span class="comment"># 关键步骤</span></span><br><span class="line">	<span class="keyword">for</span> I <span class="keyword">in</span> active_stream[] &#123;</span><br><span class="line">		read <span class="keyword">or</span> write till unavailable</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li>限于篇幅，这里只讲了揭示原理性的东西，至于epoll的使用细节，请参考man和google，实现细节，请参阅linux kernel source。</li>
<li>[更新1]: 原文为O(1)，但实际上O(k)更为准确</li>
<li>[更新2]: 原文所列第二点说法让人产生EPOLLIN/EPOLLOUT等同于“缓冲区非空”和“缓冲区非满”的事件，但并非如此，详细可以Google关于epoll的边缘触发和水平触发。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%865%EF%BC%9A%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiheng Chen‘s blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%865%EF%BC%9A%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">专题知识5：内存相关</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 11:51:00" itemprop="dateCreated datePublished" datetime="2020-04-08T11:51:00+08:00">2020-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 15:40:55" itemprop="dateModified" datetime="2020-06-08T15:40:55+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-e-%E8%AF%AD%E8%A8%80-c-c/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/e_语言/c_c++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%865%EF%BC%9A%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/" class="post-meta-item leancloud_visitors" data-flag-title="专题知识5：内存相关" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月8日 上午11:51</p>
<p><a href="bear://x-callback-url/open-note?id=A54ECAD0-E043-4021-AE84-B75D618E10DB-1248-0000DB50D44264DF">专题知识点3：const</a>const是存储在.text的常量区</p>
<h4 id="new-delete与malloc-free的区别是什么"><a href="#new-delete与malloc-free的区别是什么" class="headerlink" title="new/delete与malloc/free的区别是什么"></a>new/delete与malloc/free的区别是什么</h4><ol>
<li>首先，new_delete是C++的关键字，而malloc_free是C语言的库函数，</li>
<li>malloc不会调用构造函数和析构函数：<ol>
<li>需要给定申请内存的大小，返回的指针需要强转。</li>
</ol>
</li>
<li>new会调用构造函数<ol>
<li>不用指定内存大小，返回的指针不用强转。</li>
</ol>
</li>
</ol>
<h4 id="什么是memory-leak，也就是内存泄漏"><a href="#什么是memory-leak，也就是内存泄漏" class="headerlink" title="什么是memory leak，也就是内存泄漏"></a>什么是memory leak，也就是内存泄漏</h4><ol>
<li><strong>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。</strong>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，<strong>失去了对该段内存的控制</strong>，因而造成了内存的浪费。</li>
</ol>
<h4 id="内存泄漏的分类：内存泄漏的常见原因"><a href="#内存泄漏的分类：内存泄漏的常见原因" class="headerlink" title="内存泄漏的分类：内存泄漏的常见原因"></a>内存泄漏的分类：内存泄漏的常见原因</h4><ol>
<li>堆内存泄漏 （Heap leak）。<ol>
<li>对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</li>
</ol>
</li>
<li>系统资源泄露（Resource Leak）。<ol>
<li>主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li>
</ol>
</li>
<li>没有将基类的析构函数定义为虚函数。<ol>
<li>当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li>
</ol>
</li>
<li><a href="bear://x-callback-url/open-note?id=71D3B9CC-2DE8-479F-9BBD-E153A8A6B9BA-1248-0000D5840CF48A53">专题知识点1：指针专题</a>smart_ptr也可以引起内存泄漏</li>
</ol>
<h4 id="C-的内存管理是怎样的？"><a href="#C-的内存管理是怎样的？" class="headerlink" title="C++的内存管理是怎样的？"></a>C++的内存管理是怎样的？</h4><ol>
<li><strong>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</strong></li>
<li>代码段:<ol>
<li>包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</li>
</ol>
</li>
<li>数据段：<ol>
<li>存储程序中已初始化的全局变量和静态变量</li>
</ol>
</li>
<li>Bss 段：<ol>
<li>存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</li>
</ol>
</li>
<li>堆区：<ol>
<li>调用new_malloc函数时在堆区动态分配内存，同时需要调用delete_free来手动释放申请的内存。</li>
</ol>
</li>
<li>映射区:<ol>
<li>存储动态链接库以及调用mmap函数进行的文件映射</li>
</ol>
</li>
<li>栈：<ol>
<li>使用栈空间存储函数的返回地址、参数、局部变量、返回值</li>
</ol>
</li>
</ol>
<h4 id="函数在main函数执行前先运行"><a href="#函数在main函数执行前先运行" class="headerlink" title="函数在main函数执行前先运行"></a>函数在main函数执行前先运行</h4><ol start="2">
<li>在 .text之前：<strong>data段的内容</strong>:<ol>
<li>全局对象的构造函数会在main 函数之前执行。</li>
<li>一些全局变量、对象和静态变量、对象的空间分配和赋初值就是在执行main函数之前，而main函数执行完后，还要去执行一些诸如释放空间、释放资源使用权等操作</li>
</ol>
</li>
<li>在 .text之前：<strong>.bss段的内容</strong><ol>
<li>进程启动后，要执行一些初始化代码（如设置环境变量等），然后跳转到main执行。全局对象的构造也在main之前。</li>
</ol>
</li>
<li>通过关键字<strong>attribute</strong>，让一个函数在主函数之前运行，进行一些数据初始化、模块加载验证等。</li>
</ol>
<h4 id="Main函数执行之前，主要就是初始化系统相关资源："><a href="#Main函数执行之前，主要就是初始化系统相关资源：" class="headerlink" title="Main函数执行之前，主要就是初始化系统相关资源："></a>Main函数执行之前，主要就是初始化系统相关资源：</h4><p><a href="https://www.jianshu.com/p/4260d859f181" target="_blank" rel="noopener">C语言深度总结全面认识main函数之前运行代码 - 简书</a></p>
<ol>
<li><strong>设置栈指针</strong></li>
<li>在 .text之前：<strong>data段的内容</strong>:<ol>
<li>初始化static静态和global全局变量</li>
</ol>
</li>
<li>在 .text之前：<strong>.bss段的内容</strong><ol>
<li>将未初始化部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等</li>
</ol>
</li>
<li>.text段：<ol>
<li>将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E8%A1%A5%E5%85%85/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiheng Chen‘s blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E8%A1%A5%E5%85%85/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">事件驱动编程模型 == 异步编程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 05:57:00" itemprop="dateCreated datePublished" datetime="2020-04-08T05:57:00+08:00">2020-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 15:41:09" itemprop="dateModified" datetime="2020-06-08T15:41:09+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-c-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-b-linux%E7%B3%BB%E7%BB%9F-%E8%A1%A5%E5%85%85/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/c_计算机系统/b_linux系统/补充</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E8%A1%A5%E5%85%85/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="事件驱动编程模型 == 异步编程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月8日 下午5:57</p>
<h3 id="关键：理解了buffer的作用"><a href="#关键：理解了buffer的作用" class="headerlink" title="关键：理解了buffer的作用"></a>关键：理解了buffer的作用</h3><p>其实就是有一个buffer用作缓存(事件（消息）队列)，当动作发生的时候，我并不执行，而是将它扔到一个buffer里，让另外的处理线程去执行，这个处理线程就会不间断的执行buffer里的任务，<strong>如果当前的动作发生了阻塞</strong>，那么处理线程立刻再把它放到这个buffer中(注册一个回调到事件循环中)，找下一个进行执行，直到buffer为空</p>
<h1 id="事件驱动编程模型"><a href="#事件驱动编程模型" class="headerlink" title="事件驱动编程模型"></a>事件驱动编程模型</h1><p><a href="https://www.cnblogs.com/zingp/p/6863170.html#_labelTop" target="_blank" rel="noopener">IO模式和IO多路复用 - ZingpLiu - 博客园</a></p>
<h3 id="3-1论事件驱动"><a href="#3-1论事件驱动" class="headerlink" title="3.1论事件驱动"></a>3.1论事件驱动</h3><ol>
<li>通常，我们写<strong>服务器处理模型的程序时，有以下几种模型</strong>：<ol>
<li>（1）每收到一个请求，创建一个新的进程，来处理该请求；</li>
<li>（2）每收到一个请求，创建一个新的线程，来处理该请求；</li>
<li>（3）每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求</li>
</ol>
</li>
<li>上面的几种方式，各有千秋：<ol>
<li>第（1）中方法，由于创建新的进程:实现比较简单，但开销比较大，导致服务器性能比较差。</li>
<li>第（2）种方式，由于要涉及到线程的同步，有可能会面临死锁等问题。</li>
<li>第（3）种方式，在写应用程序代码时，逻辑比前面两种都复杂。</li>
</ol>
</li>
<li>综合考虑各方面因素，一般普遍认为<strong>第（3）种方式是大多数网络服务器采用的方式。</strong></li>
</ol>
<h3 id="3-2-看图说话讲事件驱动模型"><a href="#3-2-看图说话讲事件驱动模型" class="headerlink" title="3.2 看图说话讲事件驱动模型"></a>3.2 看图说话讲事件驱动模型</h3><p>在UI编程中，常常要对鼠标点击进行相应，首先如何获得鼠标点击呢？</p>
<ol>
<li><strong>方式一：创建一个线程，该线程一直循环检测是否有鼠标点击，那么这个方式有以下几个缺点</strong>：<ol>
<li>CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？</li>
<li>如果是堵塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘；</li>
<li>如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题；<br>　　所以，该方式是非常不好的。</li>
</ol>
</li>
<li><strong>方式二：就是事件驱动模型</strong><br>目前大部分的UI编程都是事件驱动模型，如很多UI平台都会提供onClick()事件，这个事件就代表鼠标按下事件。事件驱动模型大体思路如下：<ol>
<li>有一个事件（消息）队列；</li>
<li>鼠标按下时，往这个队列中增加一个点击事件（消息）；</li>
<li>有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；</li>
<li>事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；<br><img src="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E8%A1%A5%E5%85%85/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/986023-20170516213233307-426720751.png" alt></li>
</ol>
</li>
<li><strong>事件驱动编程</strong>是一种<strong>网络编程范式</strong>，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。</li>
<li>让我们用例子来比较和对比一下单线程、多线程以及事件驱动编程模型。下图展示了随着时间的推移，这三种模式下程序所做的工作。这个程序有3个任务需要完成，每个任务都在等待I_O操作时阻塞自身。阻塞在I_O操作上所花费的时间已经用灰色框标示出来了。<br><img src="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E8%A1%A5%E5%85%85/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/986023-20170516213325916-254282572.png" alt><ul>
<li>在单线程同步模型中，任务按照顺序执行。如果某个任务因为I/O而阻塞，其他所有的任务都必须等待，直到它完成之后它们才能依次执行。这种明确的执行顺序和串行化处理的行为是很容易推断得出的。如果任务之间并没有互相依赖的关系，但仍然需要互相等待的话这就使得程序不必要的降低了运行速度。</li>
<li>在多线程版本中，这3个任务分别在独立的线程中执行。这些线程由操作系统来管理，在多处理器系统上可以并行处理，或者在单处理器系统上交错执行。这使得当某个线程阻塞在某个资源的同时其他线程得以继续执行。与完成类似功能的同步程序相比，这种方式更有效率，但程序员必须写代码来保护共享资源，防止其被多个线程同时访问。多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题，如果实现不当就会导致出现微妙且令人痛不欲生的bug。</li>
<li>在事件驱动版本的程序中，3个任务交错执行，但仍然在一个单独的线程控制中。当处理I_O或者其他昂贵的操作时，注册一个回调到事件循环中，然后当I_O操作完成时继续执行。回调描述了该如何处理某个事件。事件循环轮询所有的事件，当事件到来时将它们分配给等待处理事件的回调函数。<strong>这种方式让程序尽可能的得以执行而不需要用到额外的线程</strong>。事件驱动型程序比多线程程序更容易推断出行为，因为程序员不需要关心线程安全问题。</li>
</ul>
</li>
<li>当我们面对如下的环境时，事件驱动模型通常是一个好的选择：<ul>
<li>程序中有许多任务，而且…</li>
<li>任务之间高度独立（因此它们不需要互相通信，或者等待彼此）而且…</li>
<li>在等待事件到来时，某些任务会阻塞。</li>
<li>当应用程序需要在任务间共享可变的数据时，这也是一个不错的选择，因为这里不需要采用同步处理。</li>
<li>网络应用程序通常都有上述这些特点，这使得它们能够很好的契合事件驱动编程模型。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E9%9B%B6%E6%95%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiheng Chen‘s blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E9%9B%B6%E6%95%A3/" class="post-title-link" itemprop="url">零散</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 11:30:00" itemprop="dateCreated datePublished" datetime="2020-04-06T11:30:00+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 15:41:08" itemprop="dateModified" datetime="2020-06-08T15:41:08+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-e-%E8%AF%AD%E8%A8%80-c-c/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/e_语言/c_c++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E9%9B%B6%E6%95%A3/" class="post-meta-item leancloud_visitors" data-flag-title="零散" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月6日 下午11:30</p>
<h4 id="strcpy和strlen"><a href="#strcpy和strlen" class="headerlink" title="strcpy和strlen"></a>strcpy和strlen</h4><ol>
<li>Strcpy是字符串拷贝函数，原型：<ol>
<li><code>char *strcpy(char* dest, const char *src);</code></li>
<li>从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。</li>
</ol>
</li>
<li>Strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</li>
</ol>
<h4 id="全局变量和静态全局变量的区别"><a href="#全局变量和静态全局变量的区别" class="headerlink" title="全局变量和静态全局变量的区别"></a>全局变量和静态全局变量的区别</h4><p><img src="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E9%9B%B6%E6%95%A3/33220680_1587611285754_v2-189c3a1df92df112232516471e2917fd_1440w.png" alt></p>
<h4 id="关于int、short-int、long-int、long-long-的区别"><a href="#关于int、short-int、long-int、long-long-的区别" class="headerlink" title="关于int、short int、long int、long long 的区别"></a>关于int、short int、long int、long long 的区别</h4><p><a href="https://blog.csdn.net/u012223913/article/details/51181761" target="_blank" rel="noopener">关于int、short int、long int、long long 的区别_C/C++_Adrianna的专栏-CSDN博客</a></p>
<ol>
<li>在标准中，并没有规定long一定要比int长，也没有规定short要比int短。</li>
<li>标准是这么说的:长整型至少和整型一样长，整型至少和短整型一样长。<ol>
<li>short int  2个字节</li>
<li>int 2/4字节</li>
<li>long 4/8字节</li>
<li>long long 8字节</li>
</ol>
</li>
</ol>
<p>从双刃剑的角度去总结<br><a href="https://blog.csdn.net/lms1008611/article/details/81408236" target="_blank" rel="noopener">C++中类的(static)静态成员变量与(static)静态成员函数_C/C++_年少轻狂，幸福时光-CSDN博客</a><br>static能怎样，不能怎样</p>
<h4 id="typedef-vs-define"><a href="#typedef-vs-define" class="headerlink" title="typedef vs define"></a>typedef vs define</h4><p><a href="https://www.runoob.com/cprogramming/c-typedef.html" target="_blank" rel="noopener">C typedef | 菜鸟教程</a></p>
<ul>
<li><code>#define</code> 是 C 指令，用于为各种数据类型定义别名，与 <strong>typedef</strong> 类似，但是它们有以下几点不同：</li>
<li><strong>typedef</strong> 仅限于为类型定义符号名称，<code>#define</code> 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。</li>
<li><strong>typedef</strong> 是由编译器执行解释的，<code>#define</code>语句是由预编译器进行处理的。</li>
</ul>
<h4 id="i和i-的实现"><a href="#i和i-的实现" class="headerlink" title="++i和i++的实现"></a>++i和i++的实现</h4><ol>
<li>++i 实现：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;  <span class="keyword">int</span>::<span class="keyword">operator</span>++（）</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> +=<span class="number">1</span>；</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>i++ 实现：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="keyword">int</span>::<span class="keyword">operator</span>（<span class="keyword">int</span>）</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> oldValue = *<span class="keyword">this</span>；</span><br><span class="line">	++（*<span class="keyword">this</span>）；</span><br><span class="line">	<span class="keyword">return</span> oldValue；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><a href="https://www.jianshu.com/p/5cb9800b6697" target="_blank" rel="noopener">C++进阶–类型转换，你看我就够了 - 简书</a></p>
<ol>
<li><strong>C++风格的强制转换其他的好处是</strong><ol>
<li>C++中风格是static_cast<type>(content)。C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。 </type></li>
</ol>
</li>
<li>reinterpret_cast：<strong>重解析类型转换</strong><ul>
<li>可以用于任意类型的<strong>指针之间的转换</strong>，对转换的结果不做任何保证</li>
</ul>
</li>
<li>dynamic_cast：<ul>
<li>这种其实也是不被推荐使用的，更多使用static_cast，dynamic本身只能用于存在虚函数的父子关系的强制类型转换，对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常</li>
<li><strong>可以动态的来判断当前对象的真实类型</strong><ul>
<li><a href="https://www.jianshu.com/p/5cb9800b6697" target="_blank" rel="noopener">C++进阶–类型转换，你看我就够了 - 简书</a>代码</li>
</ul>
</li>
</ul>
</li>
<li>const_cast：<ul>
<li>对于未定义const版本的成员函数，我们通常需要使用const_cast来去除const引用对象的const，完成函数调用。</li>
<li>另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。</li>
</ul>
</li>
<li>static_cast：<ul>
<li><strong>能使用隐式转换的地方，均可以使用static_cast转换</strong></li>
<li><strong>如果类型不兼容，使用static_cast编译检查，会报错</strong>，不用等到运行阶段</li>
</ul>
</li>
</ol>
<h4 id="说说你了解的RTTI"><a href="#说说你了解的RTTI" class="headerlink" title="说说你了解的RTTI"></a>说说你了解的RTTI</h4><p>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info</p>
<h4 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h4><ol>
<li><strong>默认的继承访问权</strong>：【继承下】<ol>
<li>class默认的是private,strcut默认的是public。</li>
<li>当然，到底默认是public继承还是private继承，取决于子类而不是基类。意思是，struct可以继承class，同样class也可以继承struct，那么默认的继承访问权限是看子类到底是用的struct还是class。</li>
</ol>
</li>
<li><strong>成员变量默认访问权限</strong>：【非继承下】<ol>
<li>struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</li>
</ol>
</li>
<li>有代码实验：<a href="https://blog.csdn.net/alidada_blog/article/details/83419757" target="_blank" rel="noopener">【C++】struct和class的区别_C/C++_alidada_blog的博客-CSDN博客</a></li>
</ol>
<h4 id="C-中可以定义引用数据成员吗？"><a href="#C-中可以定义引用数据成员吗？" class="headerlink" title="C++中可以定义引用数据成员吗？"></a>C++中可以定义引用数据成员吗？</h4><p><a href="https://blog.csdn.net/lazyq7/article/details/48186291" target="_blank" rel="noopener">C/C++ - 类中成员变量是引用_C/C++_lazyq7的博客-CSDN博客</a></p>
<ol>
<li><strong>所有的引用自带要求</strong>，并不一定是在类中：<ol>
<li>引用在定义时必须初始化，否则编译时便会报错。</li>
</ol>
</li>
<li>根据1，我们可以推得在类中，如何使用引用数据成员：<ol>
<li>构造函数：<ol>
<li>引用类型的成员变量的类，<strong>不能有缺省构造函数</strong></li>
<li>不能直接在构造函数里初始化，<strong>必须用到初始化列表</strong><ol>
<li>默认构造函数没有对引用成员提供默认的初始化机制，也因此造成引用未初始化的编译错误。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B93%EF%BC%9Aconst/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiheng Chen‘s blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B93%EF%BC%9Aconst/" class="post-title-link" itemprop="url">专题知识点3：const</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 11:00:00" itemprop="dateCreated datePublished" datetime="2020-04-06T11:00:00+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 15:41:08" itemprop="dateModified" datetime="2020-06-08T15:41:08+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-e-%E8%AF%AD%E8%A8%80-c-c/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/e_语言/c_c++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B93%EF%BC%9Aconst/" class="post-meta-item leancloud_visitors" data-flag-title="专题知识点3：const" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月6日 下午11:00</p>
<h4 id="以下四行代码的区别是什么？-const-char-arr-“123”-char-brr-“123”-const-char-crr-“123”-char-drr-“123”"><a href="#以下四行代码的区别是什么？-const-char-arr-“123”-char-brr-“123”-const-char-crr-“123”-char-drr-“123”" class="headerlink" title="以下四行代码的区别是什么？ const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”;"></a>以下四行代码的区别是什么？ const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”;</h4><ol>
<li><code>const char * arr = &quot;123”;</code><ul>
<li>字符串123保存在常量区</li>
<li>const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</li>
</ul>
</li>
<li><code>char * brr = &quot;123&quot;;</code><ul>
<li>字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改”123”的值</li>
</ul>
</li>
<li><code>const char crr[] = “123”;</code><ul>
<li>这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</li>
</ul>
</li>
<li><code>char drr[] = “123”;</code><ul>
<li>字符串123保存在栈区，可以通过drr去修改</li>
</ul>
</li>
</ol>
<h4 id="Const-修饰指针变量有以下三种情况"><a href="#Const-修饰指针变量有以下三种情况" class="headerlink" title="Const 修饰指针变量有以下三种情况"></a>Const 修饰指针变量有以下三种情况</h4><ul>
<li>A: const 修饰指针指向的内容，则内容为不可变量。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//则指针指向的内容 8 不可改变。简称左定值，因为 const 位于 * 号的左边。</span></span><br></pre></td></tr></table></figure></li>
<li>B: const 修饰指针，则指针为不可变量。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">*p = <span class="number">9</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">int</span>  b = <span class="number">7</span>;</span><br><span class="line">P = &amp;b; <span class="comment">// 错误</span></span><br><span class="line"><span class="comment">//对于 const 指针 p 其指向的内存地址不能够被改变，但其内容可以改变。简称，右定向。因为 const 位于 * 号的右边。</span></span><br></pre></td></tr></table></figure></li>
<li>C: const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span>  p = &amp;a;</span><br><span class="line"><span class="comment">//这时，const p 的指向的内容和指向的内存地址都已固定，不可改变。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>C++里是怎么定义常量的？常量存放在内存的哪个位置？</h4><ol>
<li><a href="https://www.runoob.com/cplusplus/cpp-constants-literals.html" target="_blank" rel="noopener">C++ 常量 | 菜鸟教程</a><ol>
<li>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做<strong>字面量</strong>。</li>
<li>常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。</li>
<li>常量就像是常规的变量，只不过常量的值在定义后不能进行修改。</li>
</ol>
</li>
<li>在 C++ 中，有两种简单的定义常量的方式：<ol>
<li>使用 <strong>#define</strong> 预处理器。</li>
<li>使用 <strong>const</strong> 关键字。</li>
</ol>
</li>
<li>常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。<ol>
<li>对于局部对象，常量存放在栈区</li>
<li>对于全局对象，常量存放在全局/静态存储区。</li>
<li>对于字面值常量，常量存放在常量存储区。</li>
</ol>
</li>
<li><strong>代码段</strong>:<ol>
<li><strong>包括只读存储区和文本区</strong>，其中只读存储区存储字符串常量(const就存在这里)，文本区存储程序的机器代码。</li>
</ol>
</li>
<li><a href="https://blog.csdn.net/duan19920101/article/details/50989431" target="_blank" rel="noopener">C++内存分配方式详解(堆、栈、自由存储区、全局/静态存储区和常量存储区)_C/C++_那年聪聪-CSDN博客</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  a=<span class="number">0</span>;   全局初始化区 .data   </span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p1;   全局未初始化区 .bss  </span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">int</span>  b; <span class="comment">//栈    </span></span><br><span class="line">  <span class="keyword">char</span>  s[]=<span class="string">"abc"</span>; <span class="comment">//栈    </span></span><br><span class="line">  <span class="keyword">char</span>  *p2; <span class="comment">//栈    </span></span><br><span class="line">  <span class="keyword">char</span>  *p3=<span class="string">"123456"</span>; <span class="comment">//123456/0在常量区 .text中的_const，p3在栈上。    </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>；<span class="comment">//全局（静态）初始化区  .data  </span></span><br><span class="line">  p1 =  (<span class="keyword">char</span>  *)<span class="built_in">malloc</span>(<span class="number">10</span>);  <span class="comment">//分配得来得10和20字节的区域就在堆区</span></span><br><span class="line">  p2  = (<span class="keyword">char</span>  *)<span class="built_in">malloc</span>(<span class="number">20</span>);       </span><br><span class="line">  <span class="built_in">strcpy</span>(p3,<span class="string">"123456"</span>); <span class="comment">//123456/0放在常量区，编译器可能会将它与p3所指向的"123456"  优化成一个地方。    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>堆和栈究竟有什么区别？<ol>
<li><a href="https://blog.csdn.net/duan19920101/article/details/50989431" target="_blank" rel="noopener">C++内存分配方式详解(堆、栈、自由存储区、全局/静态存储区和常量存储区)_C/C++_那年聪聪-CSDN博客</a></li>
</ol>
</li>
</ol>
<h4 id="Const修饰成员函数的目的是什么？"><a href="#Const修饰成员函数的目的是什么？" class="headerlink" title="Const修饰成员函数的目的是什么？"></a>Const修饰成员函数的目的是什么？</h4><p>Const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。</p>
<h4 id="同时定义了两个函数，一个带const，一个不带，会有问题吗？"><a href="#同时定义了两个函数，一个带const，一个不带，会有问题吗？" class="headerlink" title="同时定义了两个函数，一个带const，一个不带，会有问题吗？"></a>同时定义了两个函数，一个带const，一个不带，会有问题吗？</h4><ol>
<li>不会，这相当于函数的重载。</li>
<li>原因是：<ol>
<li>按照函数重载的定义，函数名相同而形参表有本质不同的函数称为重载。在类中，由于隐含的this形参的存在，<strong>const版本的function函数使得作为形参的this指针的类型变为指向const对象的指针</strong>，而非const版本的使得作为形参的this指针就是正常版本的指针。</li>
<li>此处是发生重载的本质。重载函数在最佳匹配过程中，对于const对象调用的就选取const版本的成员函数，而普通的对象调用就选取非const版本的成员函数。</li>
</ol>
</li>
<li>（注：this指针是一个const指针，地址不能改，但能改变其指向的对象或者变量）</li>
<li><a href="https://blog.csdn.net/guiyinzhou/article/details/6307754" target="_blank" rel="noopener">C++ 学习之函数重载、基于const的重载_C/C++_guiyinzhou的专栏-CSDN博客</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%864%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiheng Chen‘s blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%864%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">专题知识4：函数调用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 10:49:00" itemprop="dateCreated datePublished" datetime="2020-04-06T10:49:00+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 15:40:55" itemprop="dateModified" datetime="2020-06-08T15:40:55+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-e-%E8%AF%AD%E8%A8%80-c-c/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/e_语言/c_c++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%864%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" class="post-meta-item leancloud_visitors" data-flag-title="专题知识4：函数调用" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>121</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月6日 下午10:49</p>
<h4 id="C语言是怎么进行函数调用的？"><a href="#C语言是怎么进行函数调用的？" class="headerlink" title="C语言是怎么进行函数调用的？"></a>C语言是怎么进行函数调用的？</h4><p><a href="bear://x-callback-url/open-note?id=368E9E82-DAFC-435D-BB53-B2E6B57AECAF-14547-0001419E213E6D19">C++栈调用过程：C++自带功能</a></p>
<h4 id="C-函数栈空间的最大值"><a href="#C-函数栈空间的最大值" class="headerlink" title="C++函数栈空间的最大值"></a>C++函数栈空间的最大值</h4><p>默认是1M，不过可以调整</p>
<h4 id="C语言参数压栈顺序？"><a href="#C语言参数压栈顺序？" class="headerlink" title="C语言参数压栈顺序？"></a>C语言参数压栈顺序？</h4><p>从右到左</p>
<h4 id="C-如何处理返回值？"><a href="#C-如何处理返回值？" class="headerlink" title="C++如何处理返回值？"></a>C++如何处理返回值？</h4><p>生成一个临时变量，把它的引用作为函数参数传入函数内。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/119/">119</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhiheng Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1188</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhiheng Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">18:52</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        






  <script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.getAttribute('data-flag-title');

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=QiM1vjQ7SAoirKD4qY57L82O-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id'     : 'QiM1vjQ7SAoirKD4qY57L82O-gzGzoHsz',
            'X-LC-Key'    : 'aOHhzmfDblK0HGWUqEyb6ra2',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
