<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenzhiheng.cn","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="陈志恒的技术博客">
<meta property="og:url" content="http://chenzhiheng.cn/page/8/index.html">
<meta property="og:site_name" content="陈志恒的技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhiheng Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://chenzhiheng.cn/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>陈志恒的技术博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6bc779d0e3be483fc01e871fbb7cef3d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">陈志恒的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B92%EF%BC%9A%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8(%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E5%A4%9A%E6%80%81%E3%80%81%E9%87%8D%E5%86%99)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B92%EF%BC%9A%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8(%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E5%A4%9A%E6%80%81%E3%80%81%E9%87%8D%E5%86%99)/" class="post-title-link" itemprop="url">专题知识点2：虚函数表(虚函数、析构函数、多态、重写)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 10:34:00" itemprop="dateCreated datePublished" datetime="2020-04-06T10:34:00+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 15:41:08" itemprop="dateModified" datetime="2020-06-08T15:41:08+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-e-%E8%AF%AD%E8%A8%80-c-c/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/e_语言/c_c++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B92%EF%BC%9A%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8(%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E5%A4%9A%E6%80%81%E3%80%81%E9%87%8D%E5%86%99)/" class="post-meta-item leancloud_visitors" data-flag-title="专题知识点2：虚函数表(虚函数、析构函数、多态、重写)" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月6日 下午10:34</p>
<h4 id="为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数"><a href="#为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数" class="headerlink" title="为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数"></a>为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</h4><ol>
<li>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后<strong>使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏</strong>。</li>
<li>C++默认的析构函数不是虚函数是因为虚函数需要额外的<strong>虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</li>
</ol>
<h4 id="C-中析构函数的作用"><a href="#C-中析构函数的作用" class="headerlink" title="C++中析构函数的作用"></a>C++中析构函数的作用</h4><ol>
<li>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</li>
<li>析构函数名也应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</li>
<li>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</li>
<li>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</li>
<li>类析构顺序：<ol>
<li>1）派生类本身的析构函数；</li>
<li>2）对象成员析构函数；</li>
<li>3）基类析构函数。</li>
</ol>
</li>
</ol>
<h4 id="静态函数和虚函数的区别"><a href="#静态函数和虚函数的区别" class="headerlink" title="静态函数和虚函数的区别"></a>静态函数和虚函数的区别</h4><ol>
<li>静态函数在编译的时候就已经确定运行时机</li>
<li>虚函数在运行的时候动态绑定。虚函数因为用了<strong>虚函数表机制</strong>，调用的时候会增加一次内存开销</li>
</ol>
<h4 id="C-中static关键字的作用"><a href="#C-中static关键字的作用" class="headerlink" title="C++中static关键字的作用"></a>C++中static关键字的作用</h4><ol>
<li>代码块外部：对于函数定义和代码块之外的<strong>变量声明</strong><ol>
<li>static修改标识符的链接属性，由默认的external变为internal</li>
<li>作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。</li>
</ol>
</li>
<li>代码块内部：对于代码块内部的<strong>变量声明</strong><ol>
<li>static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。</li>
<li>这种变量在程序执行之前就创建，在程序执行的整个周期都存在。</li>
</ol>
</li>
<li>函数：对于被static修饰的<strong>普通函数</strong><ol>
<li>其只能在定义它的源文件中使用，不能在其他源文件中被引用</li>
</ol>
</li>
<li>类：对于被static修饰的<strong>类成员变量和成员函数</strong><ol>
<li>它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。</li>
</ol>
</li>
</ol>
<h4 id="虚函数和多态"><a href="#虚函数和多态" class="headerlink" title="虚函数和多态"></a>虚函数和多态</h4><ol>
<li>多态的实现主要分为静态多态和动态多态<ol>
<li>静态多态主要是重载，在编译的时候就已经确定；</li>
<li>动态多态是用虚函数机制实现的，在运行期间动态绑定。</li>
<li>举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。</li>
</ol>
</li>
<li><strong>虚函数的实现</strong>：<ol>
<li>::在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。::</li>
<li>如果<strong>在基类中使用vitual虚函数</strong>，::那么编译器看的是指针的内容，而不是它的类型::。 <a href="bear://x-callback-url/open-note?id=76FE359B-D849-4A4E-A33E-6B0753651837-10863-0001CB16F6A2DE3C">C++ 多态 ：一起看1</a></li>
</ol>
</li>
</ol>
<h4 id="多态机制深入："><a href="#多态机制深入：" class="headerlink" title="多态机制深入："></a>多态机制深入：</h4><p><a href="https://blog.csdn.net/sinat_20265495/article/details/50112311" target="_blank" rel="noopener">C++多态的实现方式总结_c/c++_小凡的专栏-CSDN博客</a><br>虚函数在C++中的实现机制就是用虚表和虚指针。也就是每个类用了一个虚表，每个类的对象用了一个虚指针。具体的用法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;<span class="comment">//A、B实现省略</span></span><br></pre></td></tr></table></figure>
<ol>
<li>因为A有virtual void f（）和g（），所以编译器为A类准备了一个虚表vtableA，内容如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A::f 的地址</span><br><span class="line">A::g 的地址</span><br></pre></td></tr></table></figure></li>
<li>B因为继承了A，所以编译器也为B准备了一个虚表vtableB，内容如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A::f 的地址</span><br><span class="line">B::g 的地址</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：因为B: :ｇ是重写了的，所以B的虚表的g放的是B: :g的入口地址，但是f是从上面的A继承下来的，所以f的地址是A::f的入口地址。</li>
</ul>
</li>
</ol>
<ul>
<li>然后某处有语句 B bB;的时候，编译器分配空间时，除了A的int a，B的成员int b；以外，还分配了一个虚指针vptr，指向B的虚表vtableB，bB的布局如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vptr ： 指向B的虚表vtableB</span><br><span class="line">int a： 继承A的成员</span><br><span class="line">int b： B成员</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="重载-重写"><a href="#重载-重写" class="headerlink" title="重载 重写"></a>重载 重写</h4><ol>
<li>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中</li>
<li>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B91%EF%BC%9A%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B91%EF%BC%9A%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">专题知识点1：指针专题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 09:14:00" itemprop="dateCreated datePublished" datetime="2020-04-06T09:14:00+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 15:41:08" itemprop="dateModified" datetime="2020-06-08T15:41:08+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-e-%E8%AF%AD%E8%A8%80-c-c/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/e_语言/c_c++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/c_c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B91%EF%BC%9A%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/" class="post-meta-item leancloud_visitors" data-flag-title="专题知识点1：指针专题" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月6日 下午9:14</p>
<h4 id="C-C-中指针和引用的区别？"><a href="#C-C-中指针和引用的区别？" class="headerlink" title="C/C++ 中指针和引用的区别？"></a>C/C++ 中指针和引用的区别？</h4><ol>
<li><a href="https://www.zhihu.com/question/37608201/answer/72766337" target="_blank" rel="noopener">c++中，引用和指针的区别是什么？ - 知乎</a><ol>
<li>从对象的角度来解释：<ol>
<li>从对象开始讲起：<ol>
<li><strong>对象</strong>是指一块能存储数据并具有某种类型的内存空间</li>
<li>一个<strong>对象</strong>a，它有<strong>值</strong>和<strong>地址&amp;a</strong></li>
</ol>
</li>
<li><strong>指针</strong>p也是<strong>对象</strong><ol>
<li>它同样有地址&amp;p和存储的值p，只不过，<strong>p存储的数据类型是数据的地址</strong>。</li>
</ol>
</li>
<li>对象有常量（const）和变量之分<ol>
<li>指针常量是指，指针这个对象所存储的地址是不可以改变的</li>
<li>而指向常量的指针的意思是，不能通过该指针来改变这个指针所指向的对象。</li>
</ol>
</li>
</ol>
</li>
<li>从常量指针引出到引用：<ol>
<li>可以把引用看做是通过一个常量指针来实现的，它只能绑定到初始化它的对象上</li>
</ol>
</li>
<li>如何选择：<ol>
<li>引用的一个优点是它一定不为空，因此相对于指针，它不用检查它所指对象是否为空，这增加了效率</li>
</ol>
</li>
</ol>
</li>
<li>散乱版本，根本记不住：<ol>
<li><strong>指针有自己的一块空间，是一种类型</strong>，而<strong>引用只是一个别名</strong>；</li>
<li>初始化：<ol>
<li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</li>
</ol>
</li>
<li>赋值：<ol>
<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</li>
<li><a href="https://blog.csdn.net/liujianfei526/article/details/47041433?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">C++中引用不能重新赋值的理解_c/c++_liujianfei526的专栏-CSDN博客</a></li>
</ol>
</li>
<li>参数传递：<ol>
<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</li>
</ol>
</li>
<li>sizeof :<ol>
<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li>
</ol>
</li>
<li>const:<ol>
<li>可以有const指针</li>
<li><strong>const引用和非const引用</strong><ol>
<li>const引用是必须指向const对象的引用</li>
</ol>
</li>
</ol>
</li>
<li>指针可以有多级指针（p），而引用至于一级；</li>
<li>指针和引用使用++运算符的意义不一样；</li>
<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li>
</ol>
</li>
</ol>
<h4 id="c-中的smart-pointer四个智能指针：-shared-ptr-unique-ptr-weak-ptr-auto-ptr"><a href="#c-中的smart-pointer四个智能指针：-shared-ptr-unique-ptr-weak-ptr-auto-ptr" class="headerlink" title="c++中的smart pointer四个智能指针： shared_ptr,unique_ptr,weak_ptr,auto_ptr"></a>c++中的smart pointer四个智能指针： shared_ptr,unique_ptr,weak_ptr,auto_ptr</h4><ol>
<li>C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。</li>
<li><strong>为什么要使用智能指针：</strong><ol>
<li>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</li>
</ol>
</li>
<li>auto_ptr（c++98的方案，cpp11已经抛弃）<ol>
<li>采用所有权模式。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt; <span class="built_in">string</span>&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (“I reigned lonely as a cloud.”))</span></span>;</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; p2;</span><br><span class="line">p2 = p1; <span class="comment">//auto_ptr不会报错.</span></span><br></pre></td></tr></table></figure></li>
<li>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</li>
</ol>
</li>
<li>unique_ptr（替换auto_ptr）<ol>
<li>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</li>
<li>采用所有权模式，还是上面那个例子<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (“<span class="keyword">auto</span>”))</span></span>;   <span class="comment">//#4</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4；                       <span class="comment">//#5</span></span><br><span class="line">P4 = p3;<span class="comment">//此时会报错！！</span></span><br></pre></td></tr></table></figure></li>
<li>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</li>
<li>另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (“hello world”))</span></span>;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (“You”));   <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure></li>
<li>其中# 1留下悬挂的unique_ptr(pu1)，这可能导致危害。而 # 2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</li>
<li>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(“hello”);</span><br><span class="line">ps2 = <span class="built_in">move</span>(ps1);</span><br><span class="line">ps1 = demo(“Alexia”);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>shared_ptr<ol>
<li>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。<strong>从名字share就可以看出了资源可以被多个指针共享</strong>，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</li>
<li><strong>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的),</strong> 在使用引用计数的机制上提供了可以共享所有权的智能指针。</li>
<li>成员函数：<ol>
<li>use_count 返回引用计数的个数</li>
<li>unique 返回是否是独占所有权( use_count 为 1)</li>
<li>Swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</li>
<li>Reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</li>
<li>Get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</int></li>
</ol>
</li>
</ol>
</li>
<li>weak_ptr<ol>
<li>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. </li>
<li><strong>weak_ptr只是提供了对管理对象的一个访问手段</strong>。</li>
<li>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</li>
<li>weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。<strong>它是对对象的一种弱引用，不会增加对象的引用计数</strong>，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">	~A()</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;“A <span class="keyword">delete</span>\n”;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">	~B()</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;“B <span class="keyword">delete</span>\n<span class="string">";</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void fun()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	shared_ptr&lt;B&gt; pb(new B());</span></span><br><span class="line"><span class="string">	shared_ptr&lt;A&gt; pa(new A());</span></span><br><span class="line"><span class="string">	pb-&gt;pa_ = pa;</span></span><br><span class="line"><span class="string">	pa-&gt;pb_ = pb;</span></span><br><span class="line"><span class="string">	cout&lt;&lt;pb.use_count()&lt;&lt;endl;</span></span><br><span class="line"><span class="string">	cout&lt;&lt;pa.use_count()&lt;&lt;endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	fun();</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，<strong>当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1</strong>，导致跳出函数时资源没有被释放（A B的析构函数没有被调用）</li>
<li>如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</li>
<li><strong>注意的是我们不能通过weak_ptr直接访问对象的方法</strong>，比如B对象中有一个方法print(),我们不能这样访问，<code>pa-&gt;pb_-&gt;print();</code>英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：<code>shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();</code></li>
</ol>
</li>
</ol>
<h4 id="智能指针的内存泄漏如何解决"><a href="#智能指针的内存泄漏如何解决" class="headerlink" title="智能指针的内存泄漏如何解决"></a>智能指针的内存泄漏如何解决</h4><ol>
<li>智能指针的内存泄露是指？<ol>
<li>shared_ptr的循环引用</li>
</ol>
</li>
<li>为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针<ol>
<li>weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</li>
</ol>
</li>
</ol>
<h4 id="野指针是什么？"><a href="#野指针是什么？" class="headerlink" title="野指针是什么？"></a>野指针是什么？</h4><ul>
<li>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</li>
</ul>
<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><ol>
<li>定义<ol>
<li>函数指针是指向函数的指针变量。</li>
<li>函数指针本身首先是一个<strong>指针变量</strong>，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。</li>
<li><strong>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址</strong>。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</li>
</ol>
</li>
<li>用途：<ol>
<li>调用函数和做函数的参数，比如回调函数。</li>
</ol>
</li>
<li>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char * fun(char * p)  &#123;…&#125;       &#x2F;&#x2F; 函数fun</span><br><span class="line">char * (*pf)(char * p);             &#x2F;&#x2F; 函数指针pf</span><br><span class="line">pf &#x3D; fun;                        &#x2F;&#x2F; 函数指针pf指向函数fun</span><br><span class="line">pf(p);                        &#x2F;&#x2F; 通过函数指针pf调用函数fun</span><br></pre></td></tr></table></figure>

</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">将操作系统分解，看看这个庞大的系统中包含哪些子系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-05 10:56:00" itemprop="dateCreated datePublished" datetime="2020-04-05T10:56:00+08:00">2020-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 15:41:08" itemprop="dateModified" datetime="2020-06-08T15:41:08+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-c-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-b-linux%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/c_计算机系统/b_linux系统/系统</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="post-meta-item leancloud_visitors" data-flag-title="将操作系统分解，看看这个庞大的系统中包含哪些子系统" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月5日 上午10:56</p>
<h3 id="作为软件工程出身的人，我从子系统分解的角度，将操作系统分解，看看这个庞大的系统中包含哪些子系统"><a href="#作为软件工程出身的人，我从子系统分解的角度，将操作系统分解，看看这个庞大的系统中包含哪些子系统" class="headerlink" title="作为软件工程出身的人，我从子系统分解的角度，将操作系统分解，看看这个庞大的系统中包含哪些子系统"></a>作为软件工程出身的人，我从子系统分解的角度，将操作系统分解，看看这个庞大的系统中包含哪些子系统</h3><ol>
<li>项目管理子系统(泛指)<br><img src="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/1c91956b52574b62a4418a7c6993d8bc.jpeg" alt><ol start="2">
<li>项目应该有运行中的状态<ol>
<li>TASK_RUNNING 并不是说进程正在运行，而是表示进程在时刻准备运行的状态。这个时候，要看 CPU 小伙伴有没有空，有空就运行他，没空就得等着。</li>
<li>有时候，进程运行到一半，需要等待某个条件才能运行下去，这个时候只能睡眠。睡眠状态有两种。一种是 TASK_INTERRUPTIBLE，可中断的睡眠状态。这是一种浅睡眠的状态，也就是说，虽然在睡眠，等条件成熟，进程可以被唤醒。</li>
<li>另一种睡眠是 TASK_UNINTERRUPTIBLE，不可中断的睡眠状态。这是一种深度睡眠状态，不可被唤醒，只能死等条件满足。有了一种新的进程睡眠状态，TASK_KILLABLE，可以终止的新睡眠状态。进程处于这种状态中，他的运行原理类似 TASK_UNINTERRUPTIBLE，只不过可以响应致命信号，也即虽然在深度睡眠，但是可以被干掉。</li>
<li>一旦一个进程要结束，先进入的是 EXIT_ZOMBIE 状态，但是这个时候他的父进程还没有使用 wait() 等系统调用来获知他的终止信息，此时进程就成了僵尸进程。<br><img src="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/e2fa348c67ce41ef730048ff9ca4c988.jpeg" alt></li>
</ol>
</li>
</ol>
</li>
<li>权限管理子系统</li>
<li>（编译子系统）<ol>
<li>不属于操作系统的一部分</li>
<li>编译其实是一个需求分析和需求转换的过程</li>
<li>最后生成ELF 格式的项目执行计划书，这个项目执行计划书有总论 ELF Header 的部分，有包含指令的代码段的部分，有包含全局变量的数据段的部分</li>
<li>“你看，每次你接一个项目，总要写成项目执行计划书，CPU 小伙伴们才能执行吧，项目计划书中的一行一行指令运行过程中，免不了要产生一些数据。这些数据要保存在一个地方，这个地方就是会议室（内存）。会议室（内存）被分成一块一块儿的，都编好了号。例如 3F-10，就是三楼十号会议室。这个地址是实实在在的地址，通过这个地址我们就能够定位到物理内存的位置。”</li>
</ol>
</li>
<li>任务管理子系统(专指内核态)<ol>
<li>在 Linux 里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务，由一个统一的结构 task_struct 进行管理。<br><img src="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/75c4d28a9d2daa4acc1107832be84e2d.jpeg" alt></li>
</ol>
</li>
<li>任务调度子系统<ol>
<li>调度要解决的第一个问题是，每一个 CPU 小伙伴每过一段时间，都要想一下，白板上这么多项目，我应该干哪一个？CPU 的队列里面有这么多的进程或者线程，应该取出哪一个来执行？<br><img src="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/10381dbafe0f78d80beb87560a9506af.jpeg" alt></li>
<li>调度要解决的第二个问题是，什么时候切换任务？也即，什么时候，CPU 小伙伴应该停下一个进程，换另一个进程运行？</li>
</ol>
</li>
<li>内存管理子系统<ol>
<li>第一，物理内存的管理，相当于会议室管理员管理会议室；<ol>
<li>对物理内存的管理系统，我们称为伙伴系统<br><img src="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/3fa8123990e5ae2c86859f70a8351f4f.jpeg" alt></li>
</ol>
</li>
<li>第二，虚拟地址的管理，也即在项目组的视角，会议室的虚拟地址应该如何组织；<ol>
<li>有了虚拟地址的管理这个规定以后，项目执行计划书ELF要写入数据的时候，就需要符合里面的规定了，数据不能随便乱放了。规定具体如下：</li>
<li>首先，这么大的虚拟空间一切二，一部分用来放内核的东西，称为内核空间；一部分用来放进程的东西，称为用户空间。</li>
<li>用户空间：<ol>
<li>我们从最低位开始排起，先是 Text Segment、Data Segment 和 BSS Segment。Text Segment 是存放二进制可执行代码的位置，Data Segment 存放静态常量，BSS Segment 存放未初始化的静态变量。这些都是在项目执行计划书里面有的。</li>
<li>接下来是堆段。堆是往高地址增长的，是用来动态分配内存的区域，malloc 就是在这里面分配的。</li>
<li>接下来的区域是 Memory Mapping Segment。这块地址可以用来把文件映射进内存用的，如果二进制的执行文件依赖于某个动态链接库，就是在这个区域里面将 so 文件映射到了内存中。</li>
<li>再下面就是栈地址段了，主线程的函数调用的函数栈就是用这里的。</li>
</ol>
</li>
<li>如果需要进行更高权限的工作，就需要调用系统调用，进入内核。<ol>
<li>到了内核里面，无论是从哪个进程进来的，看到的是同一个内核空间，看到的是同一个进程列表。</li>
<li>虽然内核栈是各用各的，但是如果想知道的话，还是能够知道每个进程的内核栈在哪里的。所以，如果要访问一些公共的数据结构，需要进行锁保护。</li>
<li>内核的代码访问内核的数据结构，大部分的情况下都是使用虚拟地址的。</li>
<li>虽然内核代码权限很大，但是能够使用的虚拟地址范围也只能在内核空间，也即内核代码访问内核数据结构</li>
<li>在内核里面也会有内核的代码，同样有 Text Segment、Data Segment 和 BSS Segment，内核代码也是 ELF 格式的。</li>
</ol>
</li>
</ol>
</li>
<li>第三，虚拟地址和物理地址如何映射的问题，也即会议室管理员如果管理映射表。<ol>
<li>两级：<ol>
<li>虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址。</li>
<li>32 位环境下，虚拟地址空间共 4GB。如果分成 4KB 一个页，那就是 1M 个页。每个页表项需要 4 个字节来存储，那么整个 4GB 空间的映射就需要 4MB 的内存来存储映射表。如果每个进程都有自己的映射表，100 个进程就需要 400MB 的内存。对于内核来讲，有点大了 。</li>
</ol>
</li>
<li>三级：32位<ol>
<li>页目录有 1K 项，<strong>用 10 位就可以表示访问页目录的哪一项</strong>。这一项其实对应的是一整页的页表项，也即 4K 的页表项。每个页表项也是 4 个字节，因而一整页的页表项是 1k 个。<strong>再用 10 位就可以表示访问页表项的哪一项</strong>，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是 4K，<strong>用 12 位可以定位这个页内的任何一个位置</strong>。<br><img src="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/b6960eb0a7eea008d33f8e0c4facc8b8.jpg" alt></li>
</ol>
</li>
<li>四级：64位</li>
</ol>
</li>
</ol>
</li>
<li>文件管理系统<ol>
<li>第一点，文件系统要有严格的组织形式，使得文件能够以块为单位进行存储。</li>
<li>第二点，文件系统中也要有索引区，用来方便查找一个文件分成的多个块都存放在了什么位置。</li>
<li>第三点，如果文件系统中有的文件是热点文件，近期经常被读取和写入，文件系统应该有缓存层。</li>
<li>第四点，文件应该用文件夹的形式组织起来，方便管理和查询。</li>
<li>第五点，Linux 内核要在自己的内存里面维护一套数据结构，来保存哪些文件被哪些进程打开和使用。<ol>
<li>对于每一个进程，打开的文件都有一个文件描述符。files_struct 里面会有文件描述符数组。每个一个文件描述符是这个数组的下标，里面的内容指向一个 struct file 结构，表示打开的文件。这个结构里面有这个文件对应的 inode，最重要的是这个文件对应的操作 file_operation。如果操作这个文件，就看这个 file_operation 里面的定义了。</li>
</ol>
</li>
</ol>
</li>
<li>输入和输出系统子系统<ol>
<li>（设备控制管理子系统）<ol>
<li>第一层，用设备控制器屏蔽设备差异。</li>
<li>这里需要注意的是，设备控制器不属于操作系统的一部分，但是设备驱动程序属于操作系统的一部分。</li>
<li>操作系统的内核代码可以像调用本地代码一样调用驱动程序的代码，而驱动程序的代码需要发出特殊的面向设备控制器的指令，才能操作设备控制器。</li>
</ol>
</li>
<li>设备驱动管理子系统<ol>
<li>第二层，用驱动程序屏蔽设备控制器差异。</li>
</ol>
</li>
<li>接受外部信息(中断)管理子系统<ol>
<li>第三，用中断控制器统一外部事件处理。</li>
</ol>
</li>
<li>对外输出信息管理子系统(在文件子系统中集成)<ol>
<li>第四，用文件系统接口屏蔽驱动程序的差异。</li>
</ol>
</li>
<li>一般的流程是，一个设备驱动程序初始化的时候，要先注册一个该设备的中断处理函数。咱们讲进程切换的时候说过，中断返回的那一刻是进程切换的时机。中断的时候，触发的函数是 do_IRQ。这个函数是中断处理的统一入口。在这个函数里面，我们可以找到设备驱动程序注册的中断处理函数 Handler，然后执行他进行中断处理。<br><img src="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/b_linux%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/aa9d074d9819f0eb513e11014a5772c0.jpg" alt></li>
</ol>
</li>
<li>异常处理子系统<ol>
<li>信号可以在任何时候发送给某一进程，进程需要为这个信号配置信号处理函数。当某个信号发生的时候，就默认执行这个函数就可以了。</li>
</ol>
</li>
<li>网络子系统：<ol>
<li>操作系统对于网络协议的实现模式是这样的：<ol>
<li>二到四层的处理代码在内核里面，七层的处理代码让应用自己去做。两者需要跨内核态和用户态通信，就需要一个系统调用完成这个衔接，这就是 Socket。<strong>应用层和内核互通的机制，就是通过 Socket 系统调用</strong></li>
</ol>
</li>
<li>整个网络过程：<ol>
<li>如果公司想要和其他公司沟通，我们将请求封装为 HTTP 协议，通过 Socket 发送到内核。内核的网络协议栈里面，在 TCP 层创建用于维护连接、序列号、重传、拥塞控制的数据结构，将 HTTP 包加上 TCP 头，发送给 IP 层，IP 层加上 IP 头，发送给 MAC 层，MAC 层加上 MAC 头，从硬件网卡发出去。</li>
<li>最终网络包会被转发到目标服务器，它发现 MAC 地址匹配，就将 MAC 头取下来，交给上一层。IP 层发现 IP 地址匹配，将 IP 头取下来，交给上一层。TCP 层会根据 TCP 头中的序列号等信息，发现它是一个正确的网络包，就会将网络包缓存起来，等待应用层的读取。</li>
<li>应用层通过 Socket 监听某个端口，因而读取的时候，内核会根据 TCP 头中的端口号，将网络包发给相应的应用。</li>
</ol>
</li>
</ol>
</li>
<li>虚拟化子系统：<ol>
<li>第一种方式，完全虚拟化。<ol>
<li>其实说白了，这是一种“骗人”的方式。虚拟化软件会模拟假的 CPU、内存、网络、硬盘给到虚拟机，让虚拟机里面的内核自我感觉良好，感觉他终于又像个内核了。在 Linux 上，一个叫作 qemu 的工具可以做到这一点。</li>
<li>qemu 向虚拟机里面的客户机操作系统模拟 CPU 和其他的硬件，骗客户机，GuestOS 认为自己和硬件直接打交道，其实是同 qemu 模拟出来的硬件打交道，qemu 会将这些指令转译给真正的硬件。由于所有的指令都要从 qemu 里面过一手，因而性能就会比较差。</li>
</ol>
</li>
<li>第二种方式，硬件辅助虚拟化<ol>
<li>可以使用硬件 CPU 的 Intel-VT 和 AMD-V 技术，需要 CPU 硬件开启这个标志位（一般在 BIOS 里面设置）。当确认开始了标志位之后，通过内核模块 KVM，GuestOS 的 CPU 指令将不用经过 Qemu 转译，直接运行，大大提高了速度。qemu 和 KVM 融合以后，就是 qemu-kvm。</li>
</ol>
</li>
<li>第三种方式称为半虚拟化<ol>
<li>对于网络或者硬盘的访问，我们让虚拟机内核加载特殊的驱动，重新定位自己的身份。虚拟机操作系统的内核知道自己不是物理机内核，没那么高的权限。他很可能要和很多虚拟机共享物理资源，所以学会了排队。虚拟机写硬盘其实写的是一个物理机上的文件，那我的写文件的缓存方式是不是可以变一下。我发送网络包，根本就不是发给真正的网络设备，而是给虚拟的设备，我可不可以直接在内存里面拷贝给它，等等等等。</li>
<li>网络半虚拟化方式是 virtio_net，存储是 virtio_blk。客户机需要安装这些半虚拟化驱动。客户机内核知道自己是虚拟机，所以会直接把数据发送给半虚拟化设备，然后经过特殊处理（例如排队、缓存、批量处理等性能优化方式），最终发送给真正的硬件。这在一定程度上提高了性能。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="一个子系统：系统都是服务行业，被别人调用的"><a href="#一个子系统：系统都是服务行业，被别人调用的" class="headerlink" title="一个子系统：系统都是服务行业，被别人调用的"></a>一个子系统：系统都是服务行业，被别人调用的</h4><ul>
<li>系统结构：有哪些组成部分，各个部分之间的关系</li>
<li>系统运转流程图：这个过程中可能会涉及到不同的数据结构算法</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/04/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/czh_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2/pytorch%E6%A8%A1%E5%9E%8B%E5%A6%82%E4%BD%95%E7%94%A8C++%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/04/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/czh_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2/pytorch%E6%A8%A1%E5%9E%8B%E5%A6%82%E4%BD%95%E7%94%A8C++%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">pytorch模型如何用C++进行加载</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-04 12:13:00" itemprop="dateCreated datePublished" datetime="2020-04-04T12:13:00+08:00">2020-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 19:31:53" itemprop="dateModified" datetime="2020-04-12T19:31:53+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-czh-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2/" itemprop="url" rel="index">
                    <span itemprop="name">c数据科学/czh_机器学习/模型转换</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/04/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/czh_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2/pytorch%E6%A8%A1%E5%9E%8B%E5%A6%82%E4%BD%95%E7%94%A8C++%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%BD%BD/" class="post-meta-item leancloud_visitors" data-flag-title="pytorch模型如何用C++进行加载" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>292</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月4日 下午12:13</p>
<p><a href="https://zhpmatrix.github.io/2019/03/01/c++-with-pytorch/" target="_blank" rel="noopener">PyTorchPyTorch的C++前端和模型部署</a><br><a href="https://zhpmatrix.github.io/2019/03/09/torch-jit-pytorch/" target="_blank" rel="noopener">PyTorch直观认识torch.jit模块</a></p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ol>
<li>其实这节的内容不属于不同框架之间模型转化，讲的是针对于<strong>pytorch模型如何用C++进行加载</strong><ul>
<li>是换语言（其实依然使用的是pytorch），而不是换框架</li>
<li><code>#include &lt;torch/script.h&gt;</code>这个就是pytorch的C++前端接口</li>
</ul>
</li>
<li>稍后的业界的算法同学的工作流程可能就会变成这样：<ul>
<li>论文发布-&gt;PyTorch开源代码(或者自己实现)-&gt;训练模型-&gt;导出模型-&gt;载入模型(C++_Python_其他框架/其他硬件平台)</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/04/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/czh_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/knowledge_2020/pytorch%20tensorflow%E6%95%99%E7%A8%8B%EF%BC%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/04/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/czh_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/knowledge_2020/pytorch%20tensorflow%E6%95%99%E7%A8%8B%EF%BC%9A/" class="post-title-link" itemprop="url">pytorch tensorflow教程：</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-04 09:46:00" itemprop="dateCreated datePublished" datetime="2020-04-04T09:46:00+08:00">2020-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 16:19:50" itemprop="dateModified" datetime="2020-05-04T16:19:50+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-czh-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-knowledge-2020/" itemprop="url" rel="index">
                    <span itemprop="name">c数据科学/czh_机器学习/knowledge_2020</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/04/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/czh_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/knowledge_2020/pytorch%20tensorflow%E6%95%99%E7%A8%8B%EF%BC%9A/" class="post-meta-item leancloud_visitors" data-flag-title="pytorch tensorflow教程：" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月4日 上午9:46</p>
<h3 id="tensorflow"><a href="#tensorflow" class="headerlink" title="tensorflow"></a>tensorflow</h3><p><a href="https://github.com/vahidk/EffectiveTensorflow" target="_blank" rel="noopener">GitHub - vahidk/EffectiveTensorflow: TensorFlow 1.x and 2.x tutorials and best practices.</a></p>
<h3 id="pytorch-持续更新中"><a href="#pytorch-持续更新中" class="headerlink" title="pytorch[持续更新中]"></a>pytorch[持续更新中]</h3><p><a href="https://github.com/vahidk/EffectivePyTorch" target="_blank" rel="noopener">GitHub - vahidk/EffectivePyTorch: PyTorch tutorials and best practices.</a></p>
<h4 id="作者从pytorch和numpy的对比出发开始讲解："><a href="#作者从pytorch和numpy的对比出发开始讲解：" class="headerlink" title="作者从pytorch和numpy的对比出发开始讲解："></a>作者从pytorch和numpy的对比出发开始讲解：</h4><ul>
<li>The most important advantage of PyTorch over NumPy is its <strong>automatic differentiation</strong> functionality which is very useful in optimization applications such as optimizing parameters of a neural network. </li>
<li>PyTorch allows you to perform your computations on <strong>CPUs, GPUs, and TPUs</strong> without any material change to your code.</li>
<li>PyTorch also makes it easy to <strong>distribute your computation</strong> across multiple devices or machines<h4 id="Part-I-PyTorch-Fundamentals"><a href="#Part-I-PyTorch-Fundamentals" class="headerlink" title="Part I: PyTorch Fundamentals"></a>Part I: PyTorch Fundamentals</h4></li>
</ul>
<ol>
<li><a href="https://github.com/vahidk/EffectivePyTorch#basics" target="_blank" rel="noopener">PyTorch basics</a> <ol>
<li><a href="bear://x-callback-url/open-note?id=CC7C402E-4930-4A96-98BF-8877E5F02506-1248-0000808343C75824">解释pytorch中的每轮迭代训练，更新参数W的过程</a></li>
</ol>
</li>
<li><a href="https://github.com/vahidk/EffectivePyTorch#modules" target="_blank" rel="noopener">Encapsulate your model with Modules</a> <ol>
<li>In the previous example we used bare bone tensors and tensor oeprations to build our model. To make your code slightly more organized it’s recommended to use PyTorch’s modules. A module is simply <strong>a container for your parameters and encapsulates model operations</strong>. </li>
</ol>
</li>
<li><a href="https://github.com/vahidk/EffectivePyTorch#broadcast" target="_blank" rel="noopener">Broadcasting the good and the ugly</a> <ol>
<li><strong>when you have a singular dimension</strong>. PyTorch implicitly tiles the tensor across its singular dimensions to match the shape of the other operand<ol>
<li>只有singular dimension时，才会有broadcasting</li>
</ol>
</li>
<li>when rank of two tensors don’t match, PyTorch automatically expands the first dimension of the tensor with lower rank before the elementwise operation, so the result of addition would be [[2, 3], [3, 4] ], and the reducing over all parameters would give us 12.<ol>
<li>我理解就是从内到外的顺序</li>
<li>A:[ [1.], [2.] ] ——&gt;  [ [1.,1.], [2.,2.] ] </li>
<li>B:[1., 2.] -&gt;  [ [1., 2.] [1., 2.] ] </li>
<li>A + B =  [[2, 3], [3, 4] ]<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = torch.tensor([[<span class="number">1.</span>], [<span class="number">2.</span>]])</span><br><span class="line">b = torch.tensor([<span class="number">1.</span>, <span class="number">2.</span>])</span><br><span class="line">c = torch.sum(a + b)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><a href="https://github.com/vahidk/EffectivePyTorch#overloaded_ops" target="_blank" rel="noopener">Take advantage of the overloaded operators</a> <ol>
<li>理解加速的原因？<ol>
<li>the reason is that <strong>we are calling the slice op 500 times</strong></li>
<li>A better choice would have been to use torch.unbind op to <strong>slice the matrix into a list of vectors all at once</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">z = -x  <span class="comment"># z = torch.neg(x)</span></span><br><span class="line">z = x + y  <span class="comment"># z = torch.add(x, y)</span></span><br><span class="line">z = x - y</span><br><span class="line">z = x * y  <span class="comment"># z = torch.mul(x, y)</span></span><br><span class="line">z = x / y  <span class="comment"># z = torch.div(x, y)</span></span><br><span class="line">z = x // y</span><br><span class="line">z = x % y</span><br><span class="line">z = x ** y  <span class="comment"># z = torch.pow(x, y)</span></span><br><span class="line">z = x @ y  <span class="comment"># z = torch.matmul(x, y)</span></span><br><span class="line">z = x &gt; y</span><br><span class="line">z = x &gt;= y</span><br><span class="line">z = x &lt; y</span><br><span class="line">z = x &lt;= y</span><br><span class="line">z = abs(x)  <span class="comment"># z = torch.abs(x)</span></span><br><span class="line">z = x &amp; y</span><br><span class="line">z = x | y</span><br><span class="line">z = x ^ y  <span class="comment"># z = torch.logical_xor(x, y)</span></span><br><span class="line">z = ~x  <span class="comment"># z = torch.logical_not(x)</span></span><br><span class="line">z = x == y  <span class="comment"># z = torch.eq(x, y)</span></span><br><span class="line">z = x != y  <span class="comment"># z = torch.ne(x, y)</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><a href="https://github.com/vahidk/EffectivePyTorch#torchscript" target="_blank" rel="noopener">Optimizing runtime with TorchScript</a> <ol>
<li>补充学习： <a href="bear://x-callback-url/open-note?id=580E2707-80DB-4B23-B2C2-95018567B9E1-1248-0000786ED4649688">pytorch模型如何用C++进行加载</a></li>
</ol>
</li>
<li><a href="https://github.com/vahidk/EffectivePyTorch#stable" target="_blank" rel="noopener">Numerical stability in PyTorch</a> <ol>
<li><a href="https://moore.live/news/53500/detail/" target="_blank" rel="noopener">LogSumExp这一机器学习中常见的模式-半导体新闻-摩尔芯球</a><ol>
<li>这篇文章详细的讲解了logSumExp的推理过程</li>
<li>涉及到两个数学知识：<ol>
<li>幂的乘法法则</li>
<li>对数的和差公式</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/04/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/czh_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/knowledge_2020/%E8%A7%A3%E9%87%8Apytorch%E4%B8%AD%E7%9A%84%E6%AF%8F%E8%BD%AE%E8%BF%AD%E4%BB%A3%E8%AE%AD%E7%BB%83%EF%BC%8C%E6%9B%B4%E6%96%B0%E5%8F%82%E6%95%B0W%E7%9A%84%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/04/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/czh_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/knowledge_2020/%E8%A7%A3%E9%87%8Apytorch%E4%B8%AD%E7%9A%84%E6%AF%8F%E8%BD%AE%E8%BF%AD%E4%BB%A3%E8%AE%AD%E7%BB%83%EF%BC%8C%E6%9B%B4%E6%96%B0%E5%8F%82%E6%95%B0W%E7%9A%84%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">解释pytorch中的每轮迭代训练，更新参数W的过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-04 02:58:00" itemprop="dateCreated datePublished" datetime="2020-04-04T02:58:00+08:00">2020-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 19:31:53" itemprop="dateModified" datetime="2020-04-12T19:31:53+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-czh-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-knowledge-2020/" itemprop="url" rel="index">
                    <span itemprop="name">c数据科学/czh_机器学习/knowledge_2020</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/04/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/czh_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/knowledge_2020/%E8%A7%A3%E9%87%8Apytorch%E4%B8%AD%E7%9A%84%E6%AF%8F%E8%BD%AE%E8%BF%AD%E4%BB%A3%E8%AE%AD%E7%BB%83%EF%BC%8C%E6%9B%B4%E6%96%B0%E5%8F%82%E6%95%B0W%E7%9A%84%E8%BF%87%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="解释pytorch中的每轮迭代训练，更新参数W的过程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月4日 下午2:58</p>
<h3 id="解释pytorch三个内置函数的功能："><a href="#解释pytorch三个内置函数的功能：" class="headerlink" title="解释pytorch三个内置函数的功能："></a>解释pytorch三个内置函数的功能：</h3><p><a href="https://discuss.pytorch.org/t/what-does-the-backward-function-do/9944" target="_blank" rel="noopener">What does the backward() function do? - autograd - PyTorch Forums</a></p>
<ol>
<li><strong>loss.backward()</strong> computes dloss/dx for every parameter x which has requires_grad=True. These are accumulated into x.grad for every parameter x. In pseudo-code:<ul>
<li>x.grad += dloss/dx</li>
</ul>
</li>
<li><strong>optimizer.step</strong> updates the value of x using the gradient x.grad. For example, the SGD optimizer performs:<ul>
<li>x += -lr * x.grad</li>
</ul>
</li>
<li><strong>optimizer.zero_grad()</strong> clears x.grad for every parameter x in the optimizer. It’s important to call this before loss.backward(), otherwise you’ll accumulate the gradients from multiple passes.</li>
<li>If you have <strong>multiple losses (loss1, loss2)</strong> you can sum them and then call backwards once:<ul>
<li>loss3 = loss1 + loss2</li>
<li>loss3.backward()</li>
</ul>
</li>
</ol>
<h4 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h4><ol>
<li>在每轮训练的过程中，其实还是<strong>数学结论的代码实现</strong>，代码只负责数学的结论，不体现你在稿纸上的推理结论过程</li>
<li>在每轮训练的过程中尝试问自己一个问题？<ol>
<li><strong>为什么 x += -lr * x.grad 就可以让W越来越接近正确的结果？</strong><ul>
<li>这里的x，其实写成 w += -lr * w.grad，我觉得更加正确，loss函数的自变量应该是w，而不是样本x，样本应该是已知量。</li>
<li>首先需要认识到这是一个从数学推导出来的结论，这个推导过程叫做SGD(梯度下降)，这个loss就是f(w)，在SGD中我们对他进行了泰勒展开，得出了更新w的结论w += -lr * w.grad</li>
</ul>
</li>
<li>这个问题必须得问出来，否则犯了一个本末倒置的问题<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assuming we know that the desired function is a polynomial of 2nd degree, we</span></span><br><span class="line"><span class="comment"># allocate a vector of size 3 to hold the coefficients and initialize it with</span></span><br><span class="line"><span class="comment"># random noise.</span></span><br><span class="line">w = torch.tensor(torch.randn([<span class="number">3</span>, <span class="number">1</span>]), requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># We use the Adam optimizer with learning rate set to 0.1 to minimize the loss.</span></span><br><span class="line">opt = torch.optim.Adam([w], <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment"># We define yhat to be our estimate of y.</span></span><br><span class="line">    f = torch.stack([x * x, x, torch.ones_like(x)], <span class="number">1</span>)</span><br><span class="line">    yhat = torch.squeeze(f @ w, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> yhat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_loss</span><span class="params">(y, yhat)</span>:</span></span><br><span class="line">    <span class="comment"># The loss is defined to be the mean squared error distance between our</span></span><br><span class="line">    <span class="comment"># estimate of y and its true value. </span></span><br><span class="line">    loss = torch.nn.functional.mse_loss(yhat, y)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Generate some training data based on the true function</span></span><br><span class="line">    x = torch.rand(<span class="number">100</span>) * <span class="number">20</span> - <span class="number">10</span></span><br><span class="line">    y = <span class="number">5</span> * x * x + <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> x, y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">()</span>:</span></span><br><span class="line">    x, y = generate_data()</span><br><span class="line"></span><br><span class="line">    yhat = model(x)</span><br><span class="line">    loss = compute_loss(y, yhat)</span><br><span class="line"></span><br><span class="line">    opt.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    opt.step()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    train_step()</span><br><span class="line"></span><br><span class="line">print(w.detach().numpy())</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/" class="post-title-link" itemprop="url">10道大厂面试必考题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-31 09:42:00" itemprop="dateCreated datePublished" datetime="2020-03-31T09:42:00+08:00">2020-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 15:41:08" itemprop="dateModified" datetime="2020-06-08T15:41:08+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-d-%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/d_网络/网络基础</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/" class="post-meta-item leancloud_visitors" data-flag-title="10道大厂面试必考题" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年3月31日 下午9:42</p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://ppt.infoq.cn/list/geeklive2020" target="_blank" rel="noopener">大会演讲PPT合集</a><br><a href="https://www.bilibili.com/video/BV1gk4y1o7pX" target="_blank" rel="noopener">10 道大厂面试必考的计算机网络问题_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ol>
<li>请详细介绍下TCP的三次握手机制,为什么要三次握手?<ol>
<li>为什么要有握手?<ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&mid=2247495063&idx=2&sn=2bc367afd533a03d8fa5a88c38b5389c&chksm=96ce4cdaa1b9c5cc1d06de383195afdd22ac732021b75bfeeb0ce159c79b72b1531773cba5f3&mpshare=1&s" target="_blank" rel="noopener">动画讲解TCP，再不懂请来打我</a></li>
<li>第一，为了确认双方的接收与发送能力是否正常。</li>
<li>第二，指定自己的初始化序列号，为后面的可靠传送做准备。</li>
<li>第三，如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</li>
</ol>
</li>
<li>为什么是三次?￼为什么不是四次？<ol>
<li>TCP中建立连接的过程是三次握手<ol>
<li>client发出第三次握手后，不等待server返回，就直接断开连接了</li>
</ol>
</li>
<li>连接断开的过程是四次握手<ol>
<li>发起端发出第三次握手后，还得等待server返回，在这个过程中是连接的半打开状态，被动端处于close_wait状态，被动端可以向主动端发送消息，并且主动端是可以接收的。在linux，这个半打开连接状态可以是无限时长</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>简单介绍下HTTP协议中缓存的处理流程?<ol>
<li>缓存的应用流程是什么?<br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/0003.jpg" alt><ol start="2">
<li>304 与 200的区别：<ol>
<li>304：如果服务器验证摘要没有发生变化，那么我们直接返回304，此时是返回的http是没有body的，这样就节省了带宽</li>
<li>200：如果服务器验证摘要发生变化，那么我们需要在返回的body中添加新的摘要信息<br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/0004.jpg" alt><br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/0005.jpg" alt></li>
</ol>
</li>
</ol>
</li>
<li>与缓存相关的HTTP头部有哪些?<br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/0009.jpg" alt></li>
</ol>
</li>
<li>在地址栏键入URL后,网络世界发生么什么?<ol>
<li>这是一道开放的题，可以进行多角度的回答：讲述正向、反向、DNS的过程，转换为http协议头，计算机网络分层结构、每一个层的作用<br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/0012.jpg" alt></li>
</ol>
</li>
<li>￼使用HTTP长连接有哪些优点?<ol>
<li>减少握手次数</li>
<li>减少慢启动时间</li>
<li>缺点：因为http长连接是依靠于单个tcp，而在单个tcp中文档中的每个字段在服务端接受的时候需要严格的顺序，串行的文件传输。这样就会导致大量的重传。</li>
</ol>
</li>
<li>CLOSE_WAIT状态产生的原因￼?<br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/0014.jpg" alt></li>
<li>介绍下多播是怎样实现的?<ol>
<li>多播是依靠UDP来实现的，TCP是一对一的连接，不能使用</li>
<li>使用了多播以后，可以降低client在内存中的数据拷贝，极大的节省了client的效率，这部分拷贝是让网络中的支持多播的路由器等设备进行拷贝。<br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/0015.jpg" alt></li>
</ol>
</li>
<li>服务器的最大并发连接数是多少?<ol>
<li><a href="https://www.cnblogs.com/fjping0606/p/4729389.html" target="_blank" rel="noopener">详解Linux服务器最大tcp连接数 - 陌上归人的博客 - 博客园</a></li>
<li>server端tcp连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方<br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/0017.jpg" alt></li>
</ol>
</li>
<li>￼TCP和UDP协议该如何选择?<br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/0021.jpg" alt><ol start="2">
<li>老师在视频里讲解了多个场景</li>
</ol>
</li>
<li>TLS/SSL协议是如何保障信息安全的?<br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/0022.jpg" alt></li>
<li>HTTP2协议有哪些优点?<ol>
<li><a href="https://juejin.im/post/5d70848df265da03d871de9c" target="_blank" rel="noopener">Http系列(二) Http2中的多路复用 - 掘金</a></li>
<li>从 Http/0.9 到 Http/2 要发送多个请求，从<strong>多个 Tcp 连接=&gt;keep-alive=&gt;管道化=&gt;多路复用</strong>不断的减少多次创建 Tcp 等等带来的性能损耗。</li>
<li><strong>多个 Tcp 连接</strong><ol>
<li>在最早的时候没有keep-alive只能创建多个Tcp连接来做多次请求。多次 http 请求效果如下图所示：<br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/189E6361-68A9-4A6E-AE3B-1B7AEC9200CA.png" alt></li>
<li>一次请求完成就会关闭本次的 Tcp 连接，下个请求又要从新建立 Tcp 连接传输完成数据再关闭，造成很大的性能损耗。</li>
</ol>
</li>
<li><strong>Keep-Alive</strong><ol>
<li>Keep-Alive解决的核心问题是： 一定时间内，同一域名多次请求数据，只建立一次 HTTP 请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。<br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/7B378A0F-E7C4-4A60-9167-13490E120650.png" alt></li>
<li>Keep-Alive# 还是存在如下问题：<ul>
<li>串行的文件传输。</li>
<li>同域并行请求限制带来的阻塞（6~8）个</li>
</ul>
</li>
</ol>
</li>
<li><strong>管线化</strong><ol>
<li>HTTP 管线化可以克服同域并行请求限制带来的阻塞，它是建立在<strong>持久连接</strong>之上，是把所有请求一并发给服务器，但是服务器需要按照<strong>顺序一个一个响应</strong>，而不是等到一个响应回来才能发下一个请求，这样就节省了很多请求到服务器的时间。</li>
<li>不过，HTTP 管线化<strong>仍旧</strong>有阻塞的问题，若上一响应迟迟不回，<strong>后面的响应</strong>都会被阻塞到。<br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/4949DBF3-4F57-41A9-9964-8310961C8DBA.png" alt></li>
</ol>
</li>
<li><strong>多路复用</strong><ol>
<li>多路复用代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP 连接并发完成。因为在多路复用之前所有的传输是基于基础文本的，在多路复用中是基于二进制数据帧的传输、消息、流，所以可以做到乱序的传输。多路复用对同一域名下所有请求都是基于流，所以不存在同域并行的阻塞。多次请求如下图：<br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/FB238F40-24F7-4CAE-B402-774BCD4D77B4.png" alt></li>
</ol>
</li>
<li>总结：<ol>
<li><strong>在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）</strong>。</li>
<li><strong>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流</strong>。</li>
<li><strong>HTTP2 采用二进制数据帧传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效</strong>。<br><img src="/2020/03/31/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/d_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/10%E9%81%93%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E9%A2%98/0025.jpg" alt></li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="收获："><a href="#收获：" class="headerlink" title="收获："></a>收获：</h4><ol>
<li>在面试的时候，要知道面试官问题的这个问题对应与哪几个知识点</li>
<li>很多题是开放性的，可以从多个角度进行分析<ol>
<li>在地址栏键入 URL 后，网络世界发生了什么？</li>
<li>这个问题就是最典型的可以多角度分析的问题</li>
</ol>
</li>
<li>并发是一个很好的总结这些网络知识的角度，尤其对于大厂来说</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/03/24/e%E8%A7%86%E8%A7%89%E7%9B%B8%E5%85%B3/czh_%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA(%E5%9B%BE%E7%89%87)/%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%8E%A8%E8%8D%90%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/24/e%E8%A7%86%E8%A7%89%E7%9B%B8%E5%85%B3/czh_%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA(%E5%9B%BE%E7%89%87)/%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%8E%A8%E8%8D%90%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">推荐教程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-24 04:43:00" itemprop="dateCreated datePublished" datetime="2020-03-24T04:43:00+08:00">2020-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 15:40:07" itemprop="dateModified" datetime="2020-06-08T15:40:07+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/e%E8%A7%86%E8%A7%89%E7%9B%B8%E5%85%B3-czh-%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA-%E5%9B%BE%E7%89%87-%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index">
                    <span itemprop="name">e视觉相关/czh_三维重建(图片)/知识点#</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/03/24/e%E8%A7%86%E8%A7%89%E7%9B%B8%E5%85%B3/czh_%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA(%E5%9B%BE%E7%89%87)/%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%8E%A8%E8%8D%90%E6%95%99%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="推荐教程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年3月24日 下午4:43</p>
<p><a href="https://cseweb.ucsd.edu/classes/sp04/cse252b/" target="_blank" rel="noopener">CSE 252B Spring 2004</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/03/23/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/latex/%E6%91%98%E6%8A%84%EF%BC%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/latex/%E6%91%98%E6%8A%84%EF%BC%9A/" class="post-title-link" itemprop="url">摘抄：</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-23 09:10:00" itemprop="dateCreated datePublished" datetime="2020-03-23T09:10:00+08:00">2020-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-08 15:40:54" itemprop="dateModified" datetime="2020-06-08T15:40:54+08:00">2020-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-e-%E8%AF%AD%E8%A8%80-LaTex/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/e_语言/LaTex</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/03/23/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/e_%E8%AF%AD%E8%A8%80/latex/%E6%91%98%E6%8A%84%EF%BC%9A/" class="post-meta-item leancloud_visitors" data-flag-title="摘抄：" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>29</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年3月23日 下午9:10<br><a href="https://zhuanlan.zhihu.com/p/30944610" target="_blank" rel="noopener">论文格式细节整理汇总 - 知乎</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/03/21/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/czh_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/knowledge_2020/%E6%89%93%E5%8D%B0%EF%BC%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/21/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/czh_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/knowledge_2020/%E6%89%93%E5%8D%B0%EF%BC%9A/" class="post-title-link" itemprop="url">打印：</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-21 11:40:00" itemprop="dateCreated datePublished" datetime="2020-03-21T11:40:00+08:00">2020-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-01 14:54:31" itemprop="dateModified" datetime="2020-04-01T14:54:31+08:00">2020-04-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-czh-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-knowledge-2020/" itemprop="url" rel="index">
                    <span itemprop="name">c数据科学/czh_机器学习/knowledge_2020</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/03/21/c%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/czh_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/knowledge_2020/%E6%89%93%E5%8D%B0%EF%BC%9A/" class="post-meta-item leancloud_visitors" data-flag-title="打印：" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>82</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年3月21日 下午11:40</p>
<p>2020年3月21日 下午11:40<br><a href="https://blog.csdn.net/weixin_40449426/article/details/78141635" target="_blank" rel="noopener">Faster R-CNN的训练过程的理解_网络_weixin_40449426的博客-CSDN博客</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/119/">119</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhiheng Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1188</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhiheng Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">18:52</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        






  <script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.getAttribute('data-flag-title');

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=QiM1vjQ7SAoirKD4qY57L82O-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id'     : 'QiM1vjQ7SAoirKD4qY57L82O-gzGzoHsz',
            'X-LC-Key'    : 'aOHhzmfDblK0HGWUqEyb6ra2',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
