<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.chenzhiheng.cn","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="陈志恒的博客">
<meta property="og:url" content="http://www.chenzhiheng.cn/page/97/index.html">
<meta property="og:site_name" content="陈志恒的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhiheng Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.chenzhiheng.cn/page/97/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>陈志恒的博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6bc779d0e3be483fc01e871fbb7cef3d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">陈志恒的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenzhiheng.cn/2017/07/01/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/01/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">java基础阶段图书管理系统项目需求分析过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-01 03:16:00" itemprop="dateCreated datePublished" datetime="2017-07-01T03:16:00+08:00">2017-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 16:46:16" itemprop="dateModified" datetime="2020-03-12T16:46:16+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%BC%80%E5%8F%91-czh-java-java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">web开发/czh_java/java基础</span>
                  </a>
                </span>
            </span>

          
            <span id="/2017/07/01/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="java基础阶段图书管理系统项目需求分析过程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2017年7月1日 下午3:16</p>
<h1 id="这篇文章就是我边想问题边写的，记录了我整个思考的过程"><a href="#这篇文章就是我边想问题边写的，记录了我整个思考的过程" class="headerlink" title="这篇文章就是我边想问题边写的，记录了我整个思考的过程"></a>这篇文章就是我边想问题边写的，记录了我整个思考的过程</h1><p>几个注意点：<br>    1. <strong>整体的结构要心中有数</strong>，可以用图来辅助<br>    2. 这个项目的难点在于功能流程的设计，数据库表的设计很简单<br>    3. 发现隐藏的功能，做好以后功能的扩展。<br>    4. 同时也要学会偷懒技巧，实现简单，但是却让人喜欢</p>
<p>现在想到的功能有：<br>    1. 登陆注册，人员的流动                                                                 一天<br>        1. 多用户登陆<br>            1. 一个多线程的服务端<br>            2. 一个客户端<br>        2. 前后端两个<br>        3. 会员管理系统<br>    2. 权限管理系统：<br>        1. 前后端可以设计不同的阶梯，CCF                                      一天<br>    3. 图书<strong>查询</strong>系统【核心】：                                                           三天<br>        1. 用户查书有没有，模糊查询<br>            1. 按作者<br>            2. 按类别<br>            3. 按日期查询<br>            4. 按出版社<br>            5. 按库存<br>        2. 用户查自己的借阅情况<br>            1. 用户还书<br>            2. 超时扣钱<br>        3. 管理员<br>            1. 查询一本书的借阅历史<br>            2. 查破损</p>
<pre><code>4. 辅助功能【看时间自由调整】：                                                  一天
    1. 图书的破损，下架，丢失</code></pre><hr>
<p>程序员可以创建类<br>而用户只能创建对象    </p>
<hr>
<p>老师的那个是权限于功能进行了绑定<br>而我的这个是权限和功能是分开的，先判断权限再去执行功能。<br>但是功能从哪来呢？<br>那还不如最小的权限绑定功能，而角色和权限的多对多功能，这是操作对象，所以能够给了用户来操作，用户和角色的一对多的关系也是对象操作，也可以给了用户</p>
<hr>
<h3 id="设计模式："><a href="#设计模式：" class="headerlink" title="设计模式："></a>设计模式：</h3><p>不能为了使用设计模式，专门去向哪里可以用，<br><strong>功能为导向哦！</strong></p>
<hr>
<p><img src="/2017/07/01/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/%E2%80%A2%20BookManage.mdj%20%E2%80%94%20StarUML%20StarUML,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8A%E5%8D%8810.22.28.png" alt><br><strong>这里的额priority1-3不能出现方法的重名</strong></p>
<p>为了以后<strong>扩从管理员的功能</strong>：这里使用了<strong>代理模式</strong><br>priority1是priority3针对interface3种方法的扩充<br>interface1,interface2是横向扩充<br>interface3 是纵向扩充</p>
<hr>
<h3 id="如何实现一个权限分多级的情况？"><a href="#如何实现一个权限分多级的情况？" class="headerlink" title="如何实现一个权限分多级的情况？"></a>如何实现一个权限分多级的情况？</h3><p>在interface中写不同的方法e.g.：<strong>input1() input2()</strong><br>这里的权限1，2就是权限等级<br>这里的<strong>核心问题就是方法的参数化</strong>：利用反射可以解决<br>使用方法：<br>    User中有一个方法userMethod(String methodName);<br>实现类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射中方法的测试</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_Method</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//获取Student对应的Class对象</span></span><br><span class="line">		Class cla=Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		<span class="comment">//创建Student对象</span></span><br><span class="line">		Student p=<span class="keyword">new</span> Student();</span><br><span class="line">		<span class="comment">//得到setName方法</span></span><br><span class="line">		Method met1=cla.getMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="comment">//调用setName，为name赋值</span></span><br><span class="line">		met1.invoke(p, <span class="string">"Jack"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//得到setName方法</span></span><br><span class="line">		Method met=cla.getMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">//调用setName，为name赋值</span></span><br><span class="line">		Object o=met.invoke(p, <span class="keyword">null</span>);</span><br><span class="line">		System.out.println(o);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里可以使用<strong>组合模式</strong><br>将Role继承自priority<br>好处是：要是用户只有一个Priority，一步就可以完成了，省去了Role。</p>
<hr>
<h3 id="如何实现上下级批准："><a href="#如何实现上下级批准：" class="headerlink" title="如何实现上下级批准："></a>如何实现上下级批准：</h3><p>这个不属于类的设计，是通过逻辑代码实现的。<br>要是在类图中就实现上下级，那是一定不可改变得。</p>
<p>以及实现人员的变动，这都是通过逻辑代码实现的。</p>
<hr>
<h3 id="服务端的任务—其实是个假的服务端，因为他仅仅完成了登陆这一个功能："><a href="#服务端的任务—其实是个假的服务端，因为他仅仅完成了登陆这一个功能：" class="headerlink" title="服务端的任务—其实是个假的服务端，因为他仅仅完成了登陆这一个功能："></a>服务端的任务—其实是个假的服务端，因为他仅仅完成了登陆这一个功能：</h3><pre><code>1. 服务端就是一个黑盒
2. 不走权限整个流程
3. 接收的是用户名和密码
    1. 实现判断
    2. 实现注册
4. 返回的是
    1. 登陆是否成功
    2. 注册是否成功
    3. Flag标志区分普通用户和管理员
5. 实现普通用户和管理员的区分
    1. 查不同的文件txt</code></pre><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端:"></a>客户端:</h3><pre><code>1. 拿到用户名密码
2. 给了服务器
3. 根据服务器的返回，执行不同的普通用户和管理员的方法
4. 运行不同的操作（界面）</code></pre><hr>
<h3 id="如何确定当前用户的操作？并执行？"><a href="#如何确定当前用户的操作？并执行？" class="headerlink" title="如何确定当前用户的操作？并执行？"></a>如何确定当前用户的操作？并执行？</h3><p>现在是像洋葱一样，一层一层的，要用的对象（priority对象）在最里面。<br>User的useMethod()方法中的Class.from()这里写啥？<br>如果要是表中：用户 &lt;—&gt;priority<br>那Role怎么办？<br>Role是程序写的，这里就要实现其中包含的priority的全部方法。</p>
<h3 id="啥是活的啥是死的？"><a href="#啥是活的啥是死的？" class="headerlink" title="啥是活的啥是死的？"></a>啥是活的啥是死的？</h3><p>程序员：<br>    1. 增加一个priority类别，增加一个role类别<br>用户：<br>    1. 在当前已有的priority  和 role中进行选择</p>
<h3 id="又绕回到了一开始的那就话："><a href="#又绕回到了一开始的那就话：" class="headerlink" title="又绕回到了一开始的那就话："></a>又绕回到了一开始的那就话：</h3><p>用户是不能去创建一个类，或者创建一个类中的方法的。<br>这些都是程序写死的，用户最多只能选择！</p>
<hr>
<p>人工智能</p>
<hr>
<h3 id="能不能先写逻辑，再写图形界面？"><a href="#能不能先写逻辑，再写图形界面？" class="headerlink" title="能不能先写逻辑，再写图形界面？"></a>能不能先写逻辑，再写图形界面？</h3><pre><code>1. 数据获取的方式发生改变。
    1. 原来是scanner
    2. 现在是JFrame的txt框
2. 页面跳转的方式放生了变化
    1. 原来是输入数字选
    2. 现在是鼠标点
3. 数据的输出方式了改变
    1. 原来是printf
    2. 现在是JFrame中</code></pre><p>总体来说：填了很多麻烦</p>
<p>先写逻辑，后写图形</p>
<h3 id="类有哪些？"><a href="#类有哪些？" class="headerlink" title="类有哪些？"></a>类有哪些？</h3><pre><code>1. 上面的权限，一堆
2. 还有book，bookBiz
3. 文件操作的FileBiz</code></pre><h3 id="有哪些包？"><a href="#有哪些包？" class="headerlink" title="有哪些包？"></a>有哪些包？</h3><pre><code>1. entity.book
    1. 计算总价方法
    2. 显示图书信息方法
2. bookBiz
    1. 初始化书的信息
    2. 图书入库
    3. 图书出库
    4. 新增图书
    5. 查询图书
    6. 购买图书
    7. 查询图书是否存在
3. entity.user
    1. 从priority获取方法名数组【长度规定为10】
    2. 显示当前用户所具有的功能
    3. 建立数字和方法的对应关系
    4. 根据输入，通过反射调用不同的功能
    5. 这里的输入之后，还得进行一个字符串拼接，实现权限分级
4. priority
    1. 调用bookBiz
    2. **获取方法名的数组**
5. priority.ext
6. priority.impl
7. file
8. file.impl
    1. 获取一行数据
    2. 取一行数据，分割到数组
    3. 取全部的数据，保存数组，除了第一行
    4. 插入表头
    5. 插入一条数据
    6. 新建一个文件
9. Test
    1. 给client数据
    2. 调用user完成工作
10. Server
    1. Thread
    2. 干活的类
11. Client
    1. 从test拿到数据给server</code></pre><hr>
<h3 id="步骤？"><a href="#步骤？" class="headerlink" title="步骤？"></a>步骤？</h3><pre><code>1. 文件
2. book
3. 权限
4. server
5. user
6. test</code></pre><p>把这个权限打成一个jar包去使用<br>这个现在还不考虑</p>
<hr>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>我知道的：<br>    1. 类名<br><strong>两种解决方法：</strong><br>    1. 给User建子类，每回登陆通过判断类名，好多的if产生不同的对象<br>        1. 每次增加一个类，都要两边写<br>    2. 试用反射，用类名 把类先反射出来（通过反射来<strong>读类</strong>）<br>        1. 这时已经能调用方法了<br>        2. 能调用方法，那所有的问题都解决了</p>
<hr>
<h3 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h3><pre><code>1. **方法知道了，但是参数不知道**
    1. 在写一个参数的方法
    2. 其重要有参数的个数 和 类型
2. **invoke返回的是object对象**，除了string 和 int 类型
    1. 其他的类型是固定的没几种
        1. string[]
        2. string[][]
        3. ArrayList&lt;String&gt;</code></pre><p><strong>三个方法返回数组中的内容是有顺序的，必须一致</strong><br><strong>这个可以抽象成一个方法</strong><br>    3. <strong>如何融入权限分层</strong><br>        1. 要限定<br>            1. 一共三层<br>            2. 方法要用method_1(),method_2();固定的_来分割<br>            3. 把取出来的方法分割</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class c=Class.forName(<span class="string">"cn.chenzhiheng.user.priority.PriorityClient"</span>);</span><br><span class="line">		Object o=c.newInstance();</span><br><span class="line">		Method[] m=c.getMethods();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m.length;i++)&#123;</span><br><span class="line">			System.out.println(m[i].getName());</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">if</span>(m[i].getName().equals(method))&#123;</span><br><span class="line">				Object[] os=<span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">				ArrayList&lt;String&gt; strings=(ArrayList&lt;String&gt;) m[i].invoke(o,<span class="keyword">null</span>);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; strings.size();j++)&#123;</span><br><span class="line">					System.out.println(<span class="string">"***"</span>+strings.get(j));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Test的操作流程"><a href="#Test的操作流程" class="headerlink" title="Test的操作流程"></a>Test的操作流程</h3><pre><code>1. scanner **获取用户名和密码+userId**
2. 通过client传递给server
    1. 这里要区分增删改查
3. 接受server传递过来的用户权限
    1. 不一定是权限
    2. 有可能是操作是否完成
4. 根据用户权限调用user打印出当前所有的方法
5. 调用方法去完成一些操作</code></pre><h3 id="当加上界面的时候"><a href="#当加上界面的时候" class="headerlink" title="当加上界面的时候"></a>当加上界面的时候</h3><pre><code>1. 界面是点的操作
2. 而控制窗是从上到下的一个顺序操作
3. 所以，**控制窗与逻辑的交互**由一个分割好的**test来完成**</code></pre><hr>
<h3 id="三个数据表增删改查之间的关系"><a href="#三个数据表增删改查之间的关系" class="headerlink" title="三个数据表增删改查之间的关系"></a>三个数据表增删改查之间的关系</h3><pre><code>1. 买书的时候要增加info
2. 不删除book和user 只更改他们的状态
3. 退货删info
    1. 输入infoId
    2. 通过infoid找到bookid
    3. 删除info
    4. 更改bookid对应的数量
4. **user_book不直接操作，全部由Book类来操作**</code></pre><hr>
<h3 id="怎样实现自增"><a href="#怎样实现自增" class="headerlink" title="怎样实现自增"></a>怎样实现自增</h3><pre><code>1. 抽象类 static index
2. index++;
3. 构造函数</code></pre><hr>
<h3 id="权限的升级："><a href="#权限的升级：" class="headerlink" title="权限的升级："></a>权限的升级：</h3><pre><code>1. 已有权限
    1. 直接更改用户的priority字段
    2. 用户权限的更改只能有管理员进行
2. 没有的权限
    1.有可能 **写Biz**
    2. 写priorityImpl
    3. 写priority继承自 ext 实现impl接口
    4. 然后在写一个role在包括原来的和现在的对象
    5. 在像上面一样更改用户权限字段</code></pre><hr>
<p>Biz的功能不是priority 都必须用了e.g.：insertHead。<br>程序员用一次就行了</p>
<hr>
<p>这回幸亏是从下往上做，每一层都是一个封装。<br>对下层的多次运用</p>
<hr>
<h3 id="如何拿到使用不同类型反射回的结果"><a href="#如何拿到使用不同类型反射回的结果" class="headerlink" title="如何拿到使用不同类型反射回的结果"></a>如何拿到使用不同类型反射回的结果</h3><pre><code>1. 由于多态中不支持多返回的类型
2. 所以这种情况，只能写不同的方法</code></pre><hr>
<p>结算功能：<br>一个用户-一个权限-一个Userbiz(多个唯一的biz)</p>
<hr>
<p>理想中的代码层次-应该像：MVC<br>    1. 我从数据库中取出用户的权限等级，作为全局变量<br>    2. 然后生成对应这个等级的<strong>页面</strong><br>    3. 点击一个<strong>功能按钮</strong>，然后<strong>跳到逻辑处理层</strong><br>    4. 逻辑处理层的数据，然后<strong>投影到一个页面中</strong><br>    5. <strong>页面—&gt;跳到逻辑层—&gt;新的页面</strong><br>    6. <del>就像TP一样</del><br>现在：<br>    1. 我点击<strong>功能按钮</strong>，然后<strong>逻辑处理</strong><br>    2. 逻辑处理完，显示到页面<br>    3. 这个整个过程是<strong>瀑布型</strong>的，像c一样从上到下的执行<br>    4. <strong>没有跳转</strong><br>    5. <strong>页面—&gt;走逻辑—&gt;旧页面</strong><br>    6. <del>就像原生php一样</del></p>
<hr>
<h3 id="那么第二种为啥会把一个权限系统给废了？"><a href="#那么第二种为啥会把一个权限系统给废了？" class="headerlink" title="那么第二种为啥会把一个权限系统给废了？"></a>那么第二种为啥会把一个权限系统给废了？</h3><pre><code>1. 这的权限系统就是一个**逻辑层**
2. **入口**的是你要执行的**方法名**
3. **出口**是你要的**数据**
4. 这就一个**封装**
5. 不是废了，**我这个权限系统不是用来分层的**</code></pre><h3 id="假设你现在已经按不分层的想法写完了项目，那么有啥改进的地方？"><a href="#假设你现在已经按不分层的想法写完了项目，那么有啥改进的地方？" class="headerlink" title="假设你现在已经按不分层的想法写完了项目，那么有啥改进的地方？"></a>假设你现在已经按不分层的想法写完了项目，那么有啥改进的地方？</h3><pre><code>1. 现在的情况，就是JFrame其实就是再次把UserReflectf封装了一次
2. 如果让增加功能，不仅权限里要增加相应的类，而且还要更改对应的页面
3. 做的这个权限系统不是让权限完全随用户更改添加，而是更重要的是**程序员做维护的时候好维护，自己用这个权限写项目思路更加清晰**
4. 如果是分层写的话，会这样思考
    1. 页面用不用改？哪里改？眼前全是html
    2. 逻辑用不用改？哪里改？眼前全是php逻辑
5. 如果不是分层写的话，会这样思考
    1. 乱死了，这个不是页面，跳过/这个不是逻辑，虽然明显，但是时间长了自己会**烦躁**。
6. **关键：**分层写，我可以在逻辑层处理多种任务，获得多次的数据，然后把**多组数据**都传递给新的页面
7. 分层于不分层的直观理解：
    1. 分层是把不分层的中写在**一个页面的所有过程**，集中放在一个新页面中，是一个**提取的关系**
    2. Ps：相似的功能可以通过将**各个过程封装到成方法中**
8. **分层知识为了更清晰，没其他作用**</code></pre><hr>
<h3 id="我用反射实现的权限管理"><a href="#我用反射实现的权限管理" class="headerlink" title="我用反射实现的权限管理"></a>我用反射实现的权限管理</h3><pre><code>1. 本质是实现了一对多的关系，**就是一个封装而已**
    1. 反射解决的是字符串产生对象的这个过程
    2. 一个字符串，就能对应那么多的具体的权限功能
2. 但是在这个项目中界面中只能是一对一的关系
    1. 一个界面已经绑定了一个代表权限的字符串了
3. 那这个权限系统在哪里才可以发挥它最大的作用
    1. 权限可以无限多
    2. 增加起来方便
    3. 一个权限功能的实现
        1. 权限名
        2. 方法名+参数
        3. 2这个是必须的，并不是我这个系统设计不合理留下的小尾巴
    4. 可以使用字符串直接对应权限，更加方便，直观（不用用数字去表示了）
    5. 总结：**因为封装好了，以后程序员用起来就比较方便了**
        1. 对用户来说，屁用没有
        2. 对程序员来说，却是极大的方便
    6. 这就是写框架要站的角度，和写项目占的角度**对比**
        1. 写框架是为让程序员更加爽、简单，框架就是一个封装，把麻烦的事情封装到一个黑盒中，然后，留一口，然程序员简单做到。在这过程中，程序员不用懂得其中的道理。
        2. 写项目时想的是如何实现一个功能，常常就为了一个boss功能较劲脑汁
        3. **但是**，顶尖的程序员，**做出项目来估计和设计框架是一样的**</code></pre><hr>
<h3 id="关于接口再说两句"><a href="#关于接口再说两句" class="headerlink" title="关于接口再说两句"></a>关于接口再说两句</h3><pre><code>1. 我突然一下感受到了接口的好处
    1. 在一开始，我写底层一个最小单位的一个书籍管理权限，其实直接创建一个类，写方法，填注释就行了。这时写接口是一件麻烦的事情。
    2. 但是，当我从底层越来越向上封装，集成。这时，我如果想在其他类中说明也要使用这些方法，我只要加上对应的接口，方法自动出来，我填内容就行。一般来说，内容可以直接用底层的对象调用来实现
    3. 如果没有接口，我就得反复的回去看底层的具体的类实现。还生怕拉下一个。
    4. 最常用的地方是：当修改一个，增加一个功能时，接口可以方便的提醒你还有哪些地方要改。对你的操作有**指示作用**
    5. 有时候需要去写一个抽象类，但是，java本身的这个类中就有继承如JFrame继承自Frame，这时只能用接口来救急了。
    6. 用了接口，妈妈在也不用为我担心这个问题了。</code></pre><hr>
<p>我现在是站在一个<strong>写框架</strong>的角度去思考<br>但是，这也回答了一个问题我们<strong>看框架的时候会经历什么</strong><br>最终，当你看完一个框架的时候，你脑子中是有一副<strong>类图的</strong><br>like：<br><img src="/2017/07/01/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/%E2%80%A2%20BookManage.mdj%20%E2%80%94%20StarUML%20StarUML,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%884.40.07.png" alt></p>
<hr>
<h3 id="退书和总价的关系"><a href="#退书和总价的关系" class="headerlink" title="退书和总价的关系?"></a>退书和总价的关系?</h3><p>Index还是有问题<br>Table<br>    1. 不初始化初始化<br>    2. 覆盖</p>
<hr>
<h3 id="监听实现接口写在一起的好处"><a href="#监听实现接口写在一起的好处" class="headerlink" title="监听实现接口写在一起的好处"></a>监听实现接口写在一起的好处</h3><pre><code>1. 可以何在一起写逻辑，而，单个是时候互不影响</code></pre><hr>
<h3 id="如何能发挥出这个权限系统的最大能力"><a href="#如何能发挥出这个权限系统的最大能力" class="headerlink" title="如何能发挥出这个权限系统的最大能力"></a>如何能发挥出这个权限系统的最大能力</h3><pre><code>1. 数据库中用户的权限是一个**对应权限类名**的一个字符串
2. UserRflect的参数就是**权限字符串**
3. 然后就可以通过UserRflect来调用**对应权限类**下的方法
4. 能够去除当前权限下的所有方法，但是这些方法并不是简单地像输出不同的语句这样的**不需要任何输入，有统一输出的的方法**，所以不能做统一的界面去执行所有的功能。
5. 就像web中的导航栏，导航栏可以是统一的，但是导航栏连接到的每个单独不同的页面，**这得一个一个的做**。</code></pre><hr>
<h3 id="如何让这个权限系统能够自动识别权限等级"><a href="#如何让这个权限系统能够自动识别权限等级" class="headerlink" title="如何让这个权限系统能够自动识别权限等级"></a>如何让这个权限系统能够自动识别权限等级</h3><pre><code>1. 如果实现了能够自判等级大小
    1. 那么在做相关功能的时候只需要调用一个方法就可以实现
    2. 比如说我这里要实现**当前用户只能看权限比他低的人的信息**
    3. 这个函数的参数是**权限字符串1 权限字符串2**
    4. **返回boolean**
2. 另一种实现方式，在biz查询全部用户的时候，在这就判断出结果。
    1. 那么，这种实现方式就和权限系统没关系了
    2. 如果在biz中在声明userRflect。
        1. **userRflect是用来执行方法的，不是用来判断权限的！**
    3. 那么，可以再设计一个userRflect配套的类，参数和返回值像1所说的。
3. 现在方案定了，就差功能的实现了！
    1. 如何才算是权限大，有哪些情况
        1. 存在**包含关系**的时候能判断权限大小
            1. 第一种：一个role中包含了多个priority，那么这些priority都比这个role权限小
            2. 第二种：role1包含role2时，role1的权限大于role2 的权限。
            3. 循环嵌套
    2. 那么问题来了，如何**判断他们的包含关系**
        1. 组合关系的递归
4. **一下午！实现了**
5. 使用方式：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Compare compare = <span class="keyword">new</span> Compare();		</span><br><span class="line"><span class="keyword">boolean</span> flag = compare.compare(<span class="string">"priority.PriorityBaseBook"</span>, <span class="string">"role.RoleAll"</span>);</span><br></pre></td></tr></table></figure>
<hr>
<p>我这个系统里面priorit对于图书的和用用户的管理都分别设置的普通给用户client端和管理员manager端，这是不符合实际的<br><img src="/2017/07/01/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/workspace%20-%20Java%20-%20BookManage-src-cn-chenzhiheng-user-role-PriorityAll.java%20-%20Eclipse%20Eclipse,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8A%E5%8D%8810.48.42.png" alt><br><strong>因为</strong>：<br>    1. 现实中，manager和client等级一高一低<br>    2. 但是在<strong>priority包中定义的权限</strong>，<strong>他们是没有高低的，都是一个独立的权限</strong><br>怎么改：<br>    1. 将priority包下的manager接口方法移动到role包下的对应的manager接口中，<br>    2. 然后在role包下的实体类中重新实现接口中的方法<br>    3. 对于role下包的实体类来说，是没有影响的<br>    4. 因为，他implments 多个接口，我们现在只是把一个接口中的方法放到另一个接口中，对role实体类来说<strong>无视</strong></p>
<hr>
<p><strong>循环包含</strong>的时候<br>    1. 接口要自己去查基础功能的接口,可以直接从包含类implement中复制过来<br>    2. 返回的方法和返回值类型也可直接拷贝，修改下长度</p>
<hr>
<h3 id="这个权限系统使用的要求："><a href="#这个权限系统使用的要求：" class="headerlink" title="这个权限系统使用的要求："></a>这个权限系统使用的要求：</h3><pre><code>1. 名字 属性名两部分  类名前准
    1. Priority包下,都是以priority为开头
    2. Role包下都已role开头
    3. 这个为了实现**权限等级判断的必要条件**
2. 方法 实例化哪几个方法
    1. PriorityExt抽象类下
        1. getReturns
        2. getMethods
    2. RoleExt extends PriorityExt
        1. getInclude
        2. **注意：role方法+1 judge**
3. 使用方式 
    1. 只需要一个**权限字符串**
4. 不同位置概念上的区别 
    1. Priotity包下，都是**最小单位的权限**，**并且不包含**，各为独立的个体
    2. Role包下，**可以不包括priority**，单独成为个体，作为最小单位。但是不同的是，**可以成为包含关系**</code></pre><hr>
<h3 id="权限系统的完整包"><a href="#权限系统的完整包" class="headerlink" title="权限系统的完整包"></a>权限系统的完整包</h3><p><img src="/2017/07/01/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/workspace%20-%20Java%20-%20BookManage-src-cn-chenzhiheng-test-Test.java%20-%20Eclipse%20Eclipse,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%888.40.13.png" alt></p>
<hr>
<h3 id="最后要做的工作"><a href="#最后要做的工作" class="headerlink" title="最后要做的工作"></a>最后要做的工作</h3><pre><code>1. 表格实现信息修改—完成
2. 管理员图书出库做判断—完成
3. 用户查无此id的
4. 退书应该加上专门的一个现实的表，然后进行点击退书
5. 注册用户的验证
6. 标题</code></pre><hr>
<h3 id="如何学习table，如何了解table如何使用，他又那些功能。"><a href="#如何学习table，如何了解table如何使用，他又那些功能。" class="headerlink" title="如何学习table，如何了解table如何使用，他又那些功能。"></a>如何学习table，如何了解table如何使用，他又那些功能。</h3><pre><code>1. 即使是别人写好的，你也不一定会用！
2. 手册的重要性，这个过程中一定会看大量的文档。
3. 文档的写法基本上也是按照一个个功能，**问题为主导的**。
4. 方便读者寻找自己想要的功能。
5. 这与我写文章的思路正好相符
6. 在这个过程中，有一个很大的问题就是**如何知道有什么功能**，以及会**涉及到其他**的什么类，接口，抽象等等
7. **如何实现其实不是最难的**，**手册**能解决这个问题，但是上面一个问题手册不一定能明显的解决。</code></pre><p>table_3.addTableModelListener(this);<br>就像我不知Jtable中model这个东西一样</p>
<hr>
<p><strong>这回的文件封装的和屎一样</strong></p>
<p>/*<br>                * 这里应该是通过当前用户的权限去更改User.txt文件中的数据<br>                * 但是我在client的接口中没有实现这个方法<br>                * 现在不带了改了<br>                * 所以就直接跳级<br>                * 用底层封装好的文件操作改了<br>                * 这样做是不对的！！！！！<br>         */</p>
<hr>
<h1 id="问题才是一个系统设计的核心！！！！"><a href="#问题才是一个系统设计的核心！！！！" class="headerlink" title="问题才是一个系统设计的核心！！！！"></a>问题才是一个系统设计的核心！！！！</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenzhiheng.cn/2017/07/01/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/01/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">项目结构总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-01 02:43:00" itemprop="dateCreated datePublished" datetime="2017-07-01T02:43:00+08:00">2017-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 16:46:16" itemprop="dateModified" datetime="2020-03-12T16:46:16+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%BC%80%E5%8F%91-czh-java-java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">web开发/czh_java/java基础</span>
                  </a>
                </span>
            </span>

          
            <span id="/2017/07/01/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/" class="post-meta-item leancloud_visitors" data-flag-title="项目结构总结" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>271</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2017年7月1日 下午2:43</p>
<p><img src="/2017/07/01/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/2E829A85D679272CB7FA191FFAE56CD3.png" alt><br>几个原则：<br>    1. 测试类中方法不能太多<br>        1. 解决方法：可以想象这个函数代表的功能是谁的<br>    2. 测试类中主方法太长<br>        1. 用c写的习惯了，100行以内根本不认为多<br>        2. 而java中面向对象，<strong>超过二十行</strong>就觉得有点多了<br>    3. 构造函数顺序：<br>        1. 无参构造<br>        2. 主键构造<br>        3. 带所有参数的构造<br>    4. <strong>注释注释注释注释</strong></p>
<h3 id="各占1-3的时间"><a href="#各占1-3的时间" class="headerlink" title="各占1/3的时间"></a>各占1/3的时间</h3><ol>
<li>需求说明：<ol>
<li>像关心下一代项目就没有需求说明，他想做出来再改</li>
<li>mnt-lab也是这</li>
<li>Report其实也是，那些流程都没有定出来写文档</li>
</ol>
</li>
<li>动手之前的分析占了很长时间：report项目</li>
<li>完成之后的修改也要很长时间：mnt-lab门户项目</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenzhiheng.cn/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">6.30 线程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-30 10:31:00" itemprop="dateCreated datePublished" datetime="2017-06-30T10:31:00+08:00">2017-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 16:46:16" itemprop="dateModified" datetime="2020-03-12T16:46:16+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%BC%80%E5%8F%91-czh-java-java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">web开发/czh_java/java基础</span>
                  </a>
                </span>
            </span>

          
            <span id="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="6.30 线程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2017年6月30日 上午10:31</p>
<p>多线程的好处：<br>    解决了多部分代码同时运行的情况<br>坏处：<br>    每个线程占的资源少，单个线程的效率比较低</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>1.     继承Thread
    1. run()运行代码
    2. start()开启线程：没有开始运行，进入了
    3. 一个线程类对象只能调用一次start()方法</code></pre><p><img src="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/Java17_%E5%A4%9A%E7%BA%BF%E7%A8%8B%20PDF%20Expert,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8A%E5%8D%8810.45.14.png" alt><br>         图1 线程的四种状态（五种：创建，<strong>就绪</strong>，运行，<strong>阻塞</strong>，停止）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="comment">//票的总数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(name+<span class="string">"\t"</span>+num--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建了两个资源</span></span><br><span class="line">		ThreadTest tt = <span class="keyword">new</span> ThreadTest(<span class="string">"线程1"</span>);</span><br><span class="line">		ThreadTest tt1 = <span class="keyword">new</span> ThreadTest(<span class="string">"线程2"</span>);</span><br><span class="line">		<span class="comment">//开启两个线程</span></span><br><span class="line">		tt.start();</span><br><span class="line">		tt1.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/workspace%20-%20Java%20-%20Class630-src-package1-ThreadTest.java%20-%20Eclipse%20Eclipse,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8A%E5%8D%8811.02.17.png" alt></p>
<pre><code>2. 接口Runnable     </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name ;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num =<span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RunnableTest</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建资源</span></span><br><span class="line">		RunnableTest rt = <span class="keyword">new</span> RunnableTest(<span class="string">"线程1"</span>);</span><br><span class="line">		<span class="comment">//同一个资源开两个线程</span></span><br><span class="line">		<span class="keyword">new</span> Thread(rt).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(rt).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(name+<span class="string">"\t"</span>+num--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 输出1<br><img src="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/workspace%20-%20Java%20-%20Class630-src-package1-RunnableTest.java%20-%20Eclipse%20Eclipse,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8A%E5%8D%8811.10.22.png" alt><br> 输出2<br><img src="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/workspace%20-%20Java%20-%20Class630-src-package1-RunnableTest.java%20-%20Eclipse%20Eclipse,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8A%E5%8D%8811.10.40.png" alt></p>
<h2 id="对比-输出1-和-输出2-发现："><a href="#对比-输出1-和-输出2-发现：" class="headerlink" title="对比 输出1 和 输出2 发现："></a>对比 输出1 和 输出2 发现：</h2><pre><code>1. 输出1 一共输出的为11个，10输出了两次
2. 输出2 一共输出了10个，1-10各一次</code></pre><p>总结：<strong>会有特殊情况出现</strong></p>
<h2 id="对比-程序1-和-程序2-发现："><a href="#对比-程序1-和-程序2-发现：" class="headerlink" title="对比 程序1 和 程序2 发现："></a>对比 程序1 和 程序2 发现：</h2><pre><code>1. 实现Runnable接口,方便实现资源共享
2. 继承Thread类受单继承影响，不适合多线程共享资源    
3. 只有Thread才能创建线程对象，Runnable只是实现run()方法
4. **多线程的特点是：**
            1. 一个对象的run()可以同时执行
            2. 多个对象的run()方法也可以同时执行</code></pre><p><img src="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/%E2%80%A2%20StarUML%20StarUML,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%881.11.19.png" alt><br>                              图2：Thread实现方式<br><strong>Thread 的角色：提供资源 + 提供方法 + 运行方法</strong><br><img src="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/%E2%80%A2%20StarUML%20StarUML,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%881.13.06.png" alt><br>                            图3：Runnable实现方式<br><strong>RunnableTest的角色：提供资源 + 提供方法run</strong><br><strong>Thread的角色：调用run</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="comment">//票的总数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(name+<span class="string">"\t"</span>+num--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadTest tt = <span class="keyword">new</span> ThreadTest(<span class="string">"线程1"</span>);</span><br><span class="line">		<span class="comment">//调用两次start，来模仿Thread和Runnable的关系</span></span><br><span class="line">		tt.start();</span><br><span class="line">		tt.start();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/workspace%20-%20Java%20-%20Class630-src-package1-ThreadTest.java%20-%20Eclipse%20Eclipse,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%883.57.11.png" alt></p>
<h2 id="通过这个例子来理解Runnable-和-Thread的不同："><a href="#通过这个例子来理解Runnable-和-Thread的不同：" class="headerlink" title="通过这个例子来理解Runnable 和 Thread的不同："></a>通过这个例子来理解Runnable 和 Thread的不同：</h2><pre><code>1. Thread的run方法不能让同一个对象同时调用进行，但，可以不同对象之间进行
2. Runnable 的run方法可以被同一个对象同时调用
3. 那么，在thread中，如果强制调用tt.start()两次，就类似于runnable调用两次start()，会发生什么呢？很可惜，因为start()方法是synchronized的（如图5），所以只能支持Runnable的两次（图7），不支持Thread的两次（图6）。</code></pre><p><img src="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/workspace%20-%20Java%20-%20java.lang.Thread%20-%20Eclipse%20Eclipse,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%884.40.16.png" alt><br>                                    图5<br><img src="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/Bear%20Bear,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%885.01.50.png" alt><br>                                    图6<br><img src="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/Bear%20Bear,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%885.02.11.png" alt><br>                                     图7</p>
<h2 id="Thread的方法："><a href="#Thread的方法：" class="headerlink" title="Thread的方法："></a>Thread的方法：</h2><ol>
<li>Static Thread currentThread()</li>
<li>Final String getName()</li>
<li>Final void setPriority();设置优先级</li>
<li>Void start()</li>
<li>Static void sleep()  让出执行权，不让出资源</li>
<li>Final void yield()暂停当前线程，让其他线程(大家同一个起跑线) 礼让</li>
<li>void run()执行线程</li>
</ol>
<h2 id="线程方法-object方法"><a href="#线程方法-object方法" class="headerlink" title="线程方法 + object方法"></a>线程方法 + object方法</h2><p><img src="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/Java17_%E5%A4%9A%E7%BA%BF%E7%A8%8B%20PDF%20Expert,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%884.27.18.png" alt></p>
<h2 id="同步的前提："><a href="#同步的前提：" class="headerlink" title="同步的前提："></a>同步的前提：</h2><ol>
<li>两个或两个以上的线程</li>
<li>多个线程使用同一资源<ol>
<li><strong>（必须用Runnable）或者 （Thread+ static资源变量）</strong></li>
</ol>
</li>
</ol>
<h2 id="同步的概念："><a href="#同步的概念：" class="headerlink" title="同步的概念："></a>同步的概念：</h2><ol>
<li>回去判断每个线程上的锁，浪费资源</li>
<li>同一个时间只能运行一个线程</li>
<li>同步可以解决线程中的安全问题</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name ;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadTest2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadTest2 tt = <span class="keyword">new</span> ThreadTest2(<span class="string">"线程"</span>);</span><br><span class="line">		tt.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//			Thread.currentThread().yield();</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码使用<br>    1. Thread.currentThread ().sleep 实现休眠<br>    2. Thread.currentThread().yield() 实现礼让</p>
<h2 id="同步代码块-同步方法"><a href="#同步代码块-同步方法" class="headerlink" title="同步代码块 同步方法"></a>同步代码块 同步方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num  = <span class="number">10</span> ;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//这里要死循环 或者 循环判断 </span></span><br><span class="line">		<span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (RunnableTest2<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+num--);</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//			sail();//两种方法的交换</span></span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sail</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+num--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		RunnableTest2 rt = <span class="keyword">new</span> RunnableTest2();</span><br><span class="line">		<span class="keyword">new</span> Thread(rt).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(rt).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(rt).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(rt).start();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步代码块-同步方法的区别："><a href="#同步代码块-同步方法的区别：" class="headerlink" title="同步代码块 同步方法的区别："></a>同步代码块 同步方法的区别：</h2><pre><code>1. 上面的代码包含的两种方法，通过注释来更换
2.  他们两种没有功能上的区别，可以相互替换
3. 写成方法可以更加灵活，因为可以分块写，不用写成一块了</code></pre><h2 id="同步的死锁："><a href="#同步的死锁：" class="headerlink" title="同步的死锁："></a>同步的死锁：</h2><p><img src="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%20%E7%BA%BF%E7%A8%8B/Java17_%E5%A4%9A%E7%BA%BF%E7%A8%8B%20PDF%20Expert,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%883.25.21.png" alt><br>理解：<br>    1. 爸：我要你的成绩单<br>    2. 儿：我要玩具<br>    3. 爸：你先给我成绩单！<br>    4. 儿：不！你先给我玩具！<br>    5. 两个人怒目相对，谁都不给谁，就相互看着…….</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这里是static，原因：</span></span><br><span class="line"><span class="comment">	 * 我在执行的时候初始化了两个LockRunnable对象，那么就会生成两套资源</span></span><br><span class="line"><span class="comment">	 * 也就是有 两个成绩单  和 两个玩具</span></span><br><span class="line"><span class="comment">	 * 所以，要通过static来保证只有 一个成绩单 和 一个玩具</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();<span class="comment">//表示玩具</span></span><br><span class="line">	<span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();<span class="comment">//表示成绩单</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(flag);<span class="comment">//如果1 表示家长</span></span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (o1) &#123;<span class="comment">//我现在要占用o1了，很幸运还在，我就把它拿走了，然后我接的执行</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">synchronized</span> (o2) &#123;<span class="comment">//我现在要占用o2了，但是发现不在有人拿着，我就等着！</span></span><br><span class="line">					System.out.println(<span class="string">"可以给你玩具了"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">					System.out.println(<span class="string">"可以给成绩单"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//这里是两个资源对象，所以要声明称static类型</span></span><br><span class="line">		LockRunnable t1 = <span class="keyword">new</span> LockRunnable();</span><br><span class="line">		t1.flag =<span class="number">1</span> ;</span><br><span class="line">		LockRunnable t2 = <span class="keyword">new</span> LockRunnable();</span><br><span class="line">		t2.flag =<span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(t2).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在上面的代码中注意："><a href="#在上面的代码中注意：" class="headerlink" title="在上面的代码中注意："></a>在上面的代码中注意：</h2><pre><code>1. 正确理解synchronize的意思：
    1. **用在方法时，这个方法不能被同一个对象同时调用**
    2. 用在块时，（）里的为需要站用的资源，根据这个进行判断
2.  为什么要使用static
3. 注意这里产生了两个LockRunnable资源对象，一个代表父亲，一个代表儿子</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenzhiheng.cn/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/" class="post-title-link" itemprop="url">6.30生产者消费者</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-30 05:09:00" itemprop="dateCreated datePublished" datetime="2017-06-30T05:09:00+08:00">2017-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 16:46:16" itemprop="dateModified" datetime="2020-03-12T16:46:16+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%BC%80%E5%8F%91-czh-java-java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">web开发/czh_java/java基础</span>
                  </a>
                </span>
            </span>

          
            <span id="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/" class="post-meta-item leancloud_visitors" data-flag-title="6.30生产者消费者" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2017年6月30日 下午5:09</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//馒头类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SteamBread</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id;<span class="comment">//馒头编号</span></span><br><span class="line"></span><br><span class="line">	SteamBread(<span class="keyword">int</span> id)&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"steamBread:"</span>+id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装馒头的框，栈结构</span><span class="class"><span class="keyword">class</span> <span class="title">SyncStack</span></span>&#123;	<span class="keyword">int</span> index = <span class="number">0</span>;	SteamBread[] stb = <span class="keyword">new</span> SteamBread[<span class="number">6</span>];<span class="comment">//构造馒头数组，相当于馒头筐，容量是6</span>		<span class="comment">//放入框中，相当于入栈</span>	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(SteamBread sb)</span></span>&#123;		<span class="keyword">while</span>(index==stb.length)&#123;<span class="comment">//筐满了，即栈满，</span>			<span class="keyword">try</span> &#123;				<span class="keyword">this</span>.wait();<span class="comment">//让当前线程等待</span>			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;				<span class="comment">// TODO Auto-generated catch block</span>				e.printStackTrace();			&#125;		&#125;		<span class="keyword">this</span>.notify();<span class="comment">//唤醒在此对象监视器上等待的单个线程，即消费者线程</span>		stb[index] = sb;		<span class="keyword">this</span>.index++;	&#125;		<span class="comment">//从框中拿出，相当于出栈</span>	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> SteamBread <span class="title">pop</span><span class="params">()</span></span>&#123;		<span class="keyword">while</span>(index==<span class="number">0</span>)&#123;<span class="comment">//筐空了，即栈空</span>			<span class="keyword">try</span> &#123;				<span class="keyword">this</span>.wait();			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;				<span class="comment">// TODO Auto-generated catch block</span>				e.printStackTrace();			&#125;		&#125;		<span class="keyword">this</span>.notify();		<span class="keyword">this</span>.index--;<span class="comment">//push第n个之后，this.index++，使栈顶为n+1，故return之前要减一</span>		<span class="keyword">return</span> stb[index];	&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者类，实现了Runnable接口，以便于构造生产者线程</span><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;	SyncStack ss = <span class="keyword">null</span>;	Producer(SyncStack ss)&#123;		<span class="keyword">this</span>.ss = ss;	&#125;	<span class="meta">@Override</span>	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;		<span class="comment">// 开始生产馒头</span>		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;			SteamBread stb = <span class="keyword">new</span> SteamBread(i);			ss.push(stb);			System.out.println(<span class="string">"生产了"</span>+stb);			<span class="keyword">try</span> &#123;				Thread.sleep(<span class="number">10</span>);<span class="comment">//每生产一个馒头，睡觉10毫秒</span>			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;				<span class="comment">// TODO Auto-generated catch block</span>				e.printStackTrace();			&#125;		&#125;	&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者类，实现了Runnable接口，以便于构造消费者线程</span><span class="class"><span class="keyword">class</span> <span class="title">Consume</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;	SyncStack ss = <span class="keyword">null</span>;	<span class="function"><span class="keyword">public</span> <span class="title">Consume</span><span class="params">(SyncStack ss)</span> </span>&#123;		<span class="keyword">super</span>();		<span class="keyword">this</span>.ss = ss;	&#125;	<span class="meta">@Override</span>	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;		<span class="comment">// TODO Auto-generated method stub</span>		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;<span class="comment">//开始消费馒头</span>			SteamBread stb = ss.pop();			System.out.println(<span class="string">"消费了"</span>+stb);			<span class="keyword">try</span> &#123;				Thread.sleep(<span class="number">100</span>);<span class="comment">//每消费一个馒头，睡觉100毫秒。即生产多个，消费一个</span>			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;				<span class="comment">// TODO Auto-generated catch block</span>				e.printStackTrace();			&#125;		&#125;	&#125;	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;<span class="comment">//主类</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceConsume</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		SyncStack ss = <span class="keyword">new</span> SyncStack();<span class="comment">//建造一个装馒头的框</span>		Producer p = <span class="keyword">new</span> Producer(ss);<span class="comment">//新建一个生产者，使之持有框</span>		Consume c = <span class="keyword">new</span> Consume(ss);<span class="comment">//新建一个消费者，使之持有同一个框</span>		Thread tp = <span class="keyword">new</span> Thread(p);<span class="comment">//新建一个生产者线程</span>		Thread tc = <span class="keyword">new</span> Thread(c);<span class="comment">//新建一个消费者线程</span>		tp.start();<span class="comment">//启动生产者线程</span></span><br><span class="line">		tc.start();<span class="comment">//启动消费者线程</span>	&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何思考："><a href="#如何思考：" class="headerlink" title="如何思考："></a>如何思考：</h2><pre><code>1. 根据我对算法的总结“先生活例子，然后提取概括，后算法实现”的思路
2. 我们先想这几个问题：
    1. 堆栈空了怎么办：消费者停止消费
    2. 堆栈满了怎么办：生产者停止生产
    3. 那么：我们既然要实现停止的功能，这时就得想到**线程**
    4. 因为：如果不用runnable，那么方法执行其不可控，只能一次执行完，或者出错一般的改写
3. 如果生产和消费同时进行怎么办：**sync**
4. 如何保证只用一个栈呢：**引用传参**
5. 容易忽略的问题：
    1. 既然生产和消费者都能停止，那么何时唤醒呢？
    2. 这个问题关键不是如何解决，而是注意到这个问题。
    3. **结论：等待 唤醒成对出现**
    4. **生产的时候唤醒消费，消费的时候唤醒生产**
    5. **生产暂停生产 ，消费暂停生产**
6. 实现：
    1. 先馒头 -&gt; 栈 -&gt; 生产者 -&gt; 消费者 -&gt; 总类</code></pre><h2 id="总结讨论："><a href="#总结讨论：" class="headerlink" title="总结讨论："></a>总结讨论：</h2><pre><code>1. 在这个实下中**一个消费者 ，一个生产者 ，一个栈**
2. 如果同一个消费者执行多次start()，同一个消费者也执行多次start()呢（图1）？</code></pre><p><img src="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/Bear%20Bear,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%885.41.24.png" alt><br>                                图1<br>    这时还是共享一个资源<br>    3. 如果多个消费者，多个生产者呢（图2）<strong>并且在生产者消费中将栈都声明为static</strong>？<br><img src="/2017/06/30/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.30%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/Bear%20Bear,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%885.46.26.png" alt><br>                                图2<br>    这时还是共享一个资源<br>    4. 如果多个消费者，多个生产者呢，但是却<strong>不将生产者消费中将栈声明为static</strong>？<br>        1. 这时，两个消费者使用不同的资源，两个消费也使用不同的资源<br>        2. 但是，由于是引用类型，本质内存中只有一个资源空间<br>        3. 程序就乱了！！！！！</p>
<p><strong>注：在多线程中，虽然我们使用了多线程，但是其实一个具体的时刻还是只有一个线程运行，变得只是这些各自的多线程会走走停停，交互运行</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenzhiheng.cn/2017/06/29/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.29%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/29/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.29%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">6.29数组</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-29 12:09:00" itemprop="dateCreated datePublished" datetime="2017-06-29T12:09:00+08:00">2017-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 16:46:16" itemprop="dateModified" datetime="2020-03-12T16:46:16+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%BC%80%E5%8F%91-czh-java-java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">web开发/czh_java/java基础</span>
                  </a>
                </span>
            </span>

          
            <span id="/2017/06/29/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.29%E6%95%B0%E7%BB%84/" class="post-meta-item leancloud_visitors" data-flag-title="6.29数组" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2017年6月29日 下午12:09</p>
<h2 id="第一个部分：数组定义"><a href="#第一个部分：数组定义" class="headerlink" title="第一个部分：数组定义"></a>第一个部分：数组定义</h2><p>定义的方法：<br>    1.  int num[]= new int[10];必须说明长度 int初始化为0<br>    2.  int []num;<br>     num=new int[5]<br>    3.  int num[]=new int[]{1,2,3,4}<br>    4.  int num[]={1,2,4,5,6,7}<br>     String string1[] = {“1”,”2”};</p>
<p>长度方面的错：<br>    1. String str[] = new String[];不能不说明长度<br>    2. int num[10];编译出错   说明长度情况下，必须要有指向的内容<br>    3. String str[] = new String[3]{“1”,”2”,”3”}; 编译错</p>
<p>先定义后初始化（一对三错）：<br>    String str[];<br>    str = new String[]{“1”,”2”};对</p>
<pre><code>String str[];
str[] = new String[]{&quot;1&quot;,&quot;2&quot;};错

String str[];
str = {&quot;1&quot;,&quot;2&quot;};错

int str[];
str ={1,2};错</code></pre><p>总结：分开只能按1写</p>
<h2 id="第二部分：局部-and-全局-基本类型-and-对象类型-数组-and-非数组"><a href="#第二部分：局部-and-全局-基本类型-and-对象类型-数组-and-非数组" class="headerlink" title="第二部分：局部 and 全局    基本类型 and  对象类型   数组 and 非数组"></a>第二部分：局部 and 全局    基本类型 and  对象类型   数组 and 非数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> Student student[] = <span class="keyword">new</span> Student[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">static</span> String string[] = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">static</span> Student student2[] = <span class="keyword">new</span> Student[]&#123;<span class="keyword">new</span> Student(),<span class="keyword">new</span> Student()&#125;;</span><br><span class="line">	<span class="keyword">static</span> String string2[] = <span class="keyword">new</span> String[]&#123;<span class="keyword">new</span> String(),<span class="keyword">new</span> String()&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(student.length);<span class="comment">//new Student[10] 定义长度</span></span><br><span class="line">		System.out.println(student[<span class="number">0</span>]);<span class="comment">//但是没在堆中定义空间</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(string.length);</span><br><span class="line">		System.out.println(string[<span class="number">0</span>]);<span class="comment">//但是没在堆中定义空间</span></span><br><span class="line">	</span><br><span class="line">		System.out.println(student2.length);</span><br><span class="line">		System.out.println(student2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">		System.out.println(string2.length);</span><br><span class="line">		System.out.println(string2[<span class="number">0</span>]);<span class="comment">//这里输出的是""打印出来为空</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">null</span><br><span class="line">10</span><br><span class="line">null</span><br><span class="line">2</span><br><span class="line">package1.Student@677327b6</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>[“”]自己加的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">		Student student[] = <span class="keyword">new</span> Student[<span class="number">10</span>];</span><br><span class="line">		System.out.println(student.length);<span class="comment">//new Student[10] 定义长度</span></span><br><span class="line">		System.out.println(student[<span class="number">0</span>]);<span class="comment">//但是没在堆中定义空间</span></span><br><span class="line">		</span><br><span class="line">		String string[] = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">		System.out.println(string.length);</span><br><span class="line">		System.out.println(string[<span class="number">0</span>]);<span class="comment">//但是没在堆中定义空间</span></span><br><span class="line">		</span><br><span class="line">		Student student2[] = <span class="keyword">new</span> Student[]&#123;<span class="keyword">new</span> Student(),<span class="keyword">new</span> Student()&#125;;</span><br><span class="line">		System.out.println(student2.length);</span><br><span class="line">		System.out.println(student2[<span class="number">0</span>]);</span><br><span class="line">		</span><br><span class="line">		String string2[] = <span class="keyword">new</span> String[]&#123;<span class="keyword">new</span> String(),<span class="keyword">new</span> String()&#125;;</span><br><span class="line">		System.out.println(string2.length);</span><br><span class="line">		System.out.println(string2[<span class="number">0</span>]);<span class="comment">//这里输出的是""打印出来为空</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//Student String 数组是完全一样的 </span></span><br><span class="line">		<span class="comment">//除了new的默认值以外，String的默认值是"" Student默认值为包名+地址</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">null</span><br><span class="line">10</span><br><span class="line">null</span><br><span class="line">2</span><br><span class="line">package1.Student@677327b6</span><br><span class="line">2</span><br><span class="line">[“”]自己加的</span><br></pre></td></tr></table></figure>

<p>发现：<br>        1. 他们的输出是一样的，说明局部变量的概念对数组无效</p>
<p><img src="/2017/06/29/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.29%E6%95%B0%E7%BB%84/workspace%20-%20Java%20-%20Class629-src-package1-Test4.java%20-%20Eclipse%20Eclipse,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%8812.10.44.png" alt><br>                                    图1：对象声明为局部<br><img src="/2017/06/29/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.29%E6%95%B0%E7%BB%84/workspace%20-%20Java%20-%20Class629-src-package1-Test5.java%20-%20Eclipse%20Eclipse,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%8812.11.02.png" alt><br>                                    图2：对象声明为全局<br>发现：<br>        1. 对于非数组对象（单个对象），局部变量概念有效</p>
<p>加入基本类型后：<br>    1. 局部中：<br>                                     基本类型            对象类型<br>        数组（只定义长度）                0                    null<br>         <del>非数组（只对象声明）                   错                     错</del><br>    3. 全局中：<br>                                     基本类型            对象类型<br>        数组（只定义长度）                0                    null<br>        <del>非数组（只对象声明）                        0                    null</del>     </p>
<p>总结：<br>    对于数组类型： 基本类型是0，对象类型为null<br>    对于非数组：局部中一定错 ，全局中 0 和 null</p>
<h2 id="String-和-Student的区别（单个对象-以初始化）"><a href="#String-和-Student的区别（单个对象-以初始化）" class="headerlink" title="String 和  Student的区别（单个对象+以初始化）"></a>String 和  Student的区别（单个对象+以初始化）</h2><pre><code>1. String的默认值是&quot;&quot; ，Student默认值为包名+地址
2. 其他的，Student String 数组是完全一样的 </code></pre><p>注：注意前提为以初始化</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenzhiheng.cn/2017/06/29/web%E5%BC%80%E5%8F%91/czh_java/6.15-6.27%E9%87%8D%E7%82%B9%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/29/web%E5%BC%80%E5%8F%91/czh_java/6.15-6.27%E9%87%8D%E7%82%B9%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">6.15-6.27重点总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-29 10:12:00" itemprop="dateCreated datePublished" datetime="2017-06-29T10:12:00+08:00">2017-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 16:46:18" itemprop="dateModified" datetime="2020-03-12T16:46:18+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%BC%80%E5%8F%91-czh-java/" itemprop="url" rel="index">
                    <span itemprop="name">web开发/czh_java</span>
                  </a>
                </span>
            </span>

          
            <span id="/2017/06/29/web%E5%BC%80%E5%8F%91/czh_java/6.15-6.27%E9%87%8D%E7%82%B9%E6%80%BB%E7%BB%93/" class="post-meta-item leancloud_visitors" data-flag-title="6.15-6.27重点总结" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2017年6月29日 上午10:12</p>
<h2 id="java的命名首字符"><a href="#java的命名首字符" class="headerlink" title="java的命名首字符"></a>java的命名首字符</h2><p>可以是字符，下划线，$。不可以是关键字，保留字，%等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int $1&#x3D; 1;int _1 &#x3D; 1;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>正文内容：类型转换向大的类型转换。<br>Eg:<br>        1. char sex = 12 + ‘c’;1.7不会报错，但是不能超过char的容量和ASSIC<br>        2. int  age = 20 ;<br>            char sex = age + ‘c’;编译错<br>        3. int age = (int)1234566789;运行报错out of range 不能抢转<br>        4. boolean yes = 1 ; 编译错</p>
<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><pre><code>1. int n2 = 01;八进制
2. int n3 = 0x1;16进制 </code></pre><h2 id="switch注意事项"><a href="#switch注意事项" class="headerlink" title="switch注意事项"></a>switch注意事项</h2><pre><code>1. dk1.6中switch不可以字符串 ，double 都不支持
2. 条件-确定区间的开头，break决定退出
3. 不要少break
4. 于if的不同：
    1. switch 可以转换成if ，但是if不一定能转成switch
    2. switch 有类型的限制，而if没有</code></pre><h2 id="for-和-switch连用，break和continue的特点"><a href="#for-和-switch连用，break和continue的特点" class="headerlink" title="for 和 switch连用，break和continue的特点"></a>for 和 switch连用，break和continue的特点</h2><ol>
<li>break不是跳出for而是跳出switch</li>
<li>continue和if中的一样，后面的不执行了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i &#x3D;  0; i &lt;&#x3D; 10 ;i++)&#123;	switch(2)&#123;		case 1:			System.out.println(&quot;1&quot;);			continue;		case 2:			System.out.println(&quot;2&quot;);			break;	&#125;	System.out.println(&quot;3&quot;);&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>null是没有空间的</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><pre><code>1. 包名小写 
2. 不以.为开头 
3. ；结尾</code></pre><h2 id="String-的使用"><a href="#String-的使用" class="headerlink" title="String 的使用"></a>String 的使用</h2><pre><code>1. java.lang包
2. String str = &quot;&quot;;长度为0
3. String str = &quot; &quot;;长度为1
4. 中文的长度也是1
5. String类是final类
6. == 内存池
7. equals()的比较原理 一个个字符的比较
8. == 比较是不是相同的地址，内存的首地址

大小写转换</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toLowerCase()toUpperCase()equalsIgnoreCase()</span><br></pre></td></tr></table></figure>

<pre><code>A.concat(B);B接到A后面</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;你好&quot;;String name &#x3D;&quot;张三&quot;;String sen &#x3D; s1.concat(name);；不影响s1的值s1 &#x3D; s1.concat(name);;这个才影响s1的值</span><br></pre></td></tr></table></figure>

<pre><code>提取下标1：返回第一个匹配的位置</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indexOf(int ch);indexOf(String value);lastIndexOf(int ch)lastIndexOf(String value)</span><br></pre></td></tr></table></figure>

<pre><code>提取内容2：返回字符串的一部分</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subString(int index);subString(int index_start,int index_end);包括start不包括endtirm();清楚前后空格，重新产生对象，不影响本身</span><br></pre></td></tr></table></figure>
<pre><code>替换</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace()-&gt;替换replace</span><br></pre></td></tr></table></figure>

<pre><code>转换类型：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.valueOf() -&gt; 字符串 -&gt; toCharArray()			           -&gt; charAt()</span><br></pre></td></tr></table></figure>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><pre><code>1. 栈区：编译器自动分配释放
        1. 存放函数值+局部变量
2. 堆：有程序员new分配释放，若程序员不释放，程序结束时os释放     
3. 全局区：全局变量+静态变量  放在堆中初始化之后放在一起，没有初始化的放在旁边的一块区域。程序结束后系统释放
4. 文字常量区：“abc”
5. 程序代码区：</code></pre><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void print(int a , String b);public void print(String a,int b);&#x2F;&#x2F;是重载public void print(int a ,int b);public void print(int b,int a);&#x2F;&#x2F;不是重载</span><br></pre></td></tr></table></figure>

<pre><code>重载的条件
1. 同一个类中
2. 参数列表不同
3. 方法名相同
4. 和返回值，访问修饰符无关

override 重写
overlad 重载</code></pre><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static  三种用途<br>            1. 属性  在堆中   位置：全局变量+static方法中<br>            2. 静态块 常用去提前配置 （可以把括号理解成一种简写方式）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &#123;	syso(&quot;*************&quot;)&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 方法</code></pre><p>不能直接访问非静态的方法+成员变量(也不能定义)<br>可以通过 对象. 去访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void play()&#123;	static int local &#x3D; 5;    错&#125;</span><br></pre></td></tr></table></figure>

<h2 id="char于int的关系"><a href="#char于int的关系" class="headerlink" title="char于int的关系"></a>char于int的关系</h2><p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char x&#x3D; 100;	System.out.println(x);&#x2F;&#x2F;dSystem.out.println(x + 0);&#x2F;&#x2F;100int y &#x3D; 100;System.out.println(y);&#x2F;&#x2F;100System.out.println((char)y);&#x2F;&#x2F;d</span><br></pre></td></tr></table></figure>

<pre><code>输出：
    d
    100
    100
    d

总结：他们内存本质是一样的，唯二的区别是
        1. int是16位，char是8位
        2. 输出时的方式不同</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenzhiheng.cn/2017/06/29/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.15~6.27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/29/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.15~6.27/" class="post-title-link" itemprop="url">6.15~6.27</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-29 09:08:00" itemprop="dateCreated datePublished" datetime="2017-06-29T09:08:00+08:00">2017-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 16:46:16" itemprop="dateModified" datetime="2020-03-12T16:46:16+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%BC%80%E5%8F%91-czh-java-java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">web开发/czh_java/java基础</span>
                  </a>
                </span>
            </span>

          
            <span id="/2017/06/29/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.15~6.27/" class="post-meta-item leancloud_visitors" data-flag-title="6.15~6.27" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2017年6月29日 上午9:08</p>
<p>1.文档注释<br>    接口，dao,biz,service中类的说明方法及方法写文档注释<br>2.java的八大数据基本数据类型<br>3.num + num + String =<br>  String + num + num =<br>  num+char=num<br>4.命名首字符：字符 下划线 $<br>    不可以关键字 保留字 %<br>5.定义变量的两种形式<br>========================6 16 数据类型  =======================<br>1.类型转换，向大的类型转换<br>    char sex = 12 + ‘c’;1.7不会报错，但是不能超过char的容量和ASSIC    </p>
<pre><code>int  age = 20 ;
char sex = age + ‘c&apos;;会报错

当大的类型转小的类型，要强制转换</code></pre><p>2.long 型(64)  l or L<br>  short(16)<br>3.int age = (int)1234566789;报错 不能抢转<br>4.boolean yes = 1 ; 报错<br>5.运算优先级  算数 比较 || ！<br>6.int n1=1;<br>    int n2 = 01;八进制<br>    int n3 = 0x1;16进制<br>7.String name1 = “abc”;<br>    String name2 = “abc”;相等  这里的“abc”是把上一句定义的额拿出来用</p>
<pre><code>String name3 = new String(&quot;abc&quot;);
String name4 = new String(&quot;abc&quot;); 不相等</code></pre><p>8.流程图<br>9.jdk1.6中switch不可以字符串 ，double 都不支持<br>    条件-确定区间的开头，break决定退出<br>    不要少break<br>    于if的不同：<br>        switch 可以转换成if ，但是if不一定能转成switch<br>        switch 有类型的限制，而if没有<br>10.循环的流程图</p>
<p>=======================6.19 循环==========================<br>1.for(;;){}<br>2.for(;;i++,j++) 从左到右<br>3.for(){<br>    switch(){<br>        case 11:<br>            ;<br>            continue;作用和break一样<br>    }<br>}<br>4.while 里面不能用continue<br>5.记录错误<br>6.<br>    int count=0;                                          第1行<br>    int x[ ] = new int[10];                          第2行<br>    for(int i = 0; i &lt; 5;i++){                       第3行<br>         count++;                                        第4行<br>         i++;                                                 第5行<br>     }                                                     第6行<br>     System.out.println(x[5]);                   第7行</p>
<ol start="7">
<li><p>int n;<br>double s;<br>s=1.0;<br>for(n=10;n&gt;1;n–){<br>   s=s+1.0/n;<br>}<br>System.out.println(s);</p>
</li>
<li><p>String s;<br>System.out.println(s);<br>局部变量初始化<br>=========================6.20==========================</p>
</li>
<li><p>数组长度固定，不是基本类型，是引用类型。<br>  数组会赋初值</p>
</li>
<li><p>两种赋值方式<br>  2.1int num[]= new int[10];必须说明长度 int初始化为0</p>
<p>  2.2<br>  int []num;<br>  num=new int[5]</p>
<p>  2.3<br>  int num[]=new int[]{1,2,34}<br>  String str[]= new String[]{“”,””} 赋值空字符串</p>
<p>  错的<br>  String str[] = new String[];<br>  str[]={}这个必须写成两行，不能单独写{}</p>
<p>  String classes[] = new String[3]{“c#”,”java”,”php”};长度不能定义两次</p>
</li>
</ol>
<p>3.异常yarrayIndexOutOFBoundsException为运行时异常<br>4.arrays.sort(数组名)<br>    正序 逆序<br>5.求最大值 最小值时 要先获取值完之后 才假设最大值and最小值，否则会出错。<br>    他会将你附的那个值也参与比大小。<br>    index = 0 ;<br>    输入；<br>    比较；<br>    如果这里的输入全是负值，那么最大值就是一开始附的0</p>
<p>6.if (a = b) 编译错<br>7.String s;<br>    System.out.println(s); 编译错<br>8.\r 光标最前<br>9.思路：因为层数是确定的，所以所有的规律都要找于层数的关系，也就是与i的关系【找去已知条件的关系】</p>
<p>==================== ==6.21 ==========================<br>1.成员变量 局部变量的位置<br>2.封装 继承 多态的english<br>    encapsulation 封装<br>    Inheritance 继承<br>    Polymorphism 多态<br>3.及时保存<br>4.oo   Object Oriented<br>5.return;<br>6.    Admin admin[] = new Admin[10];<br>    for(int  i = 0;i &lt; admin.length;i++){<br>        admin[i]= new Admin();<br>    }<br>    单独第一句会报空指针异常，因为初始值为null<br>7.public String toString()重写，在syso输出对象的时候为toString（）方法内容。如果没有重写，那么输出对象的类名和地址等<br>8.同一个包里的class不用import直接就可以生成对象<br>9.实例方法=必须通过对象来调用的方法  实例=对象<br>10。实例 = 对象 抽象=类   对象和类的关系<br>11.实例方法在一个类中可以直接调用 不用this就可以<br>     而，不同类之间的调用必须先声明对象，在调用<br>12.不能return 两个变量。<br>    return a,b;错<br>13.不能函数之外直接写逻辑，逻辑必须写在函数中<br>14.<br>    String.valueOf();  其他所有类型转 String<br>    str.toCharArray(); str转char[]<br>15. int num[] = {1,2,3,4,5} 对的<br>16.字符转数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String  string = scan.next();</span><br><span class="line"><span class="keyword">char</span> ch[]= string.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span> ;i &lt; ch.length;i++)&#123;</span><br><span class="line">	System.out.println(ch[i]-<span class="number">48</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>字符1 -48 = 数字1</code></pre><p>========================6.22=========================<br>1.int num[][]= new int[3][];<br>2.scan.nextLine() scan.next()的区别<br>        can.nextLine():读的是行为单位<br>        scan.next()：一空白符为单位<br>3.String 于 普通对象的对比</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">		String string = <span class="keyword">new</span> String();</span><br><span class="line">		System.out.println(string);</span><br><span class="line"><span class="comment">//		System.out.println(string.equals(""));</span></span><br><span class="line">		</span><br><span class="line">		StudentBiz stu1 = <span class="keyword">new</span> StudentBiz();</span><br><span class="line">		System.out.println(stu1);</span><br><span class="line">		</span><br><span class="line">		String str[]= <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">		System.out.println(str[<span class="number">0</span>]);</span><br><span class="line">		</span><br><span class="line">		StudentBiz stu2[] = <span class="keyword">new</span> StudentBiz[<span class="number">10</span>];</span><br><span class="line">		System.out.println(stu2[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<pre><code>输出：

    StudentBiz@6f94fa3e
    null
    null</code></pre><p>4.null是没有空间的<br>5.java中的包名小写 + 不以.为开头 + ；<br>6.        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Student student  = <span class="keyword">new</span> Student();</span><br><span class="line">Student stu[] = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">	student.name = scanner.next();</span><br><span class="line">	stu[i]=student;</span><br><span class="line">	System.out.println(stu[i].name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">	System.out.println(stu[i].name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scanner.close();</span><br></pre></td></tr></table></figure>
<pre><code>解释：真正的空间就一个 new Student();
       其他的 student+stu[] 其实就是一个指针。
        多个指针指向为一个的一个空间，当然会造成所谓的“覆盖”</code></pre><p>========================6.23============================<br>1.String 的使用<br>    java.lang包<br>    String str = “”;长度为0<br>    String str = “ “;长度为1<br>    中文的长度也是1<br>    String类是final类<br>    == 内存池</p>
<pre><code>栈区：编译器自动分配释放
    存放函数值+局部变量
堆：有程序员new分配释放，若程序员不释放，程序结束时os释放

全局区：全局变量+静态变量  放在堆中初始化之后放在一起，没有初始化的放在旁边的一块区域。程序结束后系统释放
文字常量区：“abc”
程序代码区：

equals()的比较原理 一个个字符的比较
== 比较是不是相同的地址，内存的首地址

toLowerCase()
toUpperCase()
equalsIgnoreCase()


A.concat(B);B接到A后面
String s1 = &quot;你好&quot;;
String name =&quot;张三&quot;;
String sen = s1.concat(name);
；不影响s1的值
s1 = s1.concat(name);
;这个才影响s1的值

提取方法：返回第一个匹配的位置
    indexOf(int ch);
    indexOf(String value);

    lastIndexOf(int ch)
    lastIndexOf(String value)

提取：返回字符串的一部分
    subString(int index);
    subString(int index_start,int index_end);包括start不包括end
    tirm();清楚前后空格，重新产生对象，不影响本身

str.replace()-&gt;替换replace

转：
str.valueOf() -&gt; 字符串  -&gt; toCharArray()
                     -&gt; charAt()</code></pre><p>2.int num[10];编译出错   说明长度情况下，必须要有指向的内容<br>3.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">	Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">	System.out.println(&quot;请输入用户名&quot;);</span><br><span class="line">	String str1 &#x3D; scan.next();</span><br><span class="line">	Verify(str1,str2,str3);</span><br><span class="line">	System.out.println(&quot;str1:&quot;+str1);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void Verify(String str1,String str2,String str3)&#123;</span><br><span class="line">	str1 &#x3D; &quot;acb&quot;;</span><br><span class="line">	System.out.println(&quot;str1:&quot;+str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<pre><code>请输入用户名
abc
str1:acb
str1:abc

总结：verify（）的参数 就是指针 而不是真正的对象。
    基本类型数组</code></pre><p>？4.c++中对象 指针<br>5.String ,StringBuffer ,StringBuilder<br>   StringBuffer<br>        1. toString();<br>        2. insert();<br>        3. append();<br>6.String str[] = new String[3]{“1”,”2”,”3”}; 编译错<br>7.temp = input3.split(‘-‘);错<br>    参数是字符串，而不是字符<br>    总结：看eclipse的提示<br>8:java string类型最后是没有’\n’的，这与c++不同<br>9：bat 批处理<br>？10：在做完项目之后，我们要进行项目总结，自己当初如何分析的，有没有可以改进的地方<br>？11：面向对象的抽象<br>？12:设计模式<br>13:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Dog()&#123;</span><br><span class="line">	</span><br><span class="line">&#125;&#x2F;&#x2F;当写了构造方法之后，就得加上空的构造方法了额</span><br><span class="line">public Dog(String name,int health,int love,String dif)&#123;</span><br><span class="line">	this.name &#x3D; name;</span><br><span class="line">	this.health &#x3D; health;</span><br><span class="line">	this.love &#x3D; love;</span><br><span class="line">	this.dif &#x3D; dif;</span><br><span class="line">&#125;&#x2F;&#x2F;当参数和成员变量同名时，使用this来区分</span><br></pre></td></tr></table></figure>
<p>14：source生成构造方法<br>15:方法的重载<br>16：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void print(int a , String b);</span><br><span class="line">public void print(String a,int b);&#x2F;&#x2F;是重载</span><br><span class="line"></span><br><span class="line">public void print(int a ,int b);</span><br><span class="line">public void print(int b,int a);&#x2F;&#x2F;不是重载</span><br></pre></td></tr></table></figure>

<pre><code>重载的条件
1.同一个类中
2.参数列表不同
3.方法名相同
4.和返回值，访问修饰符无关

override 重写
overload 重载</code></pre><p>17：类名不能直接访问成员变量 要写成static<br>18：static  三种用途<br>        1.属性  在堆中   位置：全局变量+static方法中<br>        2.静态块 常用去提前配置<br>        static {<br>            syso(“*”)<br>        }<br>        3.方法<br>    不能直接访问非静态的方法+成员变量(也不能定义)<br>    可以通过 对象. 去访问</p>
<pre><code>public void play(){
    static int local = 5;    错
}</code></pre><p>19：override：覆写，”实现类”实现了”接口”定义的方法<br>    overwrite：重写，”子类”重新实现了”父类”定义的方法<br>    overload：重载</p>
<p>20：<br>    封装步骤<br>        1.private<br>        2.getter setter方法<br>        3.写逻辑</p>
<p>21:option + command + s = gettter setter<br>    private int a = 0;</p>
<pre><code>public int getA() {
    return a;
}
public void setA(int a) {
    this.a = a;
}</code></pre><p>22:this() 调用构造方法 必须放类的第一句</p>
<p>========================6.23=======================<br>1.<br>    public static void main(String[] args) {<br>        String str=null;<br>        str.concat(“abc”);<br>        str.concat(“def”);<br>        System.out.println(str);<br>    }<br>        A.    输出：null<br>        B.    输出：abcdef<br>        C.    编译错误<br>        D.    运行时出现异常</p>
<pre><code>总结：现在运行时异常一共有两种：
    1.数组越界 2.对象空间为null进行.操作的方法</code></pre><p>2.int num = (int)(Math.random()<em>100);<br>  int num = (int)Math.random()</em>100;<br>  总结：强制转换的优先级高<br>  第二个是先对Math.random 强制转化成int 这就造成了num的值一定为0<br>3.char c = 100;<br>    举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char x&#x3D; 100;	</span><br><span class="line">System.out.println(x);</span><br><span class="line">System.out.println(x + 0);</span><br><span class="line"></span><br><span class="line">int y &#x3D; 100;</span><br><span class="line">System.out.println(y);</span><br><span class="line">System.out.println((char)y);</span><br></pre></td></tr></table></figure>

<pre><code>输出：
    d
    100
    100
    d

总结：他们内存本质是一样的，唯二的区别是
     1.int是16位，char是8位
     2.输出时的方式不同</code></pre><p>4.错题<br>    8)    在Java语言的控制结构中，break语句是经常用到的语句。下面一段代码中break语句起到（A，c）的作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int pointer &#x3D; 0;</span><br><span class="line">while (pointer &lt;&#x3D; 10) &#123;</span><br><span class="line">    switch (pointer % 3) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        pointer +&#x3D; 1;</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        pointer +&#x3D; 2;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        pointer +&#x3D; 3;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>    A.    结束当次循环，使控制权直接转移到控制循环的条件表达式
    B.    从嵌套循环内部跳出最里面的循环
    C.    终止switch语句的语句序列，提高switch-case语句性能
    D.    退出循环
总结：少选了

19)    给定一个Java程序的代码如下所示，则编译运行后，输出结果是（ A）。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    int count &#x3D; 9;</span><br><span class="line">    public void count() &#123;</span><br><span class="line">        System.out.println(&quot;count&#x3D;&quot; + count++);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        new Test().count();</span><br><span class="line">        new Test().count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>    A.    count=9
        count=9
    B.    count=10
        count=9
    C.    count=10
        count=10
    D.    count=9
        count=10
总结：注意到这里是声明了两个互补干扰的对象，他们之间是没有影响的

20)    有关Java中的类和对象，以下说法错误的是（ b）。
    A.    同一个类的所有对象都拥有相同的特征和行为
    B.    类和对象一样，只是说法不同
    C.    对象是具有属性和行为的实体
    D.    类规定了对象拥有的特征和行为
总结：我以为的是:不同对象之间相同的属性但是有不同的值，也算拥有不同的特征

22)    在Java语言中，有如下代码：（b,d）</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch(x) &#123;</span><br><span class="line">    case 100 :</span><br><span class="line">        System.out.println(&quot;One hundred&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 200 :              </span><br><span class="line">        System.out.println(&quot;Two hundred&quot;);                 </span><br><span class="line">        break;</span><br><span class="line">    case 300 :</span><br><span class="line">        System.out.println( &quot;Three hundred&quot;);</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>    下列x的定义中，（ ）可以使得上段代码编译通过。
        A.    double x = 100;
        B.    char x = 100;
        C.    String x = &quot;100&quot;;
        D.    int x = 100;
总结：在switch中 case中的条件类型只能有一种，不能同时又int 或者 String
      但是 int和char是可以同时出现，因为char本身就是int，只是换了一种表现形式</code></pre><p>5.ASCII 有意义的范围是0-127<br>        128-255 也能定义，但输出后像乱码</p>
<pre><code>举例：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char x&#x3D; 230;	</span><br><span class="line">System.out.println(x);</span><br><span class="line">System.out.println(x + 0);</span><br></pre></td></tr></table></figure>
<pre><code>输出
æ
230</code></pre><p>====================6.26  继承 重载 多态======================</p>
<ol>
<li><p>super()<br>super(a,b) 调用带参构造<br>super.属性<br>super.方法</p>
</li>
<li><p>先执行父类构造，再执行子类构造</p>
</li>
<li><p>debug 鼠标放到变量上</p>
</li>
<li><p>无参构造<br>  子类默认调用父类的无参构造，当父类无参构造不存在时，子类不会自动调用父类的有参构造</p>
</li>
<li><p>super不在过构造方法时，可以不放在第一行</p>
</li>
<li><p>  pet dog = new dog();<br>  dog.print();默认调用子类的print方法（print方法，子类父类中都有）</p>
<p>  pet dog = new dog();<br>  dog.method();不能调用子类特有方法（method 只有子类中有）</p>
</li>
<li><p>子类不可以调用父类的有：<br> private<br> 构造方法<br> 不在同一个包<br> 默认类型的成员</p>
</li>
<li><p>修饰符：</p>
<pre><code>本类 同包 子类 其他（不同包）            唯一的标准</code></pre><p>private  🐶                                是否在 同一个类<br>frendly       🐶                               是否在 同包            默认的<br>protect           🐶                            是否   继承<br>public                 🐶                         都行</p>
</li>
</ol>
<p>9.包名不能建成package<br>10.不同包继承时，父类不能放在默认的包中（default package中）<br>11.super总结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">super只能在写方法中</span><br><span class="line">package package1;</span><br><span class="line"></span><br><span class="line">import package2.A;</span><br><span class="line"></span><br><span class="line">public class B extends A &#123;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;super.a &#x3D;2;&#x2F;&#x2F;Syntax error on token &quot;&#123;&quot;, &#123; expected after this token</span><br><span class="line">	public B()&#123;</span><br><span class="line">		super.a &#x3D;2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>super不在过构造方法时，可以不放在第一行

super不能访问父类private成员


super()
super(a,b) 调用带参构造
super.属性
super.方法</code></pre><p>12.❤️❤️❤️❤️❤️❤️❤️❤️重写 重载 对比<br>  重写<br>    1.重写<br>    2.类型相同/父类返回类型的子类 + 修饰符只能扩大，不能缩小 + 方法名，参数列表相同<br>    3.构造方法不能重写</p>
<p>  重载的条件<br>    1.同一个类中<br>    2.参数列表不同<br>    3.方法名相同<br>    4.和返回值，访问修饰符无关<br>13.<br>    抽象类不能实例化  — 因为没有意义<br>    Pet pet = new Dog() pet是abstract<br>    是对的  这只是一个指针指向 没有分配空间进行实例化</p>
<pre><code>抽象类中可以有0个或者多个抽象方法  
子类中，抽象方法在子类中必须实现</code></pre><p>14.final<br>    方法     重写<br>    变量属性  修改 （当变量为对象时，final对象不可以=new Object()，但是仍然可以改变这个对象的属性）<br>    类       继承<br>15.this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;父类</span><br><span class="line">package package3;</span><br><span class="line"></span><br><span class="line">public class Car &#123;</span><br><span class="line">	private int site &#x3D; 4; &#x2F;&#x2F;座位数 </span><br><span class="line">	</span><br><span class="line">	Car()&#123;</span><br><span class="line">		System.out.println (&quot;载客量是&quot;+site+&quot;人&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void setSite(int site)&#123; </span><br><span class="line">		this.site &#x3D; site;</span><br><span class="line">	&#125;</span><br><span class="line">	void print()&#123;</span><br><span class="line">		System.out.print(&quot;载客量是&quot;+this.site+&quot;人&quot;); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;子类</span><br><span class="line">package package3;</span><br><span class="line"></span><br><span class="line">public class Bus extends Car &#123;</span><br><span class="line">	Bus(int site)&#123;</span><br><span class="line">		&#x2F;&#x2F;这三个的输出结果是一样的</span><br><span class="line">		&#x2F;&#x2F;this.setSite(site); </span><br><span class="line">		&#x2F;&#x2F;super.setSite(site);</span><br><span class="line">		setSite(site);</span><br><span class="line">	&#125;</span><br><span class="line">&#x2F;&#x2F;	public void setSite(int site)&#123; </span><br><span class="line">&#x2F;&#x2F;		super.site &#x3D; site;</span><br><span class="line">&#x2F;&#x2F;		&#x2F;&#x2F;this.site &#x3D; site;</span><br><span class="line">&#x2F;&#x2F;	&#125;</span><br><span class="line">	public void show()&#123;</span><br><span class="line">		System.out.println(&quot;Bus_print&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试类</span><br><span class="line">package package3;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		Bus bus &#x3D; new Bus(20);</span><br><span class="line">		bus.print();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>总结：
       1. 在继承中，如果子类没有重写父类的方法，那么子类是调用的是父类的方法
       2. ❤️这里的调用，是在父类中执行，而不是在子类中执行（原来理解的是在子类中执行）
       3. 即使，这三个的输出结果是一样的
       this.setSite(site); 
       super.setSite(site);
       setSite(site);

       4. 继承不是拥有这项技能，而是能让父类帮你干，你自己其实不会。</code></pre><ol>
<li><p>super.name</p>
</li>
<li><p> 用构造方法不一定会生成对象<br> eg：pet pet = new dog（）<br> 这调用了父类的构造方法，也调用了子类的构造方法，但是，但是只生成了子类对象</p>
</li>
<li><p>多态：同一个引用类型，使用不同的实例而执行不同操作</p>
<p> 父类存在的地方一般都能使用子类代替</p>
<p> 要素：</p>
<pre><code>1.子类重写父类分方法
2.使用父类的类型</code></pre><p> 使用的地方：</p>
<pre><code>1.方法参数
2.方法返回值</code></pre></li>
<li><p> ❤️Pet 是一个abstract类，他不能new一个对象，但是却可以调用方法pet.eat();</p>
</li>
<li><p> pet instanceof Dog<br> instanceof 使用：对象.instanceof(父类/接口)</p>
<p> Dog dog = （Dog）pet;强制转换<br> (Dog)pet.dark();这的是错的，之后转换了之后才可以进行特有dog方法的调用</p>
</li>
<li><p>❤<br> MotoVehicle moto[] =new MotoVehicle[4];<br> 这个MotoVehicle是abstract类，但是能用new，这个例子就充分的说明了，new ！= 分配空间。<br> 在这里，他仅仅说明了moto[]的长度</p>
<p> 对象数组的初始化方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line">MotoVehicle moto[] &#x3D; new MotoVehicle[]&#123;</span><br><span class="line">		new Car(1,&quot;宝马1&quot;,&quot;红色&quot;,1000,20),</span><br><span class="line">		new Car(2,&quot;宝马2&quot;,&quot;红色&quot;,1000,20),</span><br><span class="line">		new Bus(3,&quot;金龙1&quot;,&quot;绿色&quot;,1000,&quot;x&quot;),</span><br><span class="line">		new Bus(3,&quot;金龙2&quot;,&quot;绿色&quot;,1000,&quot;xx&quot;),</span><br><span class="line">		new Bus(5,&quot;金龙3&quot;,&quot;绿色&quot;,1000,&quot;xxx&quot;),</span><br><span class="line">		new Ka(6,&quot;Ka1&quot;,&quot;兰色&quot;,1000,100)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">第二种：</span><br><span class="line">for(int i &#x3D; 0 ;i &lt; n;i++)&#123;</span><br><span class="line">	moto[i]&#x3D; new Car(****);&#x2F;&#x2F;只能生成一种Car类型的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>22.abstract的作用<br>    1.对于架构设计者，他可以写好abstract类 ，以及其中的abstract方法，这就规定了这个类的子类必须要实现这个方法<br>    2.abstract的方法其实还是可以调用的，于instanceof+重写（重写不仅仅用于abstract），可以实现工厂模式+抽象工厂模式——也就有了扩展性</p>
<p>23.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">类B</span><br><span class="line">package package6;</span><br><span class="line"></span><br><span class="line">public class B extends A&#123;</span><br><span class="line">	int a;</span><br><span class="line">	public void show()&#123;</span><br><span class="line">		a &#x3D; 2;</span><br><span class="line">		System.err.println(this.a);</span><br><span class="line">		System.err.println(super.a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类A</span><br><span class="line">package package6;</span><br><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">	int a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test类</span><br><span class="line">package package6;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		B b &#x3D; new B();</span><br><span class="line">		b.show();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>输出结果
2
0</code></pre><p>=================6.27接口+ 异常================<br>1.接口<br>    接口不能实例化<br>    实现类必须实现接口的所有方法<br>    变量都是静态变量<br>    现类可以实现多个接口</p>
<p>2.interface  implements<br>3.interface的默认<br>    方法：public abstract void service();   不能用static<br>    变量：public staic final  double PI = 3.14;<br>4.❤️实例化两种 (UDisk implememts UsbInterface)<br>    UDisk u = new UDisk();<br>    UsbInterface u2 = new UDisk();</p>
<p>5.❤️接口实现方式和设计模式的不同</p>
<pre><code>在设计模式中，door是雇主，而lock是雇员，他们两个都是抽象类（可以方便的横向扩展）,door中有lock的对象（仍然是两个对象）
但是在接口中,没lock的对象，而是直接拿到了lock的方法，两个对象合二为一（合二为一为重点）


总结：
    设计模式是类，对象之间相互组合，至少也有两个对象（把功能分配给不同的对象去完成）
    而抽象和接口，本质是把一个类的方法进行拆分，分别放在抽象类和接口类中，让其他类也可以用（把功能分成方法集，方便其他类用)

接口改成类后更加灵活：
当把一个接口A写成类A，B不是通过implement来使用，而是在类B中声明一个new A对象，
这种改法使得B类可以更加灵活，因为可以通过更改A的实例，让B有新的功能。
相同的功能，如果更改在B中更改A的接口方法，那么就必须去更改方法本身，而不是简单的换个对象就行了</code></pre><p>6.❤️接口和抽象类的区别<br>    1.定义，关键词<br>    2.抽象类是单继承，extends，接口可以实现的多个，implement<br>    3.其中包含的内容，抽象类可以有变量，成员方法，接口中有final变量+abstract方法<br>    4.使用的场合<br>        抽象类：is a<br>        接口： has a<br>    5.相同点：都不能生成实例对象,都没有构造方法</p>
<pre><code>❤️❤️❤️❤️❤️❤️决定使用抽象类 还是接口
is a   ----&gt;abstract  防盗门是门    （一个类别=抽象）
has a  ----&gt;接口       门用到锁       （一个部分=接口）


总结：在类，接口，抽象中选择
    is a                   （一个类别=抽象）
    has a (二选一)      （一个部分=接口）
                    （可更换的部分=类）
注：现在我的认识是：类一定比接口好，接口的功能全能用类来实现！当然这是错的！</code></pre><ol start="7">
<li><p>先写接口 -&gt; 抽象类 -&gt;实现类 -&gt; test测试<br>接口 -&gt; 实现类 -&gt; test测试</p>
</li>
<li><p>接口的优势<br> 多继承<br> 设计和实现完全分离<br> 更自然使用多态<br> 更容易搭建程序框架<br> 更容易更换</p>
</li>
<li><p>算数异常</p>
</li>
<li><p>has.nextInt();</p>
</li>
<li><p>五个关键字<br> try          执行可能产生异常的代码<br> catch        捕获异常<br> finally      终会执行<br> throw        抛出<br> throws       声明</p>
</li>
<li><p>java.lang.Exception</p>
</li>
<li><p>e.printStacktTrace() 堆栈追踪功能<br>这个注释掉，就没有异常信息输出了</p>
</li>
<li><p>try catch的三种情况 ，以及执行情况<br>  没异常               try-&gt;继续<br> 有异常，捕获             try-&gt;catch-&gt;打印出catch中的异常-&gt;继续<br> 有异常，没捕获         try-&gt;中断-&gt;jvm打印出异常 </p>
<p> 总结：catch 只有匹配了异常才能执行，当参数写Exception时，一定能匹配</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*****例子1；*******</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">	Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">	System.out.println(&quot;请输入第一个数&quot;);</span><br><span class="line">	int input1 &#x3D; scan.nextInt();</span><br><span class="line">	System.out.println(&quot;请输入第二个数&quot;);</span><br><span class="line">	int input2 &#x3D; scan.nextInt();</span><br><span class="line">	System.out.println(String.format(&quot;%d&#x2F;%d&#x3D;%d&quot;, input1,input2,input1&#x2F;input2));</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">	System.err.println(&quot;_____catch_____&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;程序结束&quot;);</span><br></pre></td></tr></table></figure>

<pre><code>输出：
请输入第一个数
1
请输入第二个数
0
程序结束
java.lang.ArithmeticException: / by zero
    at package6.Exception1.main(Exception1.java:16)
_____catch_____</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">******例子2；*******</span><br><span class="line">将   System.err.println(&quot;_____catch_____&quot;);  </span><br><span class="line"> 改为 System.out.println(&quot;_____catch_____&quot;);</span><br></pre></td></tr></table></figure>
<pre><code>输出：
请输入第一个数
1
请输入第二个数
0
_____catch_____
程序结束
java.lang.ArithmeticException: / by zero
    at package6.Exception1.main(Exception1.java:17</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">******例子3；*******</span><br><span class="line">将    &#125; catch (Exception e) &#123;  </span><br><span class="line"> 改为  &#125; catch (InputMismatchException e) &#123;</span><br></pre></td></tr></table></figure>

<pre><code>输出：
    请输入第一个数
    1
    请输入第二个数
    0
    Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero
        at package6.Exception1.main(Exception1.java:18)


    请输入第一个数
    q
    _____catch_____
    程序结束
    java.util.InputMismatchException
        at java.util.Scanner.throwFor(Scanner.java:864)
        at java.util.Scanner.next(Scanner.java:1485)
        at java.util.Scanner.nextInt(Scanner.java:2117)
        at java.util.Scanner.nextInt(Scanner.java:2076)
        at package6.Exception1.main(Exception1.java:15)</code></pre><p>15.getMessage();输出一个异常的描述信息<br>    自定义异常 system.err.print();</p>
<p>16.常见异常<br>    arrayInexOutOfBounds 数组越界<br>    NULLPointer    空指针异常<br>    ClassNotFound  类没有定义<br>    IllegalArgument 不合法参数<br>    ClassCast   对象强制转换异常<br>    NumberFormat  abc-&gt;数字<br>    NoSuchMethod<br>    IO<br>    SQL<br>17.error exception的不同<br>    error<br>18.RuntimeException<br>19.finally<br>    1.是否发生异常都执行<br>    2.system.exit(1) 唯一可能不执行finally的情况</p>
<p>20 return 和 finally 的关系<br>    try{</p>
<pre><code>}catch(Exception e){
    syso（“*”);
    return 2;
}finall{
    syso();
}

当捕获到异常时，并且catch有返回return时，先执行finally，在执行return</code></pre><p>21.<br>    *<br>22.<br>    按catch的顺序：先父类 后子类</p>
<p>23.main方法不能改<br>    public static int main(String[] args) {</p>
<pre><code>错误: main 方法必须返回类 package6.Exception1 中的空类型值, 请
将 main 方法定义为:</code></pre><p>   public static void main(String[] args)<br>24.throws用法</p>
<pre><code>“嗨哥们，这个A方法容易出错，调用这个A方法的B方法必须进行处理”
处理方法：
    1.B()throws Exception{}
    2.B(){
        try{
            A();
        }catch(Exception e){
            e.
        }
    }

注：1方法输入让jvm处理异常，那么，可能会中断程序</code></pre><p>25.throw 的用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">********例子1******</span><br><span class="line">public void setAge(int age) throws Exception &#123;&#x2F;&#x2F;这里要声明throws</span><br><span class="line">	</span><br><span class="line">	if(age &gt; 0 &amp;&amp; age &lt; 130)&#123;</span><br><span class="line">		this.age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		throw new Exception(&quot;年龄必须大于0 小于130&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>输出：
Exception in thread &quot;main&quot; java.lang.Exception: 年龄必须大于0 小于130
at package7.Person.setAge(Person.java:16)
at package7.ExceptionTest.main(ExceptionTest.java:6)    </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">********例子2******</span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">	</span><br><span class="line">if(age &gt; 0 &amp;&amp; age &lt; 130)&#123;</span><br><span class="line">	this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		throw new Exception(&quot;年龄必须大于0 小于130&quot;);</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>输出：
java.lang.Exception: 年龄必须大于0 小于130
at package7.Person.setAge(Person.java:17)
at package7.ExceptionTest.main(ExceptionTest.java:6)
0

总结：
    写了throw之后，必须进行2选一的操作</code></pre><p>26.log 日志的作用<br>    1.用来记录系统运行中的而一些中亚操作信息<br>    2.便于见识系统运行，帮助用户提前发现和避开可能出现的问题，或出现问题后根据日志找到原因<br>27.日志的分类<br>    sql日志  记录增删该查<br>    异常日志  记录异常<br>    业务日志    记录业务操作<br>28.输出级别 8<br>    OFF<br>    Fatal<br>    ERROR<br>    warn<br>    info<br>    debug<br>    trace<br>    all<br>29.<br>    配置日志格式<br>    输出位置<br>    文件名.log</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenzhiheng.cn/2017/06/29/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.29%20%E5%B8%B8%E7%94%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/29/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.29%20%E5%B8%B8%E7%94%A8%E7%B1%BB/" class="post-title-link" itemprop="url">6.29 常用类</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-29 08:02:00" itemprop="dateCreated datePublished" datetime="2017-06-29T08:02:00+08:00">2017-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 16:46:16" itemprop="dateModified" datetime="2020-03-12T16:46:16+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%BC%80%E5%8F%91-czh-java-java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">web开发/czh_java/java基础</span>
                  </a>
                </span>
            </span>

          
            <span id="/2017/06/29/web%E5%BC%80%E5%8F%91/czh_java/java%E5%9F%BA%E7%A1%80/6.29%20%E5%B8%B8%E7%94%A8%E7%B1%BB/" class="post-meta-item leancloud_visitors" data-flag-title="6.29 常用类" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2017年6月29日 上午8:02</p>
<h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Java.lang.Object<br>    1. equal()<br>    2. toString()<br>    3. getClass() 返回运行时类<br>    4. finalize()<br>    5. notify() 唤醒在此对象监视上等待的单个线程<br>    6. notifyAll()<br>    7. wait()</p>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>java.util.Math<br>都是静态方法<br>    1. abs()<br>    2. max()<br>    3. min()<br>    4. random()  0.0~1.0 包括0.0  不包括1.0<br>    5. sin()<br>    6. exp()<br>    7. sqart(9) = 3<br>    8. Pow(2.3) = 8</p>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><pre><code>1. 日期转字符串1(DateFormat.getDateInstance)</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">DateFormat  df = DateFormat.getDateInstance(DateFormat.FULL);</span><br><span class="line">String string= df.format(date);</span><br><span class="line">System.out.println(string);</span><br></pre></td></tr></table></figure>
<pre><code>2. 日期转字符串2（SimpleDateFormat）</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日期转换成字符串</span></span><br><span class="line">Date date  = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的"yyyy-MM-dd" 要与 “String time = "1995-2-27"”格式对应</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">String string = sdf.format(date);</span><br><span class="line">System.out.println(string);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串转换成日期</span></span><br><span class="line">String time = <span class="string">"1995-2-27"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Date dtime = sdf.parse(time);</span><br><span class="line">	System.out.println(dtime);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Calendar-默认指向的是当前时间，站在当前日期的角度"><a href="#Calendar-默认指向的是当前时间，站在当前日期的角度" class="headerlink" title="Calendar//默认指向的是当前时间，站在当前日期的角度"></a>Calendar//默认指向的是当前时间，站在当前日期的角度</h2><p>操作的步骤一般是1-4<br>    1. 获取对象<br>        Calendar.getInstance()<br>    2. 修改默认时间<br>        1. cal.add()<br>        2. cal.set(年,月,日)<br>            1. 月是0-11<br>    3. 对当前设置的时间进行转换<br>        1. cal.get(Calendar.DAY_OF_WEEK)<br>            1. 星期日=1<br>            2. 获取当前设置日期的星期几<br>    4. 得到Date类型的时间<br>        1. cal.getTime() </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取操作对象</span></span><br><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line"><span class="comment">//修改当前时间</span></span><br><span class="line">cal.add(Calendar.MONTH, -<span class="number">1</span>);<span class="comment">//修改当前日期</span></span><br><span class="line">cal.set(<span class="number">1995</span>, <span class="number">1</span>, <span class="number">27</span>);<span class="comment">//覆盖了上一句</span></span><br><span class="line">System.out.println(<span class="string">"输出星期几："</span>+cal.get(Calendar.DAY_OF_WEEK));</span><br><span class="line"><span class="comment">//得到当前时间</span></span><br><span class="line">Date date = cal.getTime();</span><br><span class="line"><span class="comment">//对时间进行转换</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">String string = sdf.format(date);</span><br><span class="line">System.out.println(<span class="string">"设置的当前时间："</span>+string);</span><br></pre></td></tr></table></figure>

<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ol>
<li>八个基本类型对应一个包装类</li>
<li>数字和字符之间的转换  <ol>
<li>Integer.parseInt(str)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = Integer.parseInt(str);</span><br><span class="line"><span class="keyword">double</span> num2 = Double.parseDouble(str);</span><br><span class="line">Sysytem.out.print(num1 + num2);</span><br></pre></td></tr></table></figure></li>
<li>String.valueOf(num1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = num1 + <span class="string">""</span>;</span><br><span class="line">String str = String.valueOf(num1);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>装箱 拆箱<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="number">20</span>);  <span class="comment">//手动装箱</span></span><br><span class="line">Integer integer = <span class="number">20</span>;<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">new</span> Integer(<span class="number">5</span>).intValue();<span class="comment">//手动拆箱</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">new</span> Integer(<span class="number">5</span>);<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure></li>
<li>Integer 不能自动转换为 Float <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		method(<span class="number">5</span>);<span class="comment">//这里要改成method(5f)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Float f)</span></span>&#123;</span><br><span class="line">		System.out.println(f);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenzhiheng.cn/2017/06/29/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/2017/JULY%20%E7%AE%97%E6%B3%9501/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/29/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/2017/JULY%20%E7%AE%97%E6%B3%9501/" class="post-title-link" itemprop="url">JULY 算法01</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-29 04:15:00" itemprop="dateCreated datePublished" datetime="2017-06-29T04:15:00+08:00">2017-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 16:46:20" itemprop="dateModified" datetime="2020-03-12T16:46:20+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B-2017/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_算法/算法学习过程/2017</span>
                  </a>
                </span>
            </span>

          
            <span id="/2017/06/29/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/2017/JULY%20%E7%AE%97%E6%B3%9501/" class="post-meta-item leancloud_visitors" data-flag-title="JULY 算法01" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2017年6月29日 下午4:15</p>
<p><img src="/2017/06/29/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/2017/JULY%20%E7%AE%97%E6%B3%9501/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BA%8C%E3%80%81Dijkstra%20%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET%20Safari,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%883.13.08.png" alt><br>JULY说学习算法最好的方法：<br>        1. 抓住算法是为了<strong>解决什么样的问题</strong><br>        2. <strong>图</strong>可以帮助自己理解<br><img src="/2017/06/29/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/2017/JULY%20%E7%AE%97%E6%B3%9501/%E7%A8%8B%E5%BA%8F%20MindNode,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%883.25.13.png" alt><br>我对算法的理解：<br>        1.     算法的第一步不是去看懂程序，而是，<strong>能把一个具体的例子，一步一步的仔细完整额走下来</strong>，<strong>这部分才是真正的算法本身</strong><br>            1. JULY所说的<strong>图</strong>，正是说明例子步骤的一种好的方式<br>        2. 然后才是，想办法对例子进行<strong>总结提炼概括</strong>（抽象），<strong>找到表达的方式</strong><br>        3. 最后才动笔写程序<br><strong>注：描述一个算法，也应该是这样的思路</strong><br>在读的时候对自己的要求：<br>        1. 摘抄一些算法关键性的说明，容易漏掉的部分<br>        2. 说明一些不太懂的地方<br>        3. 说出自己的理解</p>
<h2 id="A-搜索算法"><a href="#A-搜索算法" class="headerlink" title="A*搜索算法"></a>A*搜索算法</h2><p>地址：<a href="http://blog.csdn.net/v_july_v/article/details/6093380" target="_blank" rel="noopener">一、A*搜索算法 - 结构之法 算法之道</a><br>    1. 所谓启发式搜索，就在于当前搜索结点往下选择下一步结点时，可以<strong>通过一个启发函数来进行选择</strong>，选择代价最少的结点作为下一步搜索结点而跳转其上（遇到有一个以上代价最少的结点，不妨选距离当前搜索点最近一次展开的搜索点进行下一步搜索）。<br>    2. <strong>DFS和BFS</strong>在展开子结点时均属于<strong>盲目型搜索</strong>，也就是说，它不会选择哪个结点在下一次搜索中更优而去跳转到该结点进行下一步的搜索。<br>    3. <strong>A</strong>算法最为核心的部分<strong>，就在于它的一个估值函数的设计上：  *f(n)=g(n)+h(n)</strong><br>    4. <strong>解决的问题：</strong><br>        1. 求有向图 两点之间的最短路径<br><img src="/2017/06/29/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/2017/JULY%20%E7%AE%97%E6%B3%9501/%E4%B8%80%E3%80%81A*%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET%20Safari,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%883.33.11.png" alt><br>    5.   通过上图，我们可以看出：：A<strong>算法最为核心的过程，就在每次选择下一个当前搜索点时，</strong>是从所有已探知的但未搜索过点中<em>(可能是不同层，亦可不在同一条支路上)，选取f值最小的结点进行展开。<br>    6.   而所有“已探知的但未搜索过点”可以通过一个*</em>按f值升序的队列(即优先队列)<strong>进行排列。<br>    7.    当任何</strong>第二次走到一个点的时候<strong>，判断最小步骤是否小于记录的内容，如果是，则</strong>更新掉原最小步数<strong>，一直到所有的路径点都不能继续都了为止，最终那个点被标注的最小步数既是最短路径，<br>    8. **理解不了的：</strong><br>        1.  A<strong>算法与广度、深度优先和Dijkstra 算法的联系就在于：当g(n)=0时，该算法类似于DFS，当h(n)=0时，该算法类似于BFS。且同时，如果h(n)为0，只需求出g(n)，即求出起点到任意顶点n的最短路径，则转化为单源最短路径问题，即Dijkstra算法。这一点，可以通过上面的A</strong>搜索树的具体过程中将h(n)设为0或将g(n)设为0而得到。<br>        2. 算法流程1-3这样讲解算法有用吗</p>
<h2 id="Dijkstra-算法初探"><a href="#Dijkstra-算法初探" class="headerlink" title="Dijkstra 算法初探"></a>Dijkstra 算法初探</h2><p>来源：<a href="http://blog.csdn.net/v_july_v/article/details/6096981" target="_blank" rel="noopener">经典算法研究系列：二、Dijkstra 算法初探 - 结构之法 算法之道 </a><br>    1. <strong>解决的问题</strong><br>        1. 算法解决的是有向图中<strong>单个源点</strong>到<strong>其他顶点</strong>的最短路径问题<br>    2. 针对的是非负值权边。<br>    3. 下面两个图是对算法的<strong>举例说明的过程</strong><br><img src="/2017/06/29/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/2017/JULY%20%E7%AE%97%E6%B3%9501/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BA%8C%E3%80%81Dijkstra%20%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET%20Safari,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%884.01.44.png" alt><br><img src="/2017/06/29/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/2017/JULY%20%E7%AE%97%E6%B3%9501/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BA%8C%E3%80%81Dijkstra%20%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2%20-%20%E7%BB%93%E6%9E%84%E4%B9%8B%E6%B3%95%20%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93%20-%20%E5%8D%9A%E5%AE%A2%E9%A2%91%E9%81%93%20-%20CSDN.NET%20Safari,%20%E4%BB%8A%E5%A4%A9%20at%20%E4%B8%8B%E5%8D%884.03.31.png" alt><br>    4. 发现，其实在举例说明的过程中，我们就可以发现“<strong>哎，这个东西用某某东西就能描述</strong>”<br>注：我现在不考虑<strong>算法的实现</strong>和<strong>算法的效率</strong>，我知道<strong>知道</strong>和<strong>实现</strong>之间的区别！！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.chenzhiheng.cn/2017/06/28/web%E5%BC%80%E5%8F%91/czh_blog/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0%E6%91%98%E6%8A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/28/web%E5%BC%80%E5%8F%91/czh_blog/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0%E6%91%98%E6%8A%84/" class="post-title-link" itemprop="url">SQL书本笔记摘抄</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-28 10:14:00" itemprop="dateCreated datePublished" datetime="2017-06-28T10:14:00+08:00">2017-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 16:46:16" itemprop="dateModified" datetime="2020-03-12T16:46:16+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%BC%80%E5%8F%91-czh-blog-%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">web开发/czh_blog/数据库</span>
                  </a>
                </span>
            </span>

          
            <span id="/2017/06/28/web%E5%BC%80%E5%8F%91/czh_blog/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0%E6%91%98%E6%8A%84/" class="post-meta-item leancloud_visitors" data-flag-title="SQL书本笔记摘抄" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>920</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2017年6月28日 下午10:14</p>
<ol>
<li>查询时的<strong>三种思维</strong><ol>
<li>先连接 ，后删除</li>
<li>先选取 ，后连接—–in</li>
<li>一个个的试，从小范围到大范围  exists</li>
<li>注：<strong>后两种所查询出来的信息必须在一张表中</strong><ol>
<li>第一种可以拼接多个表数据的原因是两个表<strong>通过笛卡尔积进行了拼接</strong></li>
</ol>
</li>
</ol>
</li>
<li>eg：<strong>从sc表中筛选出所有计算机系的学生选课情况</strong><ol>
<li>select sc.* from sc,student where sc.sno=student.sno and student.dept=’计算机系’</li>
<li>select * from sc where sno in (select student.sno from student where student.dept=’计算机系’)</li>
<li>select * from sc where exists (select * from student where student.sno=sc.sno and student.dept=’计算机系’);<ol>
<li>我拿上sc表的第一条数据的学号，用这个学号作为条件，看是否在学生表中存在一条数据满足：有这个学号的学生，并且她是计算机系的</li>
</ol>
</li>
<li>select * from sc where ‘计算机系’= (select dept from student where student.son=sc.sno)—这个稍微短点<ol>
<li>这个是exists的改写版，虽然没有出现exist，但是就是exist</li>
</ol>
</li>
</ol>
</li>
<li><strong>范式</strong><ol>
<li>范式问题只看两个东西<ol>
<li>依赖 <ol>
<li>1.多值 and 非多值</li>
<li>2.主要通过画图解决</li>
<li>3.使用范围是1-3+bc范式</li>
</ol>
</li>
<li>候选码<ol>
<li>能唯一标识元组的码</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="依赖："><a href="#依赖：" class="headerlink" title="依赖："></a>依赖：</h2><pre><code>1. 平凡与非平凡依赖
    1. 非平凡： （Sno,Cno） -&gt;Grade
    2. 平凡：        (Sno,Cno)   -&gt;Sno
                 (Sno,Cno)   -&gt;Cno
2. 部分与完全函数依赖
    1. 完全：    （Sno,Cno）-&gt;Grade
    2. 部分：    （Sno,Cno）-&gt;Sname
3. 传递与直接函数依赖</code></pre><h2 id="范式："><a href="#范式：" class="headerlink" title="范式："></a>范式：</h2><pre><code>BCNF与1，2，3NF的区别：
    BC是主属性之间的依赖，而1,2,3是非主属性与主属性之间的依赖</code></pre><h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><pre><code>1. 如果不存在依赖—&gt;化为4NF
2. 如果是全码为候选码（无非主属性）-&gt;至少BC
3. 依赖与候选码之间的关系  -&gt;确定2NF 3NF</code></pre><p><img src="/2017/06/28/web%E5%BC%80%E5%8F%91/czh_blog/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0%E6%91%98%E6%8A%84/73B1ECB3-8617-4A33-8143-06B3A0E23D38.png" alt><br>注：<br>    <strong>像图片中所显示依赖关系，你是画不出依赖图的</strong><br>    <strong>必须先进行处理，求最小函数依赖集</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/96/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/96/">96</a><span class="page-number current">97</span><a class="page-number" href="/page/98/">98</a><a class="extend next" rel="next" href="/page/98/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhiheng Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">974</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">82</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhiheng Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">15:58</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        






  <script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.getAttribute('data-flag-title');

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=QiM1vjQ7SAoirKD4qY57L82O-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id'     : 'QiM1vjQ7SAoirKD4qY57L82O-gzGzoHsz',
            'X-LC-Key'    : 'aOHhzmfDblK0HGWUqEyb6ra2',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
