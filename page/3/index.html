<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenzhiheng.cn","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="陈志恒的技术博客">
<meta property="og:url" content="http://chenzhiheng.cn/page/3/index.html">
<meta property="og:site_name" content="陈志恒的技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhiheng Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://chenzhiheng.cn/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>陈志恒的技术博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6bc779d0e3be483fc01e871fbb7cef3d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">陈志恒的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%865%EF%BC%9A%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%865%EF%BC%9A%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">专题知识5：内存相关</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 11:51:00" itemprop="dateCreated datePublished" datetime="2020-04-08T11:51:00+08:00">2020-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 19:31:54" itemprop="dateModified" datetime="2020-04-12T19:31:54+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AF%AD%E8%A8%80-c/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_语言/c++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%865%EF%BC%9A%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/" class="post-meta-item leancloud_visitors" data-flag-title="专题知识5：内存相关" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月8日 上午11:51</p>
<p><a href="bear://x-callback-url/open-note?id=A54ECAD0-E043-4021-AE84-B75D618E10DB-1248-0000DB50D44264DF">专题知识点3：const</a>const是存储在.text的常量区</p>
<h4 id="new-delete与malloc-free的区别是什么"><a href="#new-delete与malloc-free的区别是什么" class="headerlink" title="new/delete与malloc/free的区别是什么"></a>new/delete与malloc/free的区别是什么</h4><ol>
<li>首先，new_delete是C++的关键字，而malloc_free是C语言的库函数，</li>
<li>malloc不会调用构造函数和析构函数：<ol>
<li>需要给定申请内存的大小，返回的指针需要强转。</li>
</ol>
</li>
<li>new会调用构造函数<ol>
<li>不用指定内存大小，返回的指针不用强转。</li>
</ol>
</li>
</ol>
<h4 id="什么是memory-leak，也就是内存泄漏"><a href="#什么是memory-leak，也就是内存泄漏" class="headerlink" title="什么是memory leak，也就是内存泄漏"></a>什么是memory leak，也就是内存泄漏</h4><ol>
<li><strong>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。</strong>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，<strong>失去了对该段内存的控制</strong>，因而造成了内存的浪费。</li>
</ol>
<h4 id="内存泄漏的分类：内存泄漏的常见原因"><a href="#内存泄漏的分类：内存泄漏的常见原因" class="headerlink" title="内存泄漏的分类：内存泄漏的常见原因"></a>内存泄漏的分类：内存泄漏的常见原因</h4><ol>
<li>堆内存泄漏 （Heap leak）。<ol>
<li>对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</li>
</ol>
</li>
<li>系统资源泄露（Resource Leak）。<ol>
<li>主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li>
</ol>
</li>
<li>没有将基类的析构函数定义为虚函数。<ol>
<li>当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li>
</ol>
</li>
<li><a href="bear://x-callback-url/open-note?id=71D3B9CC-2DE8-479F-9BBD-E153A8A6B9BA-1248-0000D5840CF48A53">专题知识点1：指针专题</a>smart_ptr也可以引起内存泄漏</li>
</ol>
<h4 id="C-的内存管理是怎样的？"><a href="#C-的内存管理是怎样的？" class="headerlink" title="C++的内存管理是怎样的？"></a>C++的内存管理是怎样的？</h4><ol>
<li><strong>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</strong></li>
<li>代码段:<ol>
<li>包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</li>
</ol>
</li>
<li>数据段：<ol>
<li>存储程序中已初始化的全局变量和静态变量</li>
</ol>
</li>
<li>Bss 段：<ol>
<li>存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</li>
</ol>
</li>
<li>堆区：<ol>
<li>调用new_malloc函数时在堆区动态分配内存，同时需要调用delete_free来手动释放申请的内存。</li>
</ol>
</li>
<li>映射区:<ol>
<li>存储动态链接库以及调用mmap函数进行的文件映射</li>
</ol>
</li>
<li>栈：<ol>
<li>使用栈空间存储函数的返回地址、参数、局部变量、返回值</li>
</ol>
</li>
</ol>
<h4 id="函数在main函数执行前先运行"><a href="#函数在main函数执行前先运行" class="headerlink" title="函数在main函数执行前先运行"></a>函数在main函数执行前先运行</h4><ol start="2">
<li>在 .text之前：<strong>data段的内容</strong>:<ol>
<li>全局对象的构造函数会在main 函数之前执行。</li>
<li>一些全局变量、对象和静态变量、对象的空间分配和赋初值就是在执行main函数之前，而main函数执行完后，还要去执行一些诸如释放空间、释放资源使用权等操作</li>
</ol>
</li>
<li>在 .text之前：<strong>.bss段的内容</strong><ol>
<li>进程启动后，要执行一些初始化代码（如设置环境变量等），然后跳转到main执行。全局对象的构造也在main之前。</li>
</ol>
</li>
<li>通过关键字<strong>attribute</strong>，让一个函数在主函数之前运行，进行一些数据初始化、模块加载验证等。</li>
</ol>
<h4 id="Main函数执行之前，主要就是初始化系统相关资源："><a href="#Main函数执行之前，主要就是初始化系统相关资源：" class="headerlink" title="Main函数执行之前，主要就是初始化系统相关资源："></a>Main函数执行之前，主要就是初始化系统相关资源：</h4><p><a href="https://www.jianshu.com/p/4260d859f181" target="_blank" rel="noopener">C语言深度总结全面认识main函数之前运行代码 - 简书</a></p>
<ol>
<li><strong>设置栈指针</strong></li>
<li>在 .text之前：<strong>data段的内容</strong>:<ol>
<li>初始化static静态和global全局变量</li>
</ol>
</li>
<li>在 .text之前：<strong>.bss段的内容</strong><ol>
<li>将未初始化部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等</li>
</ol>
</li>
<li>.text段：<ol>
<li>将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%95%B4%E7%90%86/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%95%B4%E7%90%86/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">事件驱动编程模型 == 异步编程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 05:57:00" itemprop="dateCreated datePublished" datetime="2020-04-08T05:57:00+08:00">2020-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 19:32:44" itemprop="dateModified" datetime="2020-04-12T19:32:44+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E6%95%B4%E7%90%86/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_计算机系统/整理</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%95%B4%E7%90%86/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="事件驱动编程模型 == 异步编程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月8日 下午5:57</p>
<h3 id="关键：理解了buffer的作用"><a href="#关键：理解了buffer的作用" class="headerlink" title="关键：理解了buffer的作用"></a>关键：理解了buffer的作用</h3><p>其实就是有一个buffer用作缓存(事件（消息）队列)，当动作发生的时候，我并不执行，而是将它扔到一个buffer里，让另外的处理线程去执行，这个处理线程就会不间断的执行buffer里的任务，如果当前的动作发生了阻塞，那么处理线程立刻再把它放到这个buffer中(注册一个回调到事件循环中)，找下一个进行执行，直到buffer为空</p>
<h1 id="事件驱动编程模型"><a href="#事件驱动编程模型" class="headerlink" title="事件驱动编程模型"></a>事件驱动编程模型</h1><p><a href="https://www.cnblogs.com/zingp/p/6863170.html#_labelTop" target="_blank" rel="noopener">IO模式和IO多路复用 - ZingpLiu - 博客园</a></p>
<h3 id="3-1论事件驱动"><a href="#3-1论事件驱动" class="headerlink" title="3.1论事件驱动"></a>3.1论事件驱动</h3><ol>
<li>通常，我们写<strong>服务器处理模型的程序时，有以下几种模型</strong>：<ol>
<li>（1）每收到一个请求，创建一个新的进程，来处理该请求；</li>
<li>（2）每收到一个请求，创建一个新的线程，来处理该请求；</li>
<li>（3）每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求</li>
</ol>
</li>
<li>上面的几种方式，各有千秋：<ol>
<li>第（1）中方法，由于创建新的进程:实现比较简单，但开销比较大，导致服务器性能比较差。</li>
<li>第（2）种方式，由于要涉及到线程的同步，有可能会面临死锁等问题。</li>
<li>第（3）种方式，在写应用程序代码时，逻辑比前面两种都复杂。</li>
</ol>
</li>
<li>综合考虑各方面因素，一般普遍认为<strong>第（3）种方式是大多数网络服务器采用的方式。</strong></li>
</ol>
<h3 id="3-2-看图说话讲事件驱动模型"><a href="#3-2-看图说话讲事件驱动模型" class="headerlink" title="3.2 看图说话讲事件驱动模型"></a>3.2 看图说话讲事件驱动模型</h3><p>在UI编程中，常常要对鼠标点击进行相应，首先如何获得鼠标点击呢？</p>
<ol>
<li><strong>方式一：创建一个线程，该线程一直循环检测是否有鼠标点击，那么这个方式有以下几个缺点</strong>：<ol>
<li>CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？</li>
<li>如果是堵塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘；</li>
<li>如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题；<br>　　所以，该方式是非常不好的。</li>
</ol>
</li>
<li><strong>方式二：就是事件驱动模型</strong><br>目前大部分的UI编程都是事件驱动模型，如很多UI平台都会提供onClick()事件，这个事件就代表鼠标按下事件。事件驱动模型大体思路如下：<ol>
<li>有一个事件（消息）队列；</li>
<li>鼠标按下时，往这个队列中增加一个点击事件（消息）；</li>
<li>有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；</li>
<li>事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；<br><img src="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%95%B4%E7%90%86/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/986023-20170516213233307-426720751.png" alt></li>
</ol>
</li>
<li><strong>事件驱动编程</strong>是一种<strong>网络编程范式</strong>，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。</li>
<li>让我们用例子来比较和对比一下单线程、多线程以及事件驱动编程模型。下图展示了随着时间的推移，这三种模式下程序所做的工作。这个程序有3个任务需要完成，每个任务都在等待I_O操作时阻塞自身。阻塞在I_O操作上所花费的时间已经用灰色框标示出来了。<br><img src="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%95%B4%E7%90%86/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/986023-20170516213325916-254282572.png" alt><ul>
<li>在单线程同步模型中，任务按照顺序执行。如果某个任务因为I/O而阻塞，其他所有的任务都必须等待，直到它完成之后它们才能依次执行。这种明确的执行顺序和串行化处理的行为是很容易推断得出的。如果任务之间并没有互相依赖的关系，但仍然需要互相等待的话这就使得程序不必要的降低了运行速度。</li>
<li>在多线程版本中，这3个任务分别在独立的线程中执行。这些线程由操作系统来管理，在多处理器系统上可以并行处理，或者在单处理器系统上交错执行。这使得当某个线程阻塞在某个资源的同时其他线程得以继续执行。与完成类似功能的同步程序相比，这种方式更有效率，但程序员必须写代码来保护共享资源，防止其被多个线程同时访问。多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题，如果实现不当就会导致出现微妙且令人痛不欲生的bug。</li>
<li>在事件驱动版本的程序中，3个任务交错执行，但仍然在一个单独的线程控制中。当处理I_O或者其他昂贵的操作时，注册一个回调到事件循环中，然后当I_O操作完成时继续执行。回调描述了该如何处理某个事件。事件循环轮询所有的事件，当事件到来时将它们分配给等待处理事件的回调函数。这种方式让程序尽可能的得以执行而不需要用到额外的线程。事件驱动型程序比多线程程序更容易推断出行为，因为程序员不需要关心线程安全问题。</li>
</ul>
</li>
<li>当我们面对如下的环境时，事件驱动模型通常是一个好的选择：<ul>
<li>程序中有许多任务，而且…</li>
<li>任务之间高度独立（因此它们不需要互相通信，或者等待彼此）而且…</li>
<li>在等待事件到来时，某些任务会阻塞。</li>
<li>当应用程序需要在任务间共享可变的数据时，这也是一个不错的选择，因为这里不需要采用同步处理。</li>
<li>网络应用程序通常都有上述这些特点，这使得它们能够很好的契合事件驱动编程模型。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E8%A1%A5%E5%85%85/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E8%A1%A5%E5%85%85/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">事件驱动编程模型 == 异步编程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 05:57:00" itemprop="dateCreated datePublished" datetime="2020-04-08T05:57:00+08:00">2020-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 16:20:16" itemprop="dateModified" datetime="2020-05-04T16:20:16+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-linux-%E8%A1%A5%E5%85%85/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_计算机系统/linux/补充</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E8%A1%A5%E5%85%85/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="事件驱动编程模型 == 异步编程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月8日 下午5:57</p>
<h3 id="关键：理解了buffer的作用"><a href="#关键：理解了buffer的作用" class="headerlink" title="关键：理解了buffer的作用"></a>关键：理解了buffer的作用</h3><p>其实就是有一个buffer用作缓存(事件（消息）队列)，当动作发生的时候，我并不执行，而是将它扔到一个buffer里，让另外的处理线程去执行，这个处理线程就会不间断的执行buffer里的任务，<strong>如果当前的动作发生了阻塞</strong>，那么处理线程立刻再把它放到这个buffer中(注册一个回调到事件循环中)，找下一个进行执行，直到buffer为空</p>
<h1 id="事件驱动编程模型"><a href="#事件驱动编程模型" class="headerlink" title="事件驱动编程模型"></a>事件驱动编程模型</h1><p><a href="https://www.cnblogs.com/zingp/p/6863170.html#_labelTop" target="_blank" rel="noopener">IO模式和IO多路复用 - ZingpLiu - 博客园</a></p>
<h3 id="3-1论事件驱动"><a href="#3-1论事件驱动" class="headerlink" title="3.1论事件驱动"></a>3.1论事件驱动</h3><ol>
<li>通常，我们写<strong>服务器处理模型的程序时，有以下几种模型</strong>：<ol>
<li>（1）每收到一个请求，创建一个新的进程，来处理该请求；</li>
<li>（2）每收到一个请求，创建一个新的线程，来处理该请求；</li>
<li>（3）每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求</li>
</ol>
</li>
<li>上面的几种方式，各有千秋：<ol>
<li>第（1）中方法，由于创建新的进程:实现比较简单，但开销比较大，导致服务器性能比较差。</li>
<li>第（2）种方式，由于要涉及到线程的同步，有可能会面临死锁等问题。</li>
<li>第（3）种方式，在写应用程序代码时，逻辑比前面两种都复杂。</li>
</ol>
</li>
<li>综合考虑各方面因素，一般普遍认为<strong>第（3）种方式是大多数网络服务器采用的方式。</strong></li>
</ol>
<h3 id="3-2-看图说话讲事件驱动模型"><a href="#3-2-看图说话讲事件驱动模型" class="headerlink" title="3.2 看图说话讲事件驱动模型"></a>3.2 看图说话讲事件驱动模型</h3><p>在UI编程中，常常要对鼠标点击进行相应，首先如何获得鼠标点击呢？</p>
<ol>
<li><strong>方式一：创建一个线程，该线程一直循环检测是否有鼠标点击，那么这个方式有以下几个缺点</strong>：<ol>
<li>CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？</li>
<li>如果是堵塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘；</li>
<li>如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题；<br>　　所以，该方式是非常不好的。</li>
</ol>
</li>
<li><strong>方式二：就是事件驱动模型</strong><br>目前大部分的UI编程都是事件驱动模型，如很多UI平台都会提供onClick()事件，这个事件就代表鼠标按下事件。事件驱动模型大体思路如下：<ol>
<li>有一个事件（消息）队列；</li>
<li>鼠标按下时，往这个队列中增加一个点击事件（消息）；</li>
<li>有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；</li>
<li>事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；<br><img src="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E8%A1%A5%E5%85%85/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/986023-20170516213233307-426720751.png" alt></li>
</ol>
</li>
<li><strong>事件驱动编程</strong>是一种<strong>网络编程范式</strong>，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。</li>
<li>让我们用例子来比较和对比一下单线程、多线程以及事件驱动编程模型。下图展示了随着时间的推移，这三种模式下程序所做的工作。这个程序有3个任务需要完成，每个任务都在等待I_O操作时阻塞自身。阻塞在I_O操作上所花费的时间已经用灰色框标示出来了。<br><img src="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E8%A1%A5%E5%85%85/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%20==%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/986023-20170516213325916-254282572.png" alt><ul>
<li>在单线程同步模型中，任务按照顺序执行。如果某个任务因为I/O而阻塞，其他所有的任务都必须等待，直到它完成之后它们才能依次执行。这种明确的执行顺序和串行化处理的行为是很容易推断得出的。如果任务之间并没有互相依赖的关系，但仍然需要互相等待的话这就使得程序不必要的降低了运行速度。</li>
<li>在多线程版本中，这3个任务分别在独立的线程中执行。这些线程由操作系统来管理，在多处理器系统上可以并行处理，或者在单处理器系统上交错执行。这使得当某个线程阻塞在某个资源的同时其他线程得以继续执行。与完成类似功能的同步程序相比，这种方式更有效率，但程序员必须写代码来保护共享资源，防止其被多个线程同时访问。多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题，如果实现不当就会导致出现微妙且令人痛不欲生的bug。</li>
<li>在事件驱动版本的程序中，3个任务交错执行，但仍然在一个单独的线程控制中。当处理I_O或者其他昂贵的操作时，注册一个回调到事件循环中，然后当I_O操作完成时继续执行。回调描述了该如何处理某个事件。事件循环轮询所有的事件，当事件到来时将它们分配给等待处理事件的回调函数。<strong>这种方式让程序尽可能的得以执行而不需要用到额外的线程</strong>。事件驱动型程序比多线程程序更容易推断出行为，因为程序员不需要关心线程安全问题。</li>
</ul>
</li>
<li>当我们面对如下的环境时，事件驱动模型通常是一个好的选择：<ul>
<li>程序中有许多任务，而且…</li>
<li>任务之间高度独立（因此它们不需要互相通信，或者等待彼此）而且…</li>
<li>在等待事件到来时，某些任务会阻塞。</li>
<li>当应用程序需要在任务间共享可变的数据时，这也是一个不错的选择，因为这里不需要采用同步处理。</li>
<li>网络应用程序通常都有上述这些特点，这使得它们能够很好的契合事件驱动编程模型。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E8%A1%A5%E5%85%85/%E5%B9%BF%E4%B9%89%E7%9A%84IO%E6%A8%A1%E5%9E%8B%EF%BC%9A%E9%98%BB%E5%A1%9EIO-%3E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BF%99%E8%BD%AE%E8%AF%A2IO-%3Eselectepoll%E6%97%A0%E5%B7%AE%E5%88%AB%E8%BD%AE%E8%AF%A2%E4%BB%A3%E7%90%86-%3E%20epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E8%A1%A5%E5%85%85/%E5%B9%BF%E4%B9%89%E7%9A%84IO%E6%A8%A1%E5%9E%8B%EF%BC%9A%E9%98%BB%E5%A1%9EIO-%3E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BF%99%E8%BD%AE%E8%AF%A2IO-%3Eselectepoll%E6%97%A0%E5%B7%AE%E5%88%AB%E8%BD%AE%E8%AF%A2%E4%BB%A3%E7%90%86-%3E%20epoll/" class="post-title-link" itemprop="url">广义的IO模型：阻塞I/O->非阻塞忙轮询I/O->select/epoll无差别轮询代理-> epoll</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 03:25:00" itemprop="dateCreated datePublished" datetime="2020-04-08T03:25:00+08:00">2020-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 16:19:51" itemprop="dateModified" datetime="2020-05-04T16:19:51+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-linux-%E8%A1%A5%E5%85%85/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_计算机系统/linux/补充</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/08/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E8%A1%A5%E5%85%85/%E5%B9%BF%E4%B9%89%E7%9A%84IO%E6%A8%A1%E5%9E%8B%EF%BC%9A%E9%98%BB%E5%A1%9EIO-%3E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BF%99%E8%BD%AE%E8%AF%A2IO-%3Eselectepoll%E6%97%A0%E5%B7%AE%E5%88%AB%E8%BD%AE%E8%AF%A2%E4%BB%A3%E7%90%86-%3E%20epoll/" class="post-meta-item leancloud_visitors" data-flag-title="广义的IO模型：阻塞I/O->非阻塞忙轮询I/O->select/epoll无差别轮询代理-> epoll" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月8日 下午3:25</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>下面这篇文章其实写的非常好，我反复多了多次才明白其中的关键：<ol>
<li>首先，你需要理解流的概念：<ol>
<li>其实我们在server定义socket的时候<code>server = socket(AF_INET, SOCK_STREAM)</code>，这个定义会产生一个流，只不过在没有client进行连接的时候，这个流中的内容为空而已。</li>
<li>在代码中我就一直疑惑：<strong>流数组</strong>是从哪里来的？<ol>
<li>上面我们知道定义socket会产生一个流(“缓冲区空”)，当client连接server的时候，这个流中就会有信息在传递(“缓冲区非空”)</li>
<li>这里比较特殊的一个地方是：<strong>socket流中的信息也是一个流</strong>，代表着不同client与server的链接。</li>
<li>当有n个client与server进行连接的时候，加上原本socket，在当前进程中，就会有n+1个流对象</li>
</ol>
</li>
</ol>
</li>
<li>整个的IO模型，其实就是信息在流上进行一个个进行传递的过程。有些流中传递的还是流，有些流中传递的时候真正的byte数据。</li>
<li>IO模型与网络IO模型的关系：<ol>
<li>我目前见过做多的就是网络IO模型，当你把client与server之间的socket连接理解成一个流的时候，你就会发现其实就是IO模型，不要因为加上了网络就觉得难以理解</li>
<li>IO模型的基础操作单位是流，具体你是什么流(文件，socket，pipe)对于IO模型来说其实是透明的，流这个抽象就能把具体的子类对上层隐藏。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="python代码实现："><a href="#python代码实现：" class="headerlink" title="python代码实现："></a>python代码实现：</h3><p><a href="https://blog.csdn.net/u013210620/article/details/78733743" target="_blank" rel="noopener">python基础-io模型、阻塞、非阻塞、io多路复用_Python_金丙坤-CSDN博客</a><br><strong>io模型、阻塞、非阻塞、io多路复用</strong>这四种对应的client，server代码！</p>
<h3 id="概念的理解："><a href="#概念的理解：" class="headerlink" title="概念的理解："></a>概念的理解：</h3><p>补充：<a href="https://blog.csdn.net/feitianxuxue/article/details/17078179" target="_blank" rel="noopener">Epoll之ET、LT模式_网络_feitianxuxue的专栏-CSDN博客</a></p>
<ol>
<li><p>在使用epoll时，在函数 epoll_ctl中如果不设定，epoll_event 的event默认为LT（水平触发）模式。</p>
</li>
<li><p>LT模式</p>
<ol>
<li><strong>使用LT模式意味着只要fd处于可读或者可写状态，每次epoll_wait都会返回该fd</strong>，这样的话会带来很大的系统开销，且处理时候每次都需要把这些fd轮询一遍，如果fd的数量巨大，不管有没有事件发生，epoll_wait都会触发这些fd的轮询判断。</li>
</ol>
</li>
<li><p>ET模式：</p>
<ol>
<li>在ET模式下，当有事件发生时，系统只会通知你一次，即在调用epoll_wait返回fd后，不管这个事件你处理还是没处理，处理完没有处理完，当再次调用epoll_wait时，都不会再返回该fd，这样的话程序员要自己保证在事件发生时要及时有效的处理完该事件。</li>
</ol>
</li>
<li><p><em>首先我们来定义流的概念</em></p>
<ol>
<li>一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。</li>
<li>不管是文件，还是套接字，还是管道，我们都可以把他们看作流。</li>
</ol>
</li>
<li><p>之后我们来讨论<strong>I/O的操作</strong>，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，<strong>但是流中还没有数据</strong>，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），这时候该怎么办？</p>
<ul>
<li>阻塞。阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。</li>
<li>非阻塞<strong>忙</strong>轮询。接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”<ul>
<li>很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。</li>
<li>大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。</li>
</ul>
</li>
</ul>
</li>
<li><p>为了了解阻塞是如何进行的，我们来讨论<strong>缓冲区</strong>，以及内核缓冲区，最终把I_O事件解释清楚。缓冲区的引入是为了减少频繁I_O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。<br>假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。</p>
<ul>
<li><strong>假设一开始内核缓冲区是空的，B作为读出方，被阻塞着</strong>。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。</li>
<li>但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，<strong>告诉进程A，你该等等（阻塞）了</strong>，我们把这个事件定义为“缓冲区满”。</li>
<li>假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”</li>
<li>也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。<strong>这个时候内核就告诉B，你需要阻塞了！</strong>，我们把这个时间定为“缓冲区空”。</li>
<li>这四个情形涵盖了四个I_O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。 <em>_<strong>_这四个I_O事件是进行阻塞同步的根本</strong></em> 。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。</li>
</ul>
</li>
<li><p>然后我们来说说<strong>阻塞I/O的缺点</strong>。</p>
<ol>
<li>阻塞I_O模式下，一个线程只能处理一个流的I_O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。</li>
</ol>
</li>
<li><p>于是再来考虑<strong>非阻塞忙轮询的I/O方式</strong>，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> true &#123;</span><br><span class="line">	<span class="keyword">for</span> I <span class="keyword">in</span> stream[]&#123; <span class="comment">#一直轮询</span></span><br><span class="line">		<span class="keyword">if</span> I has data</span><br><span class="line">			read until unavailable</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I_O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I_O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。</li>
</ul>
</li>
<li><p>为了避免CPU空转，可以引进了<strong>一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）</strong>。这个代理比较厉害，可以同时观察许多流的I_O事件，在空闲的时候，<em>**_会把当前线程阻塞掉</em>**_，当有一个或多个流有I_O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。代码长这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> true &#123;</span><br><span class="line">	select(streams[]) <span class="comment"># 增加的这步</span></span><br><span class="line">	<span class="keyword">for</span> I <span class="keyword">in</span> streams[] &#123;</span><br><span class="line">		<span class="keyword">if</span> I has data</span><br><span class="line">			read until unavailable</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>于是，如果没有I_O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I_O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能<strong>无差别轮询</strong>所有流，找出能读出数据，或者写入数据的流，对他们进行操作。</li>
<li>但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。再次</li>
</ul>
</li>
<li><p><strong>说了这么多，终于能好好解释epoll了</strong></p>
<ul>
<li>Epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I_O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(k)，k为产生I_O事件的流的个数，也有认为O(1)的[更新 1]）</li>
<li>epoll实现机制：<ul>
<li><strong>使用epoll的时候，内核会维护一个就绪的链表，这个链表里面的东西就是”那些发生了I/O事件的流”</strong>。</li>
<li>而这些文件描述符是如何被添加到就绪链表里面的呢？是通过注册的那些回调函数实现的。</li>
<li><em>而怎么知道这些文件描述符上发生的是什么事件呢？这个就需要我们自己在代码里面去判断了。epoll这个函数返回的只是那些发生了事件的文件描述符。</em> 因为这些事件是你自己给这个文件描述符的，所以你可以通过代码判断发生了什么I/O事件。</li>
<li>于是就有”epoll只会把哪个流发生了怎样的I/O事件通知我们”。</li>
</ul>
</li>
<li>在讨论epoll的实现细节之前，先把epoll的相关操作列出[更新 2]：<ol>
<li>epoll_create 创建一个epoll对象，一般epollfd = epoll_create()</li>
<li>epoll_ctl （epoll_add_epoll_del的合体），往epoll对象中增加_删除某一个流的某一个事件</li>
<li>比如</li>
<li>epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);有缓冲区内有数据时epoll_wait返回</li>
<li>epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);缓冲区可写入时epoll_wait返回</li>
<li>epoll_wait(epollfd,…)等待直到注册的事件发生</li>
<li>（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。</li>
</ol>
</li>
<li>一个epoll模式的代码大概的样子是：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> true &#123;</span><br><span class="line">	active_stream[] = epoll_wait(epollfd) <span class="comment"># 关键步骤</span></span><br><span class="line">	<span class="keyword">for</span> I <span class="keyword">in</span> active_stream[] &#123;</span><br><span class="line">		read <span class="keyword">or</span> write till unavailable</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li>限于篇幅，这里只讲了揭示原理性的东西，至于epoll的使用细节，请参考man和google，实现细节，请参阅linux kernel source。</li>
<li>[更新1]: 原文为O(1)，但实际上O(k)更为准确</li>
<li>[更新2]: 原文所列第二点说法让人产生EPOLLIN/EPOLLOUT等同于“缓冲区非空”和“缓冲区非满”的事件，但并非如此，详细可以Google关于epoll的边缘触发和水平触发。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E9%9B%B6%E6%95%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E9%9B%B6%E6%95%A3/" class="post-title-link" itemprop="url">零散</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 11:30:00" itemprop="dateCreated datePublished" datetime="2020-04-06T11:30:00+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 16:20:16" itemprop="dateModified" datetime="2020-05-04T16:20:16+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AF%AD%E8%A8%80-c/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_语言/c++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E9%9B%B6%E6%95%A3/" class="post-meta-item leancloud_visitors" data-flag-title="零散" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月6日 下午11:30</p>
<h4 id="strcpy和strlen"><a href="#strcpy和strlen" class="headerlink" title="strcpy和strlen"></a>strcpy和strlen</h4><ol>
<li>Strcpy是字符串拷贝函数，原型：<ol>
<li><code>char *strcpy(char* dest, const char *src);</code></li>
<li>从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。</li>
</ol>
</li>
<li>Strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</li>
</ol>
<h4 id="全局变量和静态全局变量的区别"><a href="#全局变量和静态全局变量的区别" class="headerlink" title="全局变量和静态全局变量的区别"></a>全局变量和静态全局变量的区别</h4><p><img src="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E9%9B%B6%E6%95%A3/33220680_1587611285754_v2-189c3a1df92df112232516471e2917fd_1440w.png" alt></p>
<p><a href="https://blog.csdn.net/u012223913/article/details/51181761" target="_blank" rel="noopener">关于int、short int、long int、long long 的区别_C/C++_Adrianna的专栏-CSDN博客</a></p>
<ol>
<li>在标准中，并没有规定long一定要比int长，也没有规定short要比int短。</li>
<li>标准是这么说的:长整型至少和整型一样长，整型至少和短整型一样长。</li>
<li>这个的规则同样适用于浮点型long double至少和double一样长，double至少和float一样长。</li>
<li>至于如何实现要看编译器厂商.</li>
</ol>
<p>从双刃剑的角度去总结<br><a href="https://blog.csdn.net/lms1008611/article/details/81408236" target="_blank" rel="noopener">C++中类的(static)静态成员变量与(static)静态成员函数_C/C++_年少轻狂，幸福时光-CSDN博客</a><br>static能怎样，不能怎样</p>
<p><a href="https://blog.csdn.net/qq_32599479/article/details/80703759" target="_blank" rel="noopener">static和const关键字的作用_JavaScript_许政的博客-CSDN博客</a><br>const修饰哪些，有哪些使用场景</p>
<h4 id="i和i-的实现"><a href="#i和i-的实现" class="headerlink" title="++i和i++的实现"></a>++i和i++的实现</h4><ol>
<li>++i 实现：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;  <span class="keyword">int</span>::<span class="keyword">operator</span>++（）</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> +=<span class="number">1</span>；</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>i++ 实现：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="keyword">int</span>::<span class="keyword">operator</span>（<span class="keyword">int</span>）</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> oldValue = *<span class="keyword">this</span>；</span><br><span class="line">	++（*<span class="keyword">this</span>）；</span><br><span class="line">	<span class="keyword">return</span> oldValue；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><a href="https://www.jianshu.com/p/5cb9800b6697" target="_blank" rel="noopener">C++进阶–类型转换，你看我就够了 - 简书</a></p>
<ol>
<li><strong>C++风格的强制转换其他的好处是</strong><ol>
<li>C++中风格是static_cast<type>(content)。C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。 </type></li>
</ol>
</li>
<li>reinterpret_cast：<strong>重解析类型转换</strong><ul>
<li>可以用于任意类型的<strong>指针之间的转换</strong>，对转换的结果不做任何保证</li>
</ul>
</li>
<li>dynamic_cast：<ul>
<li>这种其实也是不被推荐使用的，更多使用static_cast，dynamic本身只能用于存在虚函数的父子关系的强制类型转换，对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常</li>
<li><strong>可以动态的来判断当前对象的真实类型</strong><ul>
<li><a href="https://www.jianshu.com/p/5cb9800b6697" target="_blank" rel="noopener">C++进阶–类型转换，你看我就够了 - 简书</a>代码</li>
</ul>
</li>
</ul>
</li>
<li>const_cast：<ul>
<li>对于未定义const版本的成员函数，我们通常需要使用const_cast来去除const引用对象的const，完成函数调用。</li>
<li>另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。</li>
</ul>
</li>
<li>static_cast：<ul>
<li><strong>能使用隐式转换的地方，均可以使用static_cast转换</strong></li>
<li><strong>如果类型不兼容，使用static_cast编译检查，会报错</strong>，不用等到运行阶段</li>
</ul>
</li>
</ol>
<h4 id="说说你了解的RTTI"><a href="#说说你了解的RTTI" class="headerlink" title="说说你了解的RTTI"></a>说说你了解的RTTI</h4><p>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info</p>
<h4 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h4><ol>
<li><strong>默认的继承访问权</strong>：【继承下】<ol>
<li>class默认的是private,strcut默认的是public。</li>
<li>当然，到底默认是public继承还是private继承，取决于子类而不是基类。意思是，struct可以继承class，同样class也可以继承struct，那么默认的继承访问权限是看子类到底是用的struct还是class。</li>
</ol>
</li>
<li><strong>成员变量默认访问权限</strong>：【非继承下】<ol>
<li>struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</li>
</ol>
</li>
<li>有代码实验：<a href="https://blog.csdn.net/alidada_blog/article/details/83419757" target="_blank" rel="noopener">【C++】struct和class的区别_C/C++_alidada_blog的博客-CSDN博客</a></li>
</ol>
<h4 id="C-中可以定义引用数据成员吗？"><a href="#C-中可以定义引用数据成员吗？" class="headerlink" title="C++中可以定义引用数据成员吗？"></a>C++中可以定义引用数据成员吗？</h4><p><a href="https://blog.csdn.net/lazyq7/article/details/48186291" target="_blank" rel="noopener">C/C++ - 类中成员变量是引用_C/C++_lazyq7的博客-CSDN博客</a></p>
<ol>
<li><strong>所有的引用自带要求</strong>，并不一定是在类中：<ol>
<li>引用在定义时必须初始化，否则编译时便会报错。</li>
</ol>
</li>
<li>根据1，我们可以推得在类中，如何使用引用数据成员：<ol>
<li>构造函数：<ol>
<li>引用类型的成员变量的类，<strong>不能有缺省构造函数</strong></li>
<li>不能直接在构造函数里初始化，<strong>必须用到初始化列表</strong><ol>
<li>默认构造函数没有对引用成员提供默认的初始化机制，也因此造成引用未初始化的编译错误。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B93%EF%BC%9Aconst/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B93%EF%BC%9Aconst/" class="post-title-link" itemprop="url">专题知识点3：const</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 11:00:00" itemprop="dateCreated datePublished" datetime="2020-04-06T11:00:00+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 19:31:54" itemprop="dateModified" datetime="2020-04-12T19:31:54+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AF%AD%E8%A8%80-c/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_语言/c++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B93%EF%BC%9Aconst/" class="post-meta-item leancloud_visitors" data-flag-title="专题知识点3：const" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月6日 下午11:00</p>
<h4 id="以下四行代码的区别是什么？-const-char-arr-“123”-char-brr-“123”-const-char-crr-“123”-char-drr-“123”"><a href="#以下四行代码的区别是什么？-const-char-arr-“123”-char-brr-“123”-const-char-crr-“123”-char-drr-“123”" class="headerlink" title="以下四行代码的区别是什么？ const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”;"></a>以下四行代码的区别是什么？ const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”;</h4><ol>
<li><code>const char * arr = &quot;123”;</code><ul>
<li>字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</li>
</ul>
</li>
<li><code>char * brr = &quot;123&quot;;</code><ul>
<li>字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改”123”的值</li>
</ul>
</li>
<li><code>const char crr[] = “123”;</code><ul>
<li>这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</li>
</ul>
</li>
<li><code>char drr[] = “123”;</code><ul>
<li>字符串123保存在栈区，可以通过drr去修改</li>
</ul>
</li>
</ol>
<h4 id="Const-修饰指针变量有以下三种情况"><a href="#Const-修饰指针变量有以下三种情况" class="headerlink" title="Const 修饰指针变量有以下三种情况"></a>Const 修饰指针变量有以下三种情况</h4><ul>
<li>A: const 修饰指针指向的内容，则内容为不可变量。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//则指针指向的内容 8 不可改变。简称左定值，因为 const 位于 * 号的左边。</span></span><br></pre></td></tr></table></figure></li>
<li>B: const 修饰指针，则指针为不可变量。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">*p = <span class="number">9</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">int</span>  b = <span class="number">7</span>;</span><br><span class="line">P = &amp;b; <span class="comment">// 错误</span></span><br><span class="line"><span class="comment">//对于 const 指针 p 其指向的内存地址不能够被改变，但其内容可以改变。简称，右定向。因为 const 位于 * 号的右边。</span></span><br></pre></td></tr></table></figure></li>
<li>C: const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span>  p = &amp;a;</span><br><span class="line"><span class="comment">//这时，const p 的指向的内容和指向的内存地址都已固定，不可改变。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>C++里是怎么定义常量的？常量存放在内存的哪个位置？</h4><ol>
<li><a href="https://www.runoob.com/cplusplus/cpp-constants-literals.html" target="_blank" rel="noopener">C++ 常量 | 菜鸟教程</a><ol>
<li>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做<strong>字面量</strong>。</li>
<li>常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。</li>
<li>常量就像是常规的变量，只不过常量的值在定义后不能进行修改。</li>
</ol>
</li>
<li>在 C++ 中，有两种简单的定义常量的方式：<ol>
<li>使用 <strong>#define</strong> 预处理器。</li>
<li>使用 <strong>const</strong> 关键字。</li>
</ol>
</li>
<li>常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。<ol>
<li>对于局部对象，常量存放在栈区</li>
<li>对于全局对象，常量存放在全局/静态存储区。</li>
<li>对于字面值常量，常量存放在常量存储区。</li>
</ol>
</li>
<li><strong>代码段</strong>:<ol>
<li><strong>包括只读存储区和文本区</strong>，其中只读存储区存储字符串常量(const就存在这里)，文本区存储程序的机器代码。</li>
</ol>
</li>
<li><a href="https://blog.csdn.net/duan19920101/article/details/50989431" target="_blank" rel="noopener">C++内存分配方式详解(堆、栈、自由存储区、全局/静态存储区和常量存储区)_C/C++_那年聪聪-CSDN博客</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  a=<span class="number">0</span>;   全局初始化区 .data   </span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p1;   全局未初始化区 .bss  </span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">int</span>  b; <span class="comment">//栈    </span></span><br><span class="line">  <span class="keyword">char</span>  s[]=<span class="string">"abc"</span>; <span class="comment">//栈    </span></span><br><span class="line">  <span class="keyword">char</span>  *p2; <span class="comment">//栈    </span></span><br><span class="line">  <span class="keyword">char</span>  *p3=<span class="string">"123456"</span>; <span class="comment">//123456/0在常量区 .text中的_const，p3在栈上。    </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>；<span class="comment">//全局（静态）初始化区  .data  </span></span><br><span class="line">  p1 =  (<span class="keyword">char</span>  *)<span class="built_in">malloc</span>(<span class="number">10</span>);  <span class="comment">//分配得来得10和20字节的区域就在堆区</span></span><br><span class="line">  p2  = (<span class="keyword">char</span>  *)<span class="built_in">malloc</span>(<span class="number">20</span>);       </span><br><span class="line">  <span class="built_in">strcpy</span>(p3,<span class="string">"123456"</span>); <span class="comment">//123456/0放在常量区，编译器可能会将它与p3所指向的"123456"  优化成一个地方。    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>堆和栈究竟有什么区别？<ol>
<li><a href="https://blog.csdn.net/duan19920101/article/details/50989431" target="_blank" rel="noopener">C++内存分配方式详解(堆、栈、自由存储区、全局/静态存储区和常量存储区)_C/C++_那年聪聪-CSDN博客</a></li>
</ol>
</li>
</ol>
<h4 id="Const修饰成员函数的目的是什么？"><a href="#Const修饰成员函数的目的是什么？" class="headerlink" title="Const修饰成员函数的目的是什么？"></a>Const修饰成员函数的目的是什么？</h4><p>Const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。</p>
<h4 id="同时定义了两个函数，一个带const，一个不带，会有问题吗？"><a href="#同时定义了两个函数，一个带const，一个不带，会有问题吗？" class="headerlink" title="同时定义了两个函数，一个带const，一个不带，会有问题吗？"></a>同时定义了两个函数，一个带const，一个不带，会有问题吗？</h4><p>不会，这相当于函数的重载。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%864%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%864%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">专题知识4：函数调用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 10:49:00" itemprop="dateCreated datePublished" datetime="2020-04-06T10:49:00+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 19:31:55" itemprop="dateModified" datetime="2020-04-12T19:31:55+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AF%AD%E8%A8%80-c/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_语言/c++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%864%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" class="post-meta-item leancloud_visitors" data-flag-title="专题知识4：函数调用" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>121</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月6日 下午10:49</p>
<h4 id="C语言是怎么进行函数调用的？"><a href="#C语言是怎么进行函数调用的？" class="headerlink" title="C语言是怎么进行函数调用的？"></a>C语言是怎么进行函数调用的？</h4><p><a href="bear://x-callback-url/open-note?id=368E9E82-DAFC-435D-BB53-B2E6B57AECAF-14547-0001419E213E6D19">C++栈调用过程：C++自带功能</a></p>
<h4 id="C-函数栈空间的最大值"><a href="#C-函数栈空间的最大值" class="headerlink" title="C++函数栈空间的最大值"></a>C++函数栈空间的最大值</h4><p>默认是1M，不过可以调整</p>
<h4 id="C语言参数压栈顺序？"><a href="#C语言参数压栈顺序？" class="headerlink" title="C语言参数压栈顺序？"></a>C语言参数压栈顺序？</h4><p>从右到左</p>
<h4 id="C-如何处理返回值？"><a href="#C-如何处理返回值？" class="headerlink" title="C++如何处理返回值？"></a>C++如何处理返回值？</h4><p>生成一个临时变量，把它的引用作为函数参数传入函数内。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B92%EF%BC%9A%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8(%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E5%A4%9A%E6%80%81%E3%80%81%E9%87%8D%E5%86%99)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B92%EF%BC%9A%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8(%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E5%A4%9A%E6%80%81%E3%80%81%E9%87%8D%E5%86%99)/" class="post-title-link" itemprop="url">专题知识点2：虚函数表(虚函数、析构函数、多态、重写)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 10:34:00" itemprop="dateCreated datePublished" datetime="2020-04-06T10:34:00+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 19:31:55" itemprop="dateModified" datetime="2020-04-12T19:31:55+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AF%AD%E8%A8%80-c/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_语言/c++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B92%EF%BC%9A%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8(%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E5%A4%9A%E6%80%81%E3%80%81%E9%87%8D%E5%86%99)/" class="post-meta-item leancloud_visitors" data-flag-title="专题知识点2：虚函数表(虚函数、析构函数、多态、重写)" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月6日 下午10:34</p>
<h4 id="为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数"><a href="#为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数" class="headerlink" title="为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数"></a>为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</h4><ol>
<li>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后<strong>使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏</strong>。</li>
<li>C++默认的析构函数不是虚函数是因为虚函数需要额外的<strong>虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</li>
</ol>
<h4 id="C-中析构函数的作用"><a href="#C-中析构函数的作用" class="headerlink" title="C++中析构函数的作用"></a>C++中析构函数的作用</h4><ol>
<li>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</li>
<li>析构函数名也应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</li>
<li>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</li>
<li>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</li>
<li>类析构顺序：<ol>
<li>1）派生类本身的析构函数；</li>
<li>2）对象成员析构函数；</li>
<li>3）基类析构函数。</li>
</ol>
</li>
</ol>
<h4 id="静态函数和虚函数的区别"><a href="#静态函数和虚函数的区别" class="headerlink" title="静态函数和虚函数的区别"></a>静态函数和虚函数的区别</h4><ol>
<li>静态函数在编译的时候就已经确定运行时机</li>
<li>虚函数在运行的时候动态绑定。虚函数因为用了<strong>虚函数表机制</strong>，调用的时候会增加一次内存开销</li>
</ol>
<h4 id="说一下C-中static关键字的作用"><a href="#说一下C-中static关键字的作用" class="headerlink" title="说一下C++中static关键字的作用"></a>说一下C++中static关键字的作用</h4><ol>
<li>对于函数定义和代码块之外的<strong>变量声明</strong><ol>
<li>static修改标识符的链接属性，由默认的external变为internal，作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。</li>
</ol>
</li>
<li>对于代码块内部的<strong>变量声明</strong><ol>
<li>static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。</li>
</ol>
</li>
<li>对于被static修饰的<strong>普通函数</strong><ol>
<li>其只能在定义它的源文件中使用，不能在其他源文件中被引用</li>
</ol>
</li>
<li>对于被static修饰的<strong>类成员变量和成员函数</strong><ol>
<li>它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。</li>
</ol>
</li>
</ol>
<h4 id="虚函数和多态"><a href="#虚函数和多态" class="headerlink" title="虚函数和多态"></a>虚函数和多态</h4><ol>
<li>多态的实现主要分为静态多态和动态多态<ol>
<li>静态多态主要是重载，在编译的时候就已经确定；</li>
<li>动态多态是用虚函数机制实现的，在运行期间动态绑定。</li>
<li>举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。</li>
</ol>
</li>
<li><strong>虚函数的实现</strong>：<ol>
<li>::在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。::</li>
<li>如果<strong>在基类中使用vitual虚函数</strong>，::那么编译器看的是指针的内容，而不是它的类型::。 <a href="bear://x-callback-url/open-note?id=76FE359B-D849-4A4E-A33E-6B0753651837-10863-0001CB16F6A2DE3C">C++ 多态 ：一起看1</a></li>
</ol>
</li>
</ol>
<h4 id="重载-重写"><a href="#重载-重写" class="headerlink" title="重载 重写"></a>重载 重写</h4><ol>
<li>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中</li>
<li>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B91%EF%BC%9A%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B91%EF%BC%9A%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">专题知识点1：指针专题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 09:14:00" itemprop="dateCreated datePublished" datetime="2020-04-06T09:14:00+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 16:19:51" itemprop="dateModified" datetime="2020-05-04T16:19:51+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AF%AD%E8%A8%80-c/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_语言/c++</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/06/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AF%AD%E8%A8%80/c++/%E4%B8%93%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B91%EF%BC%9A%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/" class="post-meta-item leancloud_visitors" data-flag-title="专题知识点1：指针专题" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月6日 下午9:14</p>
<h4 id="请说一下C-C-中指针和引用的区别？"><a href="#请说一下C-C-中指针和引用的区别？" class="headerlink" title="请说一下C/C++ 中指针和引用的区别？"></a>请说一下C/C++ 中指针和引用的区别？</h4><ol>
<li><strong>指针有自己的一块空间，是一种类型</strong>，而<strong>引用只是一个别名</strong>；</li>
<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li>
<li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</li>
<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</li>
<li>可以有const指针，但是没有const引用；</li>
<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li>
<li>指针可以有多级指针（p），而引用至于一级；</li>
<li>指针和引用使用++运算符的意义不一样；</li>
<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li>
</ol>
<h4 id="请你说一下你理解的c-中的smart-pointer四个智能指针：-shared-ptr-unique-ptr-weak-ptr-auto-ptr"><a href="#请你说一下你理解的c-中的smart-pointer四个智能指针：-shared-ptr-unique-ptr-weak-ptr-auto-ptr" class="headerlink" title="请你说一下你理解的c++中的smart pointer四个智能指针： shared_ptr,unique_ptr,weak_ptr,auto_ptr"></a>请你说一下你理解的c++中的smart pointer四个智能指针： shared_ptr,unique_ptr,weak_ptr,auto_ptr</h4><ol>
<li>C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。</li>
<li><strong>为什么要使用智能指针：</strong><ol>
<li>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</li>
</ol>
</li>
<li>auto_ptr（c++98的方案，cpp11已经抛弃）<ol>
<li>采用所有权模式。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt; <span class="built_in">string</span>&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (“I reigned lonely as a cloud.”))</span></span>;</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; p2;</span><br><span class="line">p2 = p1; <span class="comment">//auto_ptr不会报错.</span></span><br></pre></td></tr></table></figure></li>
<li>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</li>
</ol>
</li>
<li>unique_ptr（替换auto_ptr）<ol>
<li>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</li>
<li>采用所有权模式，还是上面那个例子<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (“<span class="keyword">auto</span>”))</span></span>;   <span class="comment">//#4</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4；                       <span class="comment">//#5</span></span><br><span class="line">P4 = p3;<span class="comment">//此时会报错！！</span></span><br></pre></td></tr></table></figure></li>
<li>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</li>
<li>另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (“hello world”))</span></span>;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (“You”));   <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure></li>
<li>其中# 1留下悬挂的unique_ptr(pu1)，这可能导致危害。而 # 2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</li>
<li>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(“hello”);</span><br><span class="line">ps2 = <span class="built_in">move</span>(ps1);</span><br><span class="line">ps1 = demo(“Alexia”);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>shared_ptr<ol>
<li>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。<strong>从名字share就可以看出了资源可以被多个指针共享</strong>，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</li>
<li><strong>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的),</strong> 在使用引用计数的机制上提供了可以共享所有权的智能指针。</li>
<li>成员函数：<ol>
<li>use_count 返回引用计数的个数</li>
<li>unique 返回是否是独占所有权( use_count 为 1)</li>
<li>Swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</li>
<li>Reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</li>
<li>Get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</int></li>
</ol>
</li>
</ol>
</li>
<li>weak_ptr<ol>
<li>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. </li>
<li><strong>weak_ptr只是提供了对管理对象的一个访问手段</strong>。</li>
<li>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</li>
<li>weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">	~A()</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;“A <span class="keyword">delete</span>\n”;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">	~B()</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;“B <span class="keyword">delete</span>\n<span class="string">";</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void fun()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	shared_ptr&lt;B&gt; pb(new B());</span></span><br><span class="line"><span class="string">	shared_ptr&lt;A&gt; pa(new A());</span></span><br><span class="line"><span class="string">	pb-&gt;pa_ = pa;</span></span><br><span class="line"><span class="string">	pa-&gt;pb_ = pb;</span></span><br><span class="line"><span class="string">	cout&lt;&lt;pb.use_count()&lt;&lt;endl;</span></span><br><span class="line"><span class="string">	cout&lt;&lt;pa.use_count()&lt;&lt;endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	fun();</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，<strong>当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1</strong>，导致跳出函数时资源没有被释放（A B的析构函数没有被调用）</li>
<li>如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</li>
<li><strong>注意的是我们不能通过weak_ptr直接访问对象的方法</strong>，比如B对象中有一个方法print(),我们不能这样访问，<code>pa-&gt;pb_-&gt;print();</code>英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：<code>shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();</code></li>
</ol>
</li>
</ol>
<h4 id="智能指针的内存泄漏如何解决"><a href="#智能指针的内存泄漏如何解决" class="headerlink" title="智能指针的内存泄漏如何解决"></a>智能指针的内存泄漏如何解决</h4><ol>
<li>智能指针的内存泄露是指？<ol>
<li>shared_ptr的循环引用</li>
</ol>
</li>
<li>为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针<ol>
<li>weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</li>
</ol>
</li>
</ol>
<h4 id="请你回答一下野指针是什么？"><a href="#请你回答一下野指针是什么？" class="headerlink" title="请你回答一下野指针是什么？"></a>请你回答一下野指针是什么？</h4><ul>
<li>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</li>
</ul>
<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><ol>
<li>定义<ol>
<li>函数指针是指向函数的指针变量。</li>
<li>函数指针本身首先是一个<strong>指针变量</strong>，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。</li>
<li><strong>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址</strong>。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</li>
</ol>
</li>
<li>用途：<ol>
<li>调用函数和做函数的参数，比如回调函数。</li>
</ol>
</li>
<li>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char * fun(char * p)  &#123;…&#125;       &#x2F;&#x2F; 函数fun</span><br><span class="line">char * (*pf)(char * p);             &#x2F;&#x2F; 函数指针pf</span><br><span class="line">pf &#x3D; fun;                        &#x2F;&#x2F; 函数指针pf指向函数fun</span><br><span class="line">pf(p);                        &#x2F;&#x2F; 通过函数指针pf调用函数fun</span><br></pre></td></tr></table></figure>

</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chenzhiheng.cn/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhiheng Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈志恒的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">将操作系统分解，看看这个庞大的系统中包含哪些子系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-05 10:56:00" itemprop="dateCreated datePublished" datetime="2020-04-05T10:56:00+08:00">2020-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 19:32:44" itemprop="dateModified" datetime="2020-04-12T19:32:44+08:00">2020-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-czh-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-linux-%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">b计算机基础/czh_计算机系统/linux/系统</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="post-meta-item leancloud_visitors" data-flag-title="将操作系统分解，看看这个庞大的系统中包含哪些子系统" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年4月5日 上午10:56</p>
<h3 id="作为软件工程出身的人，我从子系统分解的角度，将操作系统分解，看看这个庞大的系统中包含哪些子系统"><a href="#作为软件工程出身的人，我从子系统分解的角度，将操作系统分解，看看这个庞大的系统中包含哪些子系统" class="headerlink" title="作为软件工程出身的人，我从子系统分解的角度，将操作系统分解，看看这个庞大的系统中包含哪些子系统"></a>作为软件工程出身的人，我从子系统分解的角度，将操作系统分解，看看这个庞大的系统中包含哪些子系统</h3><ol>
<li>项目管理子系统(泛指)<br><img src="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/1c91956b52574b62a4418a7c6993d8bc.jpeg" alt><ol start="2">
<li>项目应该有运行中的状态<ol>
<li>TASK_RUNNING 并不是说进程正在运行，而是表示进程在时刻准备运行的状态。这个时候，要看 CPU 小伙伴有没有空，有空就运行他，没空就得等着。</li>
<li>有时候，进程运行到一半，需要等待某个条件才能运行下去，这个时候只能睡眠。睡眠状态有两种。一种是 TASK_INTERRUPTIBLE，可中断的睡眠状态。这是一种浅睡眠的状态，也就是说，虽然在睡眠，等条件成熟，进程可以被唤醒。</li>
<li>另一种睡眠是 TASK_UNINTERRUPTIBLE，不可中断的睡眠状态。这是一种深度睡眠状态，不可被唤醒，只能死等条件满足。有了一种新的进程睡眠状态，TASK_KILLABLE，可以终止的新睡眠状态。进程处于这种状态中，他的运行原理类似 TASK_UNINTERRUPTIBLE，只不过可以响应致命信号，也即虽然在深度睡眠，但是可以被干掉。</li>
<li>一旦一个进程要结束，先进入的是 EXIT_ZOMBIE 状态，但是这个时候他的父进程还没有使用 wait() 等系统调用来获知他的终止信息，此时进程就成了僵尸进程。<br><img src="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/e2fa348c67ce41ef730048ff9ca4c988.jpeg" alt></li>
</ol>
</li>
</ol>
</li>
<li>权限管理子系统</li>
<li>（编译子系统）<ol>
<li>不属于操作系统的一部分</li>
<li>编译其实是一个需求分析和需求转换的过程</li>
<li>最后生成ELF 格式的项目执行计划书，这个项目执行计划书有总论 ELF Header 的部分，有包含指令的代码段的部分，有包含全局变量的数据段的部分</li>
<li>“你看，每次你接一个项目，总要写成项目执行计划书，CPU 小伙伴们才能执行吧，项目计划书中的一行一行指令运行过程中，免不了要产生一些数据。这些数据要保存在一个地方，这个地方就是会议室（内存）。会议室（内存）被分成一块一块儿的，都编好了号。例如 3F-10，就是三楼十号会议室。这个地址是实实在在的地址，通过这个地址我们就能够定位到物理内存的位置。”</li>
</ol>
</li>
<li>任务管理子系统(专指内核态)<ol>
<li>在 Linux 里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务，由一个统一的结构 task_struct 进行管理。<br><img src="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/75c4d28a9d2daa4acc1107832be84e2d.jpeg" alt></li>
</ol>
</li>
<li>任务调度子系统<ol>
<li>调度要解决的第一个问题是，每一个 CPU 小伙伴每过一段时间，都要想一下，白板上这么多项目，我应该干哪一个？CPU 的队列里面有这么多的进程或者线程，应该取出哪一个来执行？<br><img src="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/10381dbafe0f78d80beb87560a9506af.jpeg" alt></li>
<li>调度要解决的第二个问题是，什么时候切换任务？也即，什么时候，CPU 小伙伴应该停下一个进程，换另一个进程运行？</li>
</ol>
</li>
<li>内存管理子系统<ol>
<li>第一，物理内存的管理，相当于会议室管理员管理会议室；<ol>
<li>对物理内存的管理系统，我们称为伙伴系统<br><img src="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/3fa8123990e5ae2c86859f70a8351f4f.jpeg" alt></li>
</ol>
</li>
<li>第二，虚拟地址的管理，也即在项目组的视角，会议室的虚拟地址应该如何组织；<ol>
<li>有了虚拟地址的管理这个规定以后，项目执行计划书ELF要写入数据的时候，就需要符合里面的规定了，数据不能随便乱放了。规定具体如下：</li>
<li>首先，这么大的虚拟空间一切二，一部分用来放内核的东西，称为内核空间；一部分用来放进程的东西，称为用户空间。</li>
<li>用户空间：<ol>
<li>我们从最低位开始排起，先是 Text Segment、Data Segment 和 BSS Segment。Text Segment 是存放二进制可执行代码的位置，Data Segment 存放静态常量，BSS Segment 存放未初始化的静态变量。这些都是在项目执行计划书里面有的。</li>
<li>接下来是堆段。堆是往高地址增长的，是用来动态分配内存的区域，malloc 就是在这里面分配的。</li>
<li>接下来的区域是 Memory Mapping Segment。这块地址可以用来把文件映射进内存用的，如果二进制的执行文件依赖于某个动态链接库，就是在这个区域里面将 so 文件映射到了内存中。</li>
<li>再下面就是栈地址段了，主线程的函数调用的函数栈就是用这里的。</li>
</ol>
</li>
<li>如果需要进行更高权限的工作，就需要调用系统调用，进入内核。<ol>
<li>到了内核里面，无论是从哪个进程进来的，看到的是同一个内核空间，看到的是同一个进程列表。</li>
<li>虽然内核栈是各用各的，但是如果想知道的话，还是能够知道每个进程的内核栈在哪里的。所以，如果要访问一些公共的数据结构，需要进行锁保护。</li>
<li>内核的代码访问内核的数据结构，大部分的情况下都是使用虚拟地址的。</li>
<li>虽然内核代码权限很大，但是能够使用的虚拟地址范围也只能在内核空间，也即内核代码访问内核数据结构</li>
<li>在内核里面也会有内核的代码，同样有 Text Segment、Data Segment 和 BSS Segment，内核代码也是 ELF 格式的。</li>
</ol>
</li>
</ol>
</li>
<li>第三，虚拟地址和物理地址如何映射的问题，也即会议室管理员如果管理映射表。<ol>
<li>两级：<ol>
<li>虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址。</li>
<li>32 位环境下，虚拟地址空间共 4GB。如果分成 4KB 一个页，那就是 1M 个页。每个页表项需要 4 个字节来存储，那么整个 4GB 空间的映射就需要 4MB 的内存来存储映射表。如果每个进程都有自己的映射表，100 个进程就需要 400MB 的内存。对于内核来讲，有点大了 。</li>
</ol>
</li>
<li>三级：32位<ol>
<li>页目录有 1K 项，<strong>用 10 位就可以表示访问页目录的哪一项</strong>。这一项其实对应的是一整页的页表项，也即 4K 的页表项。每个页表项也是 4 个字节，因而一整页的页表项是 1k 个。<strong>再用 10 位就可以表示访问页表项的哪一项</strong>，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是 4K，<strong>用 12 位可以定位这个页内的任何一个位置</strong>。<br><img src="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/b6960eb0a7eea008d33f8e0c4facc8b8.jpg" alt></li>
</ol>
</li>
<li>四级：64位</li>
</ol>
</li>
</ol>
</li>
<li>文件管理系统<ol>
<li>第一点，文件系统要有严格的组织形式，使得文件能够以块为单位进行存储。</li>
<li>第二点，文件系统中也要有索引区，用来方便查找一个文件分成的多个块都存放在了什么位置。</li>
<li>第三点，如果文件系统中有的文件是热点文件，近期经常被读取和写入，文件系统应该有缓存层。</li>
<li>第四点，文件应该用文件夹的形式组织起来，方便管理和查询。</li>
<li>第五点，Linux 内核要在自己的内存里面维护一套数据结构，来保存哪些文件被哪些进程打开和使用。<ol>
<li>对于每一个进程，打开的文件都有一个文件描述符。files_struct 里面会有文件描述符数组。每个一个文件描述符是这个数组的下标，里面的内容指向一个 struct file 结构，表示打开的文件。这个结构里面有这个文件对应的 inode，最重要的是这个文件对应的操作 file_operation。如果操作这个文件，就看这个 file_operation 里面的定义了。</li>
</ol>
</li>
</ol>
</li>
<li>输入和输出系统子系统<ol>
<li>（设备控制管理子系统）<ol>
<li>第一层，用设备控制器屏蔽设备差异。</li>
<li>这里需要注意的是，设备控制器不属于操作系统的一部分，但是设备驱动程序属于操作系统的一部分。</li>
<li>操作系统的内核代码可以像调用本地代码一样调用驱动程序的代码，而驱动程序的代码需要发出特殊的面向设备控制器的指令，才能操作设备控制器。</li>
</ol>
</li>
<li>设备驱动管理子系统<ol>
<li>第二层，用驱动程序屏蔽设备控制器差异。</li>
</ol>
</li>
<li>接受外部信息(中断)管理子系统<ol>
<li>第三，用中断控制器统一外部事件处理。</li>
</ol>
</li>
<li>对外输出信息管理子系统(在文件子系统中集成)<ol>
<li>第四，用文件系统接口屏蔽驱动程序的差异。</li>
</ol>
</li>
<li>一般的流程是，一个设备驱动程序初始化的时候，要先注册一个该设备的中断处理函数。咱们讲进程切换的时候说过，中断返回的那一刻是进程切换的时机。中断的时候，触发的函数是 do_IRQ。这个函数是中断处理的统一入口。在这个函数里面，我们可以找到设备驱动程序注册的中断处理函数 Handler，然后执行他进行中断处理。<br><img src="/2020/04/05/b%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/czh_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/linux/%E7%B3%BB%E7%BB%9F/%E5%B0%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E8%A7%A3%EF%BC%8C%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%90%E7%B3%BB%E7%BB%9F/aa9d074d9819f0eb513e11014a5772c0.jpg" alt></li>
</ol>
</li>
<li>异常处理子系统<ol>
<li>信号可以在任何时候发送给某一进程，进程需要为这个信号配置信号处理函数。当某个信号发生的时候，就默认执行这个函数就可以了。</li>
</ol>
</li>
<li>网络子系统：<ol>
<li>操作系统对于网络协议的实现模式是这样的：<ol>
<li>二到四层的处理代码在内核里面，七层的处理代码让应用自己去做。两者需要跨内核态和用户态通信，就需要一个系统调用完成这个衔接，这就是 Socket。<strong>应用层和内核互通的机制，就是通过 Socket 系统调用</strong></li>
</ol>
</li>
<li>整个网络过程：<ol>
<li>如果公司想要和其他公司沟通，我们将请求封装为 HTTP 协议，通过 Socket 发送到内核。内核的网络协议栈里面，在 TCP 层创建用于维护连接、序列号、重传、拥塞控制的数据结构，将 HTTP 包加上 TCP 头，发送给 IP 层，IP 层加上 IP 头，发送给 MAC 层，MAC 层加上 MAC 头，从硬件网卡发出去。</li>
<li>最终网络包会被转发到目标服务器，它发现 MAC 地址匹配，就将 MAC 头取下来，交给上一层。IP 层发现 IP 地址匹配，将 IP 头取下来，交给上一层。TCP 层会根据 TCP 头中的序列号等信息，发现它是一个正确的网络包，就会将网络包缓存起来，等待应用层的读取。</li>
<li>应用层通过 Socket 监听某个端口，因而读取的时候，内核会根据 TCP 头中的端口号，将网络包发给相应的应用。</li>
</ol>
</li>
</ol>
</li>
<li>虚拟化子系统：<ol>
<li>第一种方式，完全虚拟化。<ol>
<li>其实说白了，这是一种“骗人”的方式。虚拟化软件会模拟假的 CPU、内存、网络、硬盘给到虚拟机，让虚拟机里面的内核自我感觉良好，感觉他终于又像个内核了。在 Linux 上，一个叫作 qemu 的工具可以做到这一点。</li>
<li>qemu 向虚拟机里面的客户机操作系统模拟 CPU 和其他的硬件，骗客户机，GuestOS 认为自己和硬件直接打交道，其实是同 qemu 模拟出来的硬件打交道，qemu 会将这些指令转译给真正的硬件。由于所有的指令都要从 qemu 里面过一手，因而性能就会比较差。</li>
</ol>
</li>
<li>第二种方式，硬件辅助虚拟化<ol>
<li>可以使用硬件 CPU 的 Intel-VT 和 AMD-V 技术，需要 CPU 硬件开启这个标志位（一般在 BIOS 里面设置）。当确认开始了标志位之后，通过内核模块 KVM，GuestOS 的 CPU 指令将不用经过 Qemu 转译，直接运行，大大提高了速度。qemu 和 KVM 融合以后，就是 qemu-kvm。</li>
</ol>
</li>
<li>第三种方式称为半虚拟化<ol>
<li>对于网络或者硬盘的访问，我们让虚拟机内核加载特殊的驱动，重新定位自己的身份。虚拟机操作系统的内核知道自己不是物理机内核，没那么高的权限。他很可能要和很多虚拟机共享物理资源，所以学会了排队。虚拟机写硬盘其实写的是一个物理机上的文件，那我的写文件的缓存方式是不是可以变一下。我发送网络包，根本就不是发给真正的网络设备，而是给虚拟的设备，我可不可以直接在内存里面拷贝给它，等等等等。</li>
<li>网络半虚拟化方式是 virtio_net，存储是 virtio_blk。客户机需要安装这些半虚拟化驱动。客户机内核知道自己是虚拟机，所以会直接把数据发送给半虚拟化设备，然后经过特殊处理（例如排队、缓存、批量处理等性能优化方式），最终发送给真正的硬件。这在一定程度上提高了性能。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="一个子系统：系统都是服务行业，被别人调用的"><a href="#一个子系统：系统都是服务行业，被别人调用的" class="headerlink" title="一个子系统：系统都是服务行业，被别人调用的"></a>一个子系统：系统都是服务行业，被别人调用的</h4><ul>
<li>系统结构：有哪些组成部分，各个部分之间的关系</li>
<li>系统运转流程图：这个过程中可能会涉及到不同的数据结构算法</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/120/">120</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhiheng Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1194</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">103</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhiheng Chen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">18:20</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        






  <script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.getAttribute('data-flag-title');

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=QiM1vjQ7SAoirKD4qY57L82O-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id'     : 'QiM1vjQ7SAoirKD4qY57L82O-gzGzoHsz',
            'X-LC-Key'    : 'aOHhzmfDblK0HGWUqEyb6ra2',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
